{"version":3,"sources":["webpack:///app.9b5e1580122971279aa2.js","webpack:///webpack/bootstrap c64c6309429951ecb8db","webpack:///../Vue-projects/src/main.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.global.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.to-iobject.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.cof.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.core.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.descriptors.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.fails.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.has.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.property-desc.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.shared.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.uid.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.wks.js","webpack:///./~/vue/dist/vue.js","webpack:///../Vue-projects/lib/marked.js","webpack:///App.vue","webpack:///toolbox.vue","webpack:///./~/babel-runtime/core-js/symbol.js","webpack:///./~/babel-runtime/helpers/typeof.js","webpack:///./~/babel-runtime/~/core-js/library/fn/symbol/index.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.a-function.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.an-object.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.ctx.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.defined.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.enum-keys.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.export.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.get-names.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.hide.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.iobject.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.is-array.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.is-object.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.keyof.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.library.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.redefine.js","webpack:///./~/babel-runtime/~/core-js/library/modules/$.set-to-string-tag.js","webpack:///./~/babel-runtime/~/core-js/library/modules/es6.symbol.js","webpack:///./src/App.vue?d818","webpack:///./src/components/toolbox.vue?cdc7","webpack:///./src/App.vue","webpack:///./src/components/toolbox.vue"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_vue","_vue2","_App","_App2","el","components","App","$Object","Object","create","getProto","getPrototypeOf","isEnum","propertyIsEnumerable","getDesc","getOwnPropertyDescriptor","setDesc","defineProperty","setDescs","defineProperties","getKeys","keys","getNames","getOwnPropertyNames","getSymbols","getOwnPropertySymbols","each","forEach","global","window","Math","self","Function","__g","IObject","defined","it","toString","slice","core","version","__e","get","a","exec","e","hasOwnProperty","key","bitmap","value","enumerable","configurable","writable","SHARED","store","px","random","concat","undefined","uid","Symbol","name","factory","this","set","val","hasOwn","_isVue","_data","ob","__ob__","convert","dep","notify","vms","i","length","vm","_proxy","_digest","del","_unproxy","isLiteral","exp","literalValueRE","test","isReserved","str","charCodeAt","_toString","toNumber","parsed","Number","isNaN","toBoolean","stripQuotes","b","camelize","replace","camelizeRE","toUpper","_","toUpperCase","hyphenate","hyphenateRE","toLowerCase","classify","classifyRE","bind$1","fn","ctx","l","arguments","apply","toArray","list","start","ret","Array","extend","to","from","isObject","isPlainObject","OBJECT_STRING","def","_debounce","func","wait","timeout","args","context","timestamp","result","later","last","Date","now","setTimeout","indexOf","arr","cancellable","cb","cancelled","cancel","looseEqual","JSON","stringify","Cache","limit","size","head","tail","_keymap","pushFilter","filter","lastFilterIndex","trim","tokens","match","filterTokenRE","map","processFilterArg","dir","filters","push","arg","reservedArgRE","dynamic","stripped","parseDirective","s","hit","cache$1","inSingle","inDouble","curly","square","paren","prev","expression","put","escapeRegex","regexEscapeRE","compileRegex","open","config","delimiters","close","unsafeOpen","unsafeDelimiters","unsafeClose","tagRE","RegExp","htmlRE","cache","parseText","text","index","html","first","oneTime","lastIndex","tag","tokensToExp","token","formatToken","join","single","$eval","inlineFilters","filterRE$1","appendWithTransition","target","applyTransition","appendChild","beforeWithTransition","before","removeWithTransition","remove","direction","op","transition","__v_trans","hooks","transitionEndEvent","_isCompiled","$parent","action","query","selector","document","querySelector","warn","inDoc","node","doc","documentElement","parent","parentNode","nodeType","contains","getAttr","_attr","getAttribute","removeAttribute","getBindAttr","hasBindAttr","hasAttribute","insertBefore","after","nextSibling","removeChild","prepend","firstChild","replaceChild","on$1","event","addEventListener","off","removeEventListener","setClass","cls","isIE9","SVGElement","setAttribute","className","addClass","classList","add","cur","removeClass","tar","extractContent","asFragment","child","rawContent","isTemplate","content","DocumentFragment","hasChildNodes","trimNode","createDocumentFragment","createElement","lastChild","data","tagName","createAnchor","persist","anchor","debug","createComment","createTextNode","__vue_anchor","findRef","hasAttributes","attrs","attributes","refRE","mapNodeRange","end","next","removeNodeRange","frag","onRemoved","removed","done","nodes","checkComponentAttr","options","hasAttrs","commonTagRE","reservedTagRE","getIsBinding","resolveAsset","is","initProp","prop","path","coerceProp","assertProp","raw","required","expectedType","type","valid","String","Boolean","isArray","formatType","formatValue","validator","coerce","charAt","prototype","mergeData","toVal","fromVal","mergeAssets","parentVal","childVal","res","guardArrayAssets","guardComponents","ids","Vue","guardProps","props","assets","asset","mergeOptions","mergeField","strat","strats","defaultStrat","mixins","camelizedId","assertAsset","Dep","uid$3","subs","Observer","augment","hasProto","protoAugment","copyAugment","arrayMethods","arrayKeys","observeArray","walk","src","__proto__","observe","isExtensible","addVm","defineReactive","getter","setter","convertAllProperties","property","childOb","depend","newVal","initMixin","_init","$el","$root","$children","$refs","$els","_watchers","_directives","_uid","_events","_eventsCount","_isFragment","_fragment","_fragmentStart","_fragmentEnd","_isDestroyed","_isReady","_isAttached","_isBeingDestroyed","_unlinkFn","_context","_scope","_frag","children","$options","constructor","_updateRef","_callHook","_initState","_initEvents","$mount","getPathCharType","ch","code","formatSubPath","trimmed","parse","maybeUnescapeQuote","nextChar","mode","IN_SINGLE_QUOTE","IN_DOUBLE_QUOTE","newChar","actions","APPEND","typeMap","BEFORE_PATH","subPathDepth","PUSH","INC_SUB_PATH_DEPTH","PUSH_SUB_PATH","IN_SUB_PATH","pathStateMachine","ERROR","AFTER_PATH","parsePath","pathCache","getPath","parseExpression","setPath","original","warnNonExistent","$set","save","isString","saved","newlineRE","rewrite","allowedKeywordsRE","restoreRE","restore","compileGetter","improperKeywordsRE","body","saveRE","wsRE","identRE","makeGetterFn","compileSetter","scope","needSet","expressionCache","isSimplePath","pathTestRE","booleanLiteralRE","resetBatcherState","queue","userQueue","has","circular","waiting","internalQueueDepleted","flushBatcherQueue","runBatcherQueue","inBrowser","__VUE_DEVTOOLS_GLOBAL_HOOK__","emit","watcher","run","_maxUpdateCount","splice","pushWatcher","user","q","nextTick","Watcher","expOrFn","isFn","uid$2","active","dirty","lazy","deps","newDeps","prevError","twoWay","queued","shallow","traverse","normalize","propCache","prefix","camel","upper","testEl","style","prefixed","prefixes","camelPrefixes","keyFilter","handler","codes","charCode","parseInt","keyCodes","keyCode","stopFilter","stopPropagation","preventFilter","preventDefault","getValue","multi","init","selected","_value","indexOf$1","isRealTemplate","stringToFragment","templateString","templateCache","tagMatch","tagRE$1","entityMatch","entityRE","wrap","efault","depth","suffix","innerHTML","nodeToFragment","textContent","clonedNode","cloneNode","querySelectorAll","cloned","hasBrokenTemplate","tempClone","hasTextareaCloneBug","parseTemplate","template","shouldClone","idSelectorCache","getElementById","Fragment","linker","host","parentFrag","childFrags","inserted","unlink","childNodes","singleBefore","singleRemove","multiBefore","multiRemove","__vfrag__","withTransition","method","callHook","attach","shouldCallRemove","beforeRemove","detach","destroy","FragmentFactory","cid","cacheId","outerHTML","linkerCache","compile","findPrevFrag","previousSibling","forId","findVmFromFrag","__vue__","range","n","pushJob","job","queue$1","flush","f","offsetHeight","Transition","enterClass","leaveClass","pendingCssEvent","pendingCssCb","pendingJsCb","justEntered","entered","left","typeCache","TYPE_TRANSITION","TYPE_ANIMATION","isHidden","offsetWidth","getClientRects","stringToObject","split","contains$1","compileProps","propOptions","attr","names","empty","identRE$1","propBindingModes","ONE_WAY","TWO_WAY","ONE_TIME","optimizedLiteral","settablePathRE","parentPath","makePropsLinkFn","_props","getDefault","$get","_bindDir","propDef","partial","nodeLinkFn","_asComponent","compileNode","childLinkFn","terminal","compileNodeList","dirs","linkAndCapture","makeUnlinkFn","originalDirCount","sort","directiveComparator","_bind","descriptor","priority","DEFAULT_PRIORITY","contextDirs","destroying","teardownDirs","_teardown","$remove","compileAndLinkProps","propsLinkFn","propDirs","compileRoot","contextOptions","contextLinkFn","replacerLinkFn","containerAttrs","_containerAttrs","replacerAttrs","_replacerAttrs","compileDirectives","onRE","plural","selfDirs","compileElement","compileTextNode","linkFn","checkTerminalDirectives","checkElementDirectives","checkComponent","_skip","removeText","wholeText","processTextToken","makeTextNodeLinkFn","setTokenType","publicDirectives","fragClone","nodeList","linkFns","makeChildLinkFn","childrenLinkFn","makeTerminalNodeLinkFn","component","ref","internalDirectives","modifiers","literal","componentLinkFn","skip","previousElementSibling","dirName","terminalDirectives","pushDir","interpTokens","hasOneTimeToken","hasOneTime","rawName","rawValue","interp","dirDef","parseModifiers","modifierRE","bind","some","transitionRE","bindRE","on","argRE","makeNodeLinkFn","directives","transclude","extractAttrs","_content","transcludeTemplate","replacer","mergeAttrs","specialCharRE","stateMixin","noop","makeComputedGetter","owner","evaluate","newData","_setData","_initProps","_initMeta","_initMethods","_initData","_initComputed","_propsUnlinkFn","propsData","optionsDataFn","optionsData","oldData","removeVm","update","computed","userDef","methods","metas","_meta","eventsMixin","registerComponentEvents","eventRE","_fromParent","$on","registerCallbacks","hash","handlers","j","register","onAttached","callAttach","onDetached","callDetach","events","watch","_initDOMHooks","hook","$emit","Directive","_locked","_bound","_listeners","_host","_vue_directives","lifecycleMixin","_ref","refs","_compile","_initElement","contentLinkFn","rootLinker","ctor","_linkerCachable","rootUnlinkFn","contentUnlinkFn","_destroy","deferCleanup","_cleanup","destroyReady","pendingRemoval","cleanupIfPossible","$destroy","teardown","$off","miscMixin","_applyFilters","oldValue","write","offset","k","read","_resolveComponent","resolved","requested","pendingCallbacks","cbs","reason","globalAPI","createClass","util","compiler","parsers","text$1","directive","extendOptions","Super","isFirstExtend","_Ctor","Sub","_assetTypes","use","plugin","installed","unshift","install","mixin","definition","dataAPI","clean","asStatement","$arguments","$delete","$watch","deep","sync","immediate","filterRE","$interpolate","$log","console","log","domAPI","insert","op1","op2","targetIsDetached","shouldCallHook","append","beforeWithCb","removeWithCb","$nextTick","$appendTo","$prependTo","$before","$after","inDocument","realCb","eventsAPI","modifyListenerCount","count","hookRE","$once","isSource","shouldPropagate","hasParentCbs","$broadcast","source","$dispatch","lifecycleAPI","ready","$compile","limitBy","filterBy","search","delimiter","convertArray","item","reduce","$value","$key","orderBy","sortKey","reverse","order","extractFragment","main","__v_selected","navigator","userAgent","isAndroid","transitionProp","animationProp","animationEndEvent","isWebkitTrans","ontransitionend","onwebkittransitionend","isWebkitAnim","onanimationend","onwebkitanimationend","nextTickHandler","pending","copies","callbacks","timerFunc","MutationObserver","counter","observer","textNode","characterData","entry","newer","older","shift","returnEntry","freeze","silent","async","warnExpressionErrors","_delimitersChanged","_propBindingModes","hasConsole","msg","Error","stack","optionMergeStrategies","instanceData","defaultData","created","attached","detached","beforeCompile","compiled","beforeDestroy","destroyed","paramAttributes","arrayProto","addSub","sub","removeSub","addDep","items","debounce","IN_PATH","BEFORE_IDENT","IN_IDENT","ws","ident","[","eof",".","0","number","'","\"","]","else","allowedKeywords","improperKeywords","beforeGet","preProcess","postProcess","afterGet","forContext","$forContext","alias","_withLock","$index","current","depIds","cloak","ON","MODEL","BIND","TRANSITION","EL","COMPONENT","PARTIAL","SLOT","FOR","IF","unbind","importantRE","cssText","handleObject","handleSingle","isImportant","setProperty","removeProperty","xlinkNS","xlinkRE","disallowedInterpAttrRE","attrWithPropsRE","modelProps","true-value","false-value","invalid","modelProp","model","__v_model","listener","setAttributeNS","esc","tab","enter","space","delete","up","right","down","acceptStatement","iframeBind","contentWindow","stop","prevent","reset","checkbox","getBooleanValue","checked","_trueValue","_falseValue","params","_watcher","afterBind","select","forceUpdate","multiple","initValue","selectedIndex","radio","text$2","isRange","composing","focused","rawListener","hasjQuery","jQuery","checkFilters","hasRead","hasWrite","_unbind","show","nextElementSibling","elseEl","toggle","display","legend","tr","col","td","th","option","optgroup","thead","tbody","colgroup","caption","tfoot","g","defs","symbol","image","circle","ellipse","line","polygon","polyline","rect","t","placeholder","vIf","elseFactory","elseFrag","uid$1","vFor","inMatch","itMatch","iterator","isOption","diff","updateRef","updateModel","primitive","convertedFromObject","fromObject","trackByKey","trackBy","oldFrags","frags","getCachedFrag","reused","fresh","removalIndex","totalRemoved","deleteCachedFrag","targetPrev","prevEl","currentPrev","insertionIndex","staggerCb","staggerAnchor","move","parentScope","cacheFrag","staggerAmount","getStagger","total","warnDuplicate","trans","stagger","_preProcess","_postProcess","swap","for","if","transDurationProp","animDurationProp","p$1","cancelPending","callHookWithCb","enterCancelled","enterNextTick","enterDone","getCssTransitionType","setupCssCb","leave","leaveCancelled","leaveDone","leaveNextTick","hasPending","hidden","css","inlineStyles","computedStyles","getComputedStyle","transDuration","animDuration","onEnd","oldId","bindingModes","childKey","parentKey","parentWatcher","childWatcher","keepAlive","inlineTemplate","pendingComponentCb","Component","pendingRemovals","pendingRemovalCb","setComponent","invalidatePending","resolveComponent","mountComponent","unbuild","childVM","ComponentName","activateHook","activate","cached","getCached","newComponent","build","waitingFor","extraOptions","_isRouterView","defer","_inactive","transitionMode","vClass","handleArray","cleanup","prevKeys","class","_setupParams","_checkStatement","_update","oldVal","mappedKey","_setupParamWatcher","called","unwatch","paramWatchers","_paramUnwatchFns","$event","listeners","unwatchFns","digitsRE","json","indent","capitalize","uppercase","lowercase","currency","_currency","parseFloat","isFinite","stringified","abs","toFixed","_int","_float","sign","pluralize","delay","slot","fallback","slotName","tryCompile","namedSlot","elementDirectives","_namedSlot","transitions","partials","__WEBPACK_AMD_DEFINE_RESULT__","_typeof2","_typeof3","Lexer","links","marked","defaults","rules","block","normal","gfm","tables","InlineLexer","inline","renderer","Renderer","breaks","pedantic","Parser","escape","encode","unescape","fromCharCode","substring","regex","opt","merge","callback","highlight","lex","err","out","lang","escaped","message","newline","fences","hr","heading","nptable","lheading","blockquote","table","paragraph","bullet","_tag","lexer","top","bq","loose","cap","bull","header","align","cells","ordered","smartLists","sanitize","pre","sanitizer","href","title","autolink","url","link","reflink","nolink","strong","em","br","_inside","_href","output","mangle","inLink","outputLink","codespan","smartypants","langPrefix","quote","level","headerPrefix","xhtml","listitem","tablerow","tablecell","flags","prot","decodeURIComponent","parser","tok","pop","peek","row","cell","setOptions","inlineLexer","_marked","_marked2","_toolbox","_toolbox2","article","htmlDataUrl","mdDataUrl","dragenter","dragover","drop","dt","dataTransfer","files","fileReader","FileReader","readAsText","onloadend","dropbox","outputHtml","toolbox","localStorage","swal","createUrl","blobObj","Blob","objectURL","URL","createObjectURL","myValue","myField","selection","focus","sel","createRange","selectionStart","startPos","endPos","selectionEnd","restoreTop","scrollTop","_Symbol","TypeError","aFunction","that","$","symbols","PROTOTYPE","$export","own","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","P","IS_BIND","B","IS_WRAP","W","C","param","toIObject","windowNames","getWindowNames","createDesc","object","cof","O","TAG","stat","DESCRIPTORS","redefine","$fails","shared","setToStringTag","wks","keyOf","$names","enumKeys","anObject","_create","$Symbol","$JSON","_stringify","HIDDEN","SymbolRegistry","AllSymbols","useNative","ObjectProto","setSymbolDesc","D","protoDesc","sym","_k","isSymbol","$defineProperty","$defineProperties","$create","$propertyIsEnumerable","E","$getOwnPropertyDescriptor","$getOwnPropertyNames","$getOwnPropertySymbols","$stringify","$replacer","$$","buggyJSON","symbolStatics","keyFor","useSetter","useSimple","__vue_script__","__vue_template__"],"mappings":"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","file":"app.9b5e1580122971279aa2.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./static/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _vue = __webpack_require__(13);\n\t\n\tvar _vue2 = _interopRequireDefault(_vue);\n\t\n\tvar _App = __webpack_require__(40);\n\t\n\tvar _App2 = _interopRequireDefault(_App);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tnew _vue2.default({\n\t  el: 'body',\n\t  components: { App: _App2.default }\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tvar $Object = Object;\n\tmodule.exports = {\n\t  create:     $Object.create,\n\t  getProto:   $Object.getPrototypeOf,\n\t  isEnum:     {}.propertyIsEnumerable,\n\t  getDesc:    $Object.getOwnPropertyDescriptor,\n\t  setDesc:    $Object.defineProperty,\n\t  setDescs:   $Object.defineProperties,\n\t  getKeys:    $Object.keys,\n\t  getNames:   $Object.getOwnPropertyNames,\n\t  getSymbols: $Object.getOwnPropertySymbols,\n\t  each:       [].forEach\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(28)\n\t  , defined = __webpack_require__(23);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '1.2.6'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(7)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(2)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store  = __webpack_require__(10)('wks')\n\t  , uid    = __webpack_require__(11)\n\t  , Symbol = __webpack_require__(2).Symbol;\n\tmodule.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Vue.js v1.0.14\n\t * (c) 2016 Evan You\n\t * Released under the MIT License.\n\t */\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  global.Vue = factory();\n\t}(this, function () { 'use strict';\n\t\n\t  function set(obj, key, val) {\n\t    if (hasOwn(obj, key)) {\n\t      obj[key] = val;\n\t      return;\n\t    }\n\t    if (obj._isVue) {\n\t      set(obj._data, key, val);\n\t      return;\n\t    }\n\t    var ob = obj.__ob__;\n\t    if (!ob) {\n\t      obj[key] = val;\n\t      return;\n\t    }\n\t    ob.convert(key, val);\n\t    ob.dep.notify();\n\t    if (ob.vms) {\n\t      var i = ob.vms.length;\n\t      while (i--) {\n\t        var vm = ob.vms[i];\n\t        vm._proxy(key);\n\t        vm._digest();\n\t      }\n\t    }\n\t    return val;\n\t  }\n\t\n\t  /**\n\t   * Delete a property and trigger change if necessary.\n\t   *\n\t   * @param {Object} obj\n\t   * @param {String} key\n\t   */\n\t\n\t  function del(obj, key) {\n\t    if (!hasOwn(obj, key)) {\n\t      return;\n\t    }\n\t    delete obj[key];\n\t    var ob = obj.__ob__;\n\t    if (!ob) {\n\t      return;\n\t    }\n\t    ob.dep.notify();\n\t    if (ob.vms) {\n\t      var i = ob.vms.length;\n\t      while (i--) {\n\t        var vm = ob.vms[i];\n\t        vm._unproxy(key);\n\t        vm._digest();\n\t      }\n\t    }\n\t  }\n\t\n\t  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\t  /**\n\t   * Check whether the object has the property.\n\t   *\n\t   * @param {Object} obj\n\t   * @param {String} key\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function hasOwn(obj, key) {\n\t    return hasOwnProperty.call(obj, key);\n\t  }\n\t\n\t  /**\n\t   * Check if an expression is a literal value.\n\t   *\n\t   * @param {String} exp\n\t   * @return {Boolean}\n\t   */\n\t\n\t  var literalValueRE = /^\\s?(true|false|[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\t\n\t  function isLiteral(exp) {\n\t    return literalValueRE.test(exp);\n\t  }\n\t\n\t  /**\n\t   * Check if a string starts with $ or _\n\t   *\n\t   * @param {String} str\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function isReserved(str) {\n\t    var c = (str + '').charCodeAt(0);\n\t    return c === 0x24 || c === 0x5F;\n\t  }\n\t\n\t  /**\n\t   * Guard text output, make sure undefined outputs\n\t   * empty string\n\t   *\n\t   * @param {*} value\n\t   * @return {String}\n\t   */\n\t\n\t  function _toString(value) {\n\t    return value == null ? '' : value.toString();\n\t  }\n\t\n\t  /**\n\t   * Check and convert possible numeric strings to numbers\n\t   * before setting back to data\n\t   *\n\t   * @param {*} value\n\t   * @return {*|Number}\n\t   */\n\t\n\t  function toNumber(value) {\n\t    if (typeof value !== 'string') {\n\t      return value;\n\t    } else {\n\t      var parsed = Number(value);\n\t      return isNaN(parsed) ? value : parsed;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Convert string boolean literals into real booleans.\n\t   *\n\t   * @param {*} value\n\t   * @return {*|Boolean}\n\t   */\n\t\n\t  function toBoolean(value) {\n\t    return value === 'true' ? true : value === 'false' ? false : value;\n\t  }\n\t\n\t  /**\n\t   * Strip quotes from a string\n\t   *\n\t   * @param {String} str\n\t   * @return {String | false}\n\t   */\n\t\n\t  function stripQuotes(str) {\n\t    var a = str.charCodeAt(0);\n\t    var b = str.charCodeAt(str.length - 1);\n\t    return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n\t  }\n\t\n\t  /**\n\t   * Camelize a hyphen-delmited string.\n\t   *\n\t   * @param {String} str\n\t   * @return {String}\n\t   */\n\t\n\t  var camelizeRE = /-(\\w)/g;\n\t\n\t  function camelize(str) {\n\t    return str.replace(camelizeRE, toUpper);\n\t  }\n\t\n\t  function toUpper(_, c) {\n\t    return c ? c.toUpperCase() : '';\n\t  }\n\t\n\t  /**\n\t   * Hyphenate a camelCase string.\n\t   *\n\t   * @param {String} str\n\t   * @return {String}\n\t   */\n\t\n\t  var hyphenateRE = /([a-z\\d])([A-Z])/g;\n\t\n\t  function hyphenate(str) {\n\t    return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n\t  }\n\t\n\t  /**\n\t   * Converts hyphen/underscore/slash delimitered names into\n\t   * camelized classNames.\n\t   *\n\t   * e.g. my-component => MyComponent\n\t   *      some_else    => SomeElse\n\t   *      some/comp    => SomeComp\n\t   *\n\t   * @param {String} str\n\t   * @return {String}\n\t   */\n\t\n\t  var classifyRE = /(?:^|[-_\\/])(\\w)/g;\n\t\n\t  function classify(str) {\n\t    return str.replace(classifyRE, toUpper);\n\t  }\n\t\n\t  /**\n\t   * Simple bind, faster than native\n\t   *\n\t   * @param {Function} fn\n\t   * @param {Object} ctx\n\t   * @return {Function}\n\t   */\n\t\n\t  function bind$1(fn, ctx) {\n\t    return function (a) {\n\t      var l = arguments.length;\n\t      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Convert an Array-like object to a real Array.\n\t   *\n\t   * @param {Array-like} list\n\t   * @param {Number} [start] - start index\n\t   * @return {Array}\n\t   */\n\t\n\t  function toArray(list, start) {\n\t    start = start || 0;\n\t    var i = list.length - start;\n\t    var ret = new Array(i);\n\t    while (i--) {\n\t      ret[i] = list[i + start];\n\t    }\n\t    return ret;\n\t  }\n\t\n\t  /**\n\t   * Mix properties into target object.\n\t   *\n\t   * @param {Object} to\n\t   * @param {Object} from\n\t   */\n\t\n\t  function extend(to, from) {\n\t    var keys = Object.keys(from);\n\t    var i = keys.length;\n\t    while (i--) {\n\t      to[keys[i]] = from[keys[i]];\n\t    }\n\t    return to;\n\t  }\n\t\n\t  /**\n\t   * Quick object check - this is primarily used to tell\n\t   * Objects from primitive values when we know the value\n\t   * is a JSON-compliant type.\n\t   *\n\t   * @param {*} obj\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function isObject(obj) {\n\t    return obj !== null && typeof obj === 'object';\n\t  }\n\t\n\t  /**\n\t   * Strict object type check. Only returns true\n\t   * for plain JavaScript objects.\n\t   *\n\t   * @param {*} obj\n\t   * @return {Boolean}\n\t   */\n\t\n\t  var toString = Object.prototype.toString;\n\t  var OBJECT_STRING = '[object Object]';\n\t\n\t  function isPlainObject(obj) {\n\t    return toString.call(obj) === OBJECT_STRING;\n\t  }\n\t\n\t  /**\n\t   * Array type check.\n\t   *\n\t   * @param {*} obj\n\t   * @return {Boolean}\n\t   */\n\t\n\t  var isArray = Array.isArray;\n\t\n\t  /**\n\t   * Define a non-enumerable property\n\t   *\n\t   * @param {Object} obj\n\t   * @param {String} key\n\t   * @param {*} val\n\t   * @param {Boolean} [enumerable]\n\t   */\n\t\n\t  function def(obj, key, val, enumerable) {\n\t    Object.defineProperty(obj, key, {\n\t      value: val,\n\t      enumerable: !!enumerable,\n\t      writable: true,\n\t      configurable: true\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Debounce a function so it only gets called after the\n\t   * input stops arriving after the given wait period.\n\t   *\n\t   * @param {Function} func\n\t   * @param {Number} wait\n\t   * @return {Function} - the debounced function\n\t   */\n\t\n\t  function _debounce(func, wait) {\n\t    var timeout, args, context, timestamp, result;\n\t    var later = function later() {\n\t      var last = Date.now() - timestamp;\n\t      if (last < wait && last >= 0) {\n\t        timeout = setTimeout(later, wait - last);\n\t      } else {\n\t        timeout = null;\n\t        result = func.apply(context, args);\n\t        if (!timeout) context = args = null;\n\t      }\n\t    };\n\t    return function () {\n\t      context = this;\n\t      args = arguments;\n\t      timestamp = Date.now();\n\t      if (!timeout) {\n\t        timeout = setTimeout(later, wait);\n\t      }\n\t      return result;\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Manual indexOf because it's slightly faster than\n\t   * native.\n\t   *\n\t   * @param {Array} arr\n\t   * @param {*} obj\n\t   */\n\t\n\t  function indexOf(arr, obj) {\n\t    var i = arr.length;\n\t    while (i--) {\n\t      if (arr[i] === obj) return i;\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * Make a cancellable version of an async callback.\n\t   *\n\t   * @param {Function} fn\n\t   * @return {Function}\n\t   */\n\t\n\t  function cancellable(fn) {\n\t    var cb = function cb() {\n\t      if (!cb.cancelled) {\n\t        return fn.apply(this, arguments);\n\t      }\n\t    };\n\t    cb.cancel = function () {\n\t      cb.cancelled = true;\n\t    };\n\t    return cb;\n\t  }\n\t\n\t  /**\n\t   * Check if two values are loosely equal - that is,\n\t   * if they are plain objects, do they have the same shape?\n\t   *\n\t   * @param {*} a\n\t   * @param {*} b\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function looseEqual(a, b) {\n\t    /* eslint-disable eqeqeq */\n\t    return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\n\t    /* eslint-enable eqeqeq */\n\t  }\n\t\n\t  var hasProto = ('__proto__' in {});\n\t\n\t  // Browser environment sniffing\n\t  var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\t\n\t  var isIE9 = inBrowser && navigator.userAgent.toLowerCase().indexOf('msie 9.0') > 0;\n\t\n\t  var isAndroid = inBrowser && navigator.userAgent.toLowerCase().indexOf('android') > 0;\n\t\n\t  var transitionProp = undefined;\n\t  var transitionEndEvent = undefined;\n\t  var animationProp = undefined;\n\t  var animationEndEvent = undefined;\n\t\n\t  // Transition property/event sniffing\n\t  if (inBrowser && !isIE9) {\n\t    var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\n\t    var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\n\t    transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\n\t    transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\n\t    animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\n\t    animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\n\t  }\n\t\n\t  /**\n\t   * Defer a task to execute it asynchronously. Ideally this\n\t   * should be executed as a microtask, so we leverage\n\t   * MutationObserver if it's available, and fallback to\n\t   * setTimeout(0).\n\t   *\n\t   * @param {Function} cb\n\t   * @param {Object} ctx\n\t   */\n\t\n\t  var nextTick = (function () {\n\t    var callbacks = [];\n\t    var pending = false;\n\t    var timerFunc;\n\t    function nextTickHandler() {\n\t      pending = false;\n\t      var copies = callbacks.slice(0);\n\t      callbacks = [];\n\t      for (var i = 0; i < copies.length; i++) {\n\t        copies[i]();\n\t      }\n\t    }\n\t    /* istanbul ignore if */\n\t    if (typeof MutationObserver !== 'undefined') {\n\t      var counter = 1;\n\t      var observer = new MutationObserver(nextTickHandler);\n\t      var textNode = document.createTextNode(counter);\n\t      observer.observe(textNode, {\n\t        characterData: true\n\t      });\n\t      timerFunc = function () {\n\t        counter = (counter + 1) % 2;\n\t        textNode.data = counter;\n\t      };\n\t    } else {\n\t      timerFunc = setTimeout;\n\t    }\n\t    return function (cb, ctx) {\n\t      var func = ctx ? function () {\n\t        cb.call(ctx);\n\t      } : cb;\n\t      callbacks.push(func);\n\t      if (pending) return;\n\t      pending = true;\n\t      timerFunc(nextTickHandler, 0);\n\t    };\n\t  })();\n\t\n\t  function Cache(limit) {\n\t    this.size = 0;\n\t    this.limit = limit;\n\t    this.head = this.tail = undefined;\n\t    this._keymap = Object.create(null);\n\t  }\n\t\n\t  var p = Cache.prototype;\n\t\n\t  /**\n\t   * Put <value> into the cache associated with <key>.\n\t   * Returns the entry which was removed to make room for\n\t   * the new entry. Otherwise undefined is returned.\n\t   * (i.e. if there was enough room already).\n\t   *\n\t   * @param {String} key\n\t   * @param {*} value\n\t   * @return {Entry|undefined}\n\t   */\n\t\n\t  p.put = function (key, value) {\n\t    var entry = {\n\t      key: key,\n\t      value: value\n\t    };\n\t    this._keymap[key] = entry;\n\t    if (this.tail) {\n\t      this.tail.newer = entry;\n\t      entry.older = this.tail;\n\t    } else {\n\t      this.head = entry;\n\t    }\n\t    this.tail = entry;\n\t    if (this.size === this.limit) {\n\t      return this.shift();\n\t    } else {\n\t      this.size++;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Purge the least recently used (oldest) entry from the\n\t   * cache. Returns the removed entry or undefined if the\n\t   * cache was empty.\n\t   */\n\t\n\t  p.shift = function () {\n\t    var entry = this.head;\n\t    if (entry) {\n\t      this.head = this.head.newer;\n\t      this.head.older = undefined;\n\t      entry.newer = entry.older = undefined;\n\t      this._keymap[entry.key] = undefined;\n\t    }\n\t    return entry;\n\t  };\n\t\n\t  /**\n\t   * Get and register recent use of <key>. Returns the value\n\t   * associated with <key> or undefined if not in cache.\n\t   *\n\t   * @param {String} key\n\t   * @param {Boolean} returnEntry\n\t   * @return {Entry|*}\n\t   */\n\t\n\t  p.get = function (key, returnEntry) {\n\t    var entry = this._keymap[key];\n\t    if (entry === undefined) return;\n\t    if (entry === this.tail) {\n\t      return returnEntry ? entry : entry.value;\n\t    }\n\t    // HEAD--------------TAIL\n\t    //   <.older   .newer>\n\t    //  <--- add direction --\n\t    //   A  B  C  <D>  E\n\t    if (entry.newer) {\n\t      if (entry === this.head) {\n\t        this.head = entry.newer;\n\t      }\n\t      entry.newer.older = entry.older; // C <-- E.\n\t    }\n\t    if (entry.older) {\n\t      entry.older.newer = entry.newer; // C. --> E\n\t    }\n\t    entry.newer = undefined; // D --x\n\t    entry.older = this.tail; // D. --> E\n\t    if (this.tail) {\n\t      this.tail.newer = entry; // E. <-- D\n\t    }\n\t    this.tail = entry;\n\t    return returnEntry ? entry : entry.value;\n\t  };\n\t\n\t  var cache$1 = new Cache(1000);\n\t  var filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\n\t  var reservedArgRE = /^in$|^-?\\d+/;\n\t\n\t  /**\n\t   * Parser state\n\t   */\n\t\n\t  var str;\n\t  var dir;\n\t  var c;\n\t  var prev;\n\t  var i;\n\t  var l;\n\t  var lastFilterIndex;\n\t  var inSingle;\n\t  var inDouble;\n\t  var curly;\n\t  var square;\n\t  var paren;\n\t  /**\n\t   * Push a filter to the current directive object\n\t   */\n\t\n\t  function pushFilter() {\n\t    var exp = str.slice(lastFilterIndex, i).trim();\n\t    var filter;\n\t    if (exp) {\n\t      filter = {};\n\t      var tokens = exp.match(filterTokenRE);\n\t      filter.name = tokens[0];\n\t      if (tokens.length > 1) {\n\t        filter.args = tokens.slice(1).map(processFilterArg);\n\t      }\n\t    }\n\t    if (filter) {\n\t      (dir.filters = dir.filters || []).push(filter);\n\t    }\n\t    lastFilterIndex = i + 1;\n\t  }\n\t\n\t  /**\n\t   * Check if an argument is dynamic and strip quotes.\n\t   *\n\t   * @param {String} arg\n\t   * @return {Object}\n\t   */\n\t\n\t  function processFilterArg(arg) {\n\t    if (reservedArgRE.test(arg)) {\n\t      return {\n\t        value: toNumber(arg),\n\t        dynamic: false\n\t      };\n\t    } else {\n\t      var stripped = stripQuotes(arg);\n\t      var dynamic = stripped === arg;\n\t      return {\n\t        value: dynamic ? arg : stripped,\n\t        dynamic: dynamic\n\t      };\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Parse a directive value and extract the expression\n\t   * and its filters into a descriptor.\n\t   *\n\t   * Example:\n\t   *\n\t   * \"a + 1 | uppercase\" will yield:\n\t   * {\n\t   *   expression: 'a + 1',\n\t   *   filters: [\n\t   *     { name: 'uppercase', args: null }\n\t   *   ]\n\t   * }\n\t   *\n\t   * @param {String} str\n\t   * @return {Object}\n\t   */\n\t\n\t  function parseDirective(s) {\n\t\n\t    var hit = cache$1.get(s);\n\t    if (hit) {\n\t      return hit;\n\t    }\n\t\n\t    // reset parser state\n\t    str = s;\n\t    inSingle = inDouble = false;\n\t    curly = square = paren = 0;\n\t    lastFilterIndex = 0;\n\t    dir = {};\n\t\n\t    for (i = 0, l = str.length; i < l; i++) {\n\t      prev = c;\n\t      c = str.charCodeAt(i);\n\t      if (inSingle) {\n\t        // check single quote\n\t        if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\n\t      } else if (inDouble) {\n\t        // check double quote\n\t        if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\n\t      } else if (c === 0x7C && // pipe\n\t      str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\n\t        if (dir.expression == null) {\n\t          // first filter, end of expression\n\t          lastFilterIndex = i + 1;\n\t          dir.expression = str.slice(0, i).trim();\n\t        } else {\n\t          // already has filter\n\t          pushFilter();\n\t        }\n\t      } else {\n\t        switch (c) {\n\t          case 0x22:\n\t            inDouble = true;break; // \"\n\t          case 0x27:\n\t            inSingle = true;break; // '\n\t          case 0x28:\n\t            paren++;break; // (\n\t          case 0x29:\n\t            paren--;break; // )\n\t          case 0x5B:\n\t            square++;break; // [\n\t          case 0x5D:\n\t            square--;break; // ]\n\t          case 0x7B:\n\t            curly++;break; // {\n\t          case 0x7D:\n\t            curly--;break; // }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (dir.expression == null) {\n\t      dir.expression = str.slice(0, i).trim();\n\t    } else if (lastFilterIndex !== 0) {\n\t      pushFilter();\n\t    }\n\t\n\t    cache$1.put(s, dir);\n\t    return dir;\n\t  }\n\t\n\t  var directive = Object.freeze({\n\t    parseDirective: parseDirective\n\t  });\n\t\n\t  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\t  var cache = undefined;\n\t  var tagRE = undefined;\n\t  var htmlRE = undefined;\n\t  /**\n\t   * Escape a string so it can be used in a RegExp\n\t   * constructor.\n\t   *\n\t   * @param {String} str\n\t   */\n\t\n\t  function escapeRegex(str) {\n\t    return str.replace(regexEscapeRE, '\\\\$&');\n\t  }\n\t\n\t  function compileRegex() {\n\t    var open = escapeRegex(config.delimiters[0]);\n\t    var close = escapeRegex(config.delimiters[1]);\n\t    var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\n\t    var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\n\t    tagRE = new RegExp(unsafeOpen + '(.+?)' + unsafeClose + '|' + open + '(.+?)' + close, 'g');\n\t    htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');\n\t    // reset cache\n\t    cache = new Cache(1000);\n\t  }\n\t\n\t  /**\n\t   * Parse a template text string into an array of tokens.\n\t   *\n\t   * @param {String} text\n\t   * @return {Array<Object> | null}\n\t   *               - {String} type\n\t   *               - {String} value\n\t   *               - {Boolean} [html]\n\t   *               - {Boolean} [oneTime]\n\t   */\n\t\n\t  function parseText(text) {\n\t    if (!cache) {\n\t      compileRegex();\n\t    }\n\t    var hit = cache.get(text);\n\t    if (hit) {\n\t      return hit;\n\t    }\n\t    text = text.replace(/\\n/g, '');\n\t    if (!tagRE.test(text)) {\n\t      return null;\n\t    }\n\t    var tokens = [];\n\t    var lastIndex = tagRE.lastIndex = 0;\n\t    var match, index, html, value, first, oneTime;\n\t    /* eslint-disable no-cond-assign */\n\t    while (match = tagRE.exec(text)) {\n\t      /* eslint-enable no-cond-assign */\n\t      index = match.index;\n\t      // push text token\n\t      if (index > lastIndex) {\n\t        tokens.push({\n\t          value: text.slice(lastIndex, index)\n\t        });\n\t      }\n\t      // tag token\n\t      html = htmlRE.test(match[0]);\n\t      value = html ? match[1] : match[2];\n\t      first = value.charCodeAt(0);\n\t      oneTime = first === 42; // *\n\t      value = oneTime ? value.slice(1) : value;\n\t      tokens.push({\n\t        tag: true,\n\t        value: value.trim(),\n\t        html: html,\n\t        oneTime: oneTime\n\t      });\n\t      lastIndex = index + match[0].length;\n\t    }\n\t    if (lastIndex < text.length) {\n\t      tokens.push({\n\t        value: text.slice(lastIndex)\n\t      });\n\t    }\n\t    cache.put(text, tokens);\n\t    return tokens;\n\t  }\n\t\n\t  /**\n\t   * Format a list of tokens into an expression.\n\t   * e.g. tokens parsed from 'a {{b}} c' can be serialized\n\t   * into one single expression as '\"a \" + b + \" c\"'.\n\t   *\n\t   * @param {Array} tokens\n\t   * @param {Vue} [vm]\n\t   * @return {String}\n\t   */\n\t\n\t  function tokensToExp(tokens, vm) {\n\t    if (tokens.length > 1) {\n\t      return tokens.map(function (token) {\n\t        return formatToken(token, vm);\n\t      }).join('+');\n\t    } else {\n\t      return formatToken(tokens[0], vm, true);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Format a single token.\n\t   *\n\t   * @param {Object} token\n\t   * @param {Vue} [vm]\n\t   * @param {Boolean} [single]\n\t   * @return {String}\n\t   */\n\t\n\t  function formatToken(token, vm, single) {\n\t    return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\n\t  }\n\t\n\t  /**\n\t   * For an attribute with multiple interpolation tags,\n\t   * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n\t   * the whole thing into a single watchable expression, we\n\t   * have to inline those filters. This function does exactly\n\t   * that. This is a bit hacky but it avoids heavy changes\n\t   * to directive parser and watcher mechanism.\n\t   *\n\t   * @param {String} exp\n\t   * @param {Boolean} single\n\t   * @return {String}\n\t   */\n\t\n\t  var filterRE$1 = /[^|]\\|[^|]/;\n\t  function inlineFilters(exp, single) {\n\t    if (!filterRE$1.test(exp)) {\n\t      return single ? exp : '(' + exp + ')';\n\t    } else {\n\t      var dir = parseDirective(exp);\n\t      if (!dir.filters) {\n\t        return '(' + exp + ')';\n\t      } else {\n\t        return 'this._applyFilters(' + dir.expression + // value\n\t        ',null,' + // oldValue (null for read)\n\t        JSON.stringify(dir.filters) + // filter descriptors\n\t        ',false)'; // write?\n\t      }\n\t    }\n\t  }\n\t\n\t  var text$1 = Object.freeze({\n\t    compileRegex: compileRegex,\n\t    parseText: parseText,\n\t    tokensToExp: tokensToExp\n\t  });\n\t\n\t  var delimiters = ['{{', '}}'];\n\t  var unsafeDelimiters = ['{{{', '}}}'];\n\t\n\t  var config = Object.defineProperties({\n\t\n\t    /**\n\t     * Whether to print debug messages.\n\t     * Also enables stack trace for warnings.\n\t     *\n\t     * @type {Boolean}\n\t     */\n\t\n\t    debug: false,\n\t\n\t    /**\n\t     * Whether to suppress warnings.\n\t     *\n\t     * @type {Boolean}\n\t     */\n\t\n\t    silent: false,\n\t\n\t    /**\n\t     * Whether to use async rendering.\n\t     */\n\t\n\t    async: true,\n\t\n\t    /**\n\t     * Whether to warn against errors caught when evaluating\n\t     * expressions.\n\t     */\n\t\n\t    warnExpressionErrors: true,\n\t\n\t    /**\n\t     * Whether or not to handle fully object properties which\n\t     * are already backed by getters and seters. Depending on\n\t     * use case and environment, this might introduce non-neglible\n\t     * performance penalties.\n\t     */\n\t    convertAllProperties: false,\n\t\n\t    /**\n\t     * Internal flag to indicate the delimiters have been\n\t     * changed.\n\t     *\n\t     * @type {Boolean}\n\t     */\n\t\n\t    _delimitersChanged: true,\n\t\n\t    /**\n\t     * List of asset types that a component can own.\n\t     *\n\t     * @type {Array}\n\t     */\n\t\n\t    _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\n\t\n\t    /**\n\t     * prop binding modes\n\t     */\n\t\n\t    _propBindingModes: {\n\t      ONE_WAY: 0,\n\t      TWO_WAY: 1,\n\t      ONE_TIME: 2\n\t    },\n\t\n\t    /**\n\t     * Max circular updates allowed in a batcher flush cycle.\n\t     */\n\t\n\t    _maxUpdateCount: 100\n\t\n\t  }, {\n\t    delimiters: { /**\n\t                   * Interpolation delimiters. Changing these would trigger\n\t                   * the text parser to re-compile the regular expressions.\n\t                   *\n\t                   * @type {Array<String>}\n\t                   */\n\t\n\t      get: function get() {\n\t        return delimiters;\n\t      },\n\t      set: function set(val) {\n\t        delimiters = val;\n\t        compileRegex();\n\t      },\n\t      configurable: true,\n\t      enumerable: true\n\t    },\n\t    unsafeDelimiters: {\n\t      get: function get() {\n\t        return unsafeDelimiters;\n\t      },\n\t      set: function set(val) {\n\t        unsafeDelimiters = val;\n\t        compileRegex();\n\t      },\n\t      configurable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  var warn = undefined;\n\t\n\t  if (true) {\n\t    (function () {\n\t      var hasConsole = typeof console !== 'undefined';\n\t      warn = function (msg, e) {\n\t        if (hasConsole && (!config.silent || config.debug)) {\n\t          console.warn('[Vue warn]: ' + msg);\n\t          /* istanbul ignore if */\n\t          if (config.debug) {\n\t            if (e) {\n\t              throw e;\n\t            } else {\n\t              console.warn(new Error('Warning Stack Trace').stack);\n\t            }\n\t          }\n\t        }\n\t      };\n\t    })();\n\t  }\n\t\n\t  /**\n\t   * Append with transition.\n\t   *\n\t   * @param {Element} el\n\t   * @param {Element} target\n\t   * @param {Vue} vm\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function appendWithTransition(el, target, vm, cb) {\n\t    applyTransition(el, 1, function () {\n\t      target.appendChild(el);\n\t    }, vm, cb);\n\t  }\n\t\n\t  /**\n\t   * InsertBefore with transition.\n\t   *\n\t   * @param {Element} el\n\t   * @param {Element} target\n\t   * @param {Vue} vm\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function beforeWithTransition(el, target, vm, cb) {\n\t    applyTransition(el, 1, function () {\n\t      before(el, target);\n\t    }, vm, cb);\n\t  }\n\t\n\t  /**\n\t   * Remove with transition.\n\t   *\n\t   * @param {Element} el\n\t   * @param {Vue} vm\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function removeWithTransition(el, vm, cb) {\n\t    applyTransition(el, -1, function () {\n\t      remove(el);\n\t    }, vm, cb);\n\t  }\n\t\n\t  /**\n\t   * Apply transitions with an operation callback.\n\t   *\n\t   * @param {Element} el\n\t   * @param {Number} direction\n\t   *                  1: enter\n\t   *                 -1: leave\n\t   * @param {Function} op - the actual DOM operation\n\t   * @param {Vue} vm\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  function applyTransition(el, direction, op, vm, cb) {\n\t    var transition = el.__v_trans;\n\t    if (!transition ||\n\t    // skip if there are no js hooks and CSS transition is\n\t    // not supported\n\t    !transition.hooks && !transitionEndEvent ||\n\t    // skip transitions for initial compile\n\t    !vm._isCompiled ||\n\t    // if the vm is being manipulated by a parent directive\n\t    // during the parent's compilation phase, skip the\n\t    // animation.\n\t    vm.$parent && !vm.$parent._isCompiled) {\n\t      op();\n\t      if (cb) cb();\n\t      return;\n\t    }\n\t    var action = direction > 0 ? 'enter' : 'leave';\n\t    transition[action](op, cb);\n\t  }\n\t\n\t  /**\n\t   * Query an element selector if it's not an element already.\n\t   *\n\t   * @param {String|Element} el\n\t   * @return {Element}\n\t   */\n\t\n\t  function query(el) {\n\t    if (typeof el === 'string') {\n\t      var selector = el;\n\t      el = document.querySelector(el);\n\t      if (!el) {\n\t        'development' !== 'production' && warn('Cannot find element: ' + selector);\n\t      }\n\t    }\n\t    return el;\n\t  }\n\t\n\t  /**\n\t   * Check if a node is in the document.\n\t   * Note: document.documentElement.contains should work here\n\t   * but always returns false for comment nodes in phantomjs,\n\t   * making unit tests difficult. This is fixed by doing the\n\t   * contains() check on the node's parentNode instead of\n\t   * the node itself.\n\t   *\n\t   * @param {Node} node\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function inDoc(node) {\n\t    var doc = document.documentElement;\n\t    var parent = node && node.parentNode;\n\t    return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n\t  }\n\t\n\t  /**\n\t   * Get and remove an attribute from a node.\n\t   *\n\t   * @param {Node} node\n\t   * @param {String} _attr\n\t   */\n\t\n\t  function getAttr(node, _attr) {\n\t    var val = node.getAttribute(_attr);\n\t    if (val !== null) {\n\t      node.removeAttribute(_attr);\n\t    }\n\t    return val;\n\t  }\n\t\n\t  /**\n\t   * Get an attribute with colon or v-bind: prefix.\n\t   *\n\t   * @param {Node} node\n\t   * @param {String} name\n\t   * @return {String|null}\n\t   */\n\t\n\t  function getBindAttr(node, name) {\n\t    var val = getAttr(node, ':' + name);\n\t    if (val === null) {\n\t      val = getAttr(node, 'v-bind:' + name);\n\t    }\n\t    return val;\n\t  }\n\t\n\t  /**\n\t   * Check the presence of a bind attribute.\n\t   *\n\t   * @param {Node} node\n\t   * @param {String} name\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function hasBindAttr(node, name) {\n\t    return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\n\t  }\n\t\n\t  /**\n\t   * Insert el before target\n\t   *\n\t   * @param {Element} el\n\t   * @param {Element} target\n\t   */\n\t\n\t  function before(el, target) {\n\t    target.parentNode.insertBefore(el, target);\n\t  }\n\t\n\t  /**\n\t   * Insert el after target\n\t   *\n\t   * @param {Element} el\n\t   * @param {Element} target\n\t   */\n\t\n\t  function after(el, target) {\n\t    if (target.nextSibling) {\n\t      before(el, target.nextSibling);\n\t    } else {\n\t      target.parentNode.appendChild(el);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Remove el from DOM\n\t   *\n\t   * @param {Element} el\n\t   */\n\t\n\t  function remove(el) {\n\t    el.parentNode.removeChild(el);\n\t  }\n\t\n\t  /**\n\t   * Prepend el to target\n\t   *\n\t   * @param {Element} el\n\t   * @param {Element} target\n\t   */\n\t\n\t  function prepend(el, target) {\n\t    if (target.firstChild) {\n\t      before(el, target.firstChild);\n\t    } else {\n\t      target.appendChild(el);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Replace target with el\n\t   *\n\t   * @param {Element} target\n\t   * @param {Element} el\n\t   */\n\t\n\t  function replace(target, el) {\n\t    var parent = target.parentNode;\n\t    if (parent) {\n\t      parent.replaceChild(el, target);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Add event listener shorthand.\n\t   *\n\t   * @param {Element} el\n\t   * @param {String} event\n\t   * @param {Function} cb\n\t   */\n\t\n\t  function on$1(el, event, cb) {\n\t    el.addEventListener(event, cb);\n\t  }\n\t\n\t  /**\n\t   * Remove event listener shorthand.\n\t   *\n\t   * @param {Element} el\n\t   * @param {String} event\n\t   * @param {Function} cb\n\t   */\n\t\n\t  function off(el, event, cb) {\n\t    el.removeEventListener(event, cb);\n\t  }\n\t\n\t  /**\n\t   * In IE9, setAttribute('class') will result in empty class\n\t   * if the element also has the :class attribute; However in\n\t   * PhantomJS, setting `className` does not work on SVG elements...\n\t   * So we have to do a conditional check here.\n\t   *\n\t   * @param {Element} el\n\t   * @param {String} cls\n\t   */\n\t\n\t  function setClass(el, cls) {\n\t    /* istanbul ignore if */\n\t    if (isIE9 && !(el instanceof SVGElement)) {\n\t      el.className = cls;\n\t    } else {\n\t      el.setAttribute('class', cls);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Add class with compatibility for IE & SVG\n\t   *\n\t   * @param {Element} el\n\t   * @param {String} cls\n\t   */\n\t\n\t  function addClass(el, cls) {\n\t    if (el.classList) {\n\t      el.classList.add(cls);\n\t    } else {\n\t      var cur = ' ' + (el.getAttribute('class') || '') + ' ';\n\t      if (cur.indexOf(' ' + cls + ' ') < 0) {\n\t        setClass(el, (cur + cls).trim());\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Remove class with compatibility for IE & SVG\n\t   *\n\t   * @param {Element} el\n\t   * @param {String} cls\n\t   */\n\t\n\t  function removeClass(el, cls) {\n\t    if (el.classList) {\n\t      el.classList.remove(cls);\n\t    } else {\n\t      var cur = ' ' + (el.getAttribute('class') || '') + ' ';\n\t      var tar = ' ' + cls + ' ';\n\t      while (cur.indexOf(tar) >= 0) {\n\t        cur = cur.replace(tar, ' ');\n\t      }\n\t      setClass(el, cur.trim());\n\t    }\n\t    if (!el.className) {\n\t      el.removeAttribute('class');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Extract raw content inside an element into a temporary\n\t   * container div\n\t   *\n\t   * @param {Element} el\n\t   * @param {Boolean} asFragment\n\t   * @return {Element}\n\t   */\n\t\n\t  function extractContent(el, asFragment) {\n\t    var child;\n\t    var rawContent;\n\t    /* istanbul ignore if */\n\t    if (isTemplate(el) && el.content instanceof DocumentFragment) {\n\t      el = el.content;\n\t    }\n\t    if (el.hasChildNodes()) {\n\t      trimNode(el);\n\t      rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\n\t      /* eslint-disable no-cond-assign */\n\t      while (child = el.firstChild) {\n\t        /* eslint-enable no-cond-assign */\n\t        rawContent.appendChild(child);\n\t      }\n\t    }\n\t    return rawContent;\n\t  }\n\t\n\t  /**\n\t   * Trim possible empty head/tail textNodes inside a parent.\n\t   *\n\t   * @param {Node} node\n\t   */\n\t\n\t  function trimNode(node) {\n\t    trim(node, node.firstChild);\n\t    trim(node, node.lastChild);\n\t  }\n\t\n\t  function trim(parent, node) {\n\t    if (node && node.nodeType === 3 && !node.data.trim()) {\n\t      parent.removeChild(node);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Check if an element is a template tag.\n\t   * Note if the template appears inside an SVG its tagName\n\t   * will be in lowercase.\n\t   *\n\t   * @param {Element} el\n\t   */\n\t\n\t  function isTemplate(el) {\n\t    return el.tagName && el.tagName.toLowerCase() === 'template';\n\t  }\n\t\n\t  /**\n\t   * Create an \"anchor\" for performing dom insertion/removals.\n\t   * This is used in a number of scenarios:\n\t   * - fragment instance\n\t   * - v-html\n\t   * - v-if\n\t   * - v-for\n\t   * - component\n\t   *\n\t   * @param {String} content\n\t   * @param {Boolean} persist - IE trashes empty textNodes on\n\t   *                            cloneNode(true), so in certain\n\t   *                            cases the anchor needs to be\n\t   *                            non-empty to be persisted in\n\t   *                            templates.\n\t   * @return {Comment|Text}\n\t   */\n\t\n\t  function createAnchor(content, persist) {\n\t    var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\n\t    anchor.__vue_anchor = true;\n\t    return anchor;\n\t  }\n\t\n\t  /**\n\t   * Find a component ref attribute that starts with $.\n\t   *\n\t   * @param {Element} node\n\t   * @return {String|undefined}\n\t   */\n\t\n\t  var refRE = /^v-ref:/;\n\t\n\t  function findRef(node) {\n\t    if (node.hasAttributes()) {\n\t      var attrs = node.attributes;\n\t      for (var i = 0, l = attrs.length; i < l; i++) {\n\t        var name = attrs[i].name;\n\t        if (refRE.test(name)) {\n\t          return camelize(name.replace(refRE, ''));\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Map a function to a range of nodes .\n\t   *\n\t   * @param {Node} node\n\t   * @param {Node} end\n\t   * @param {Function} op\n\t   */\n\t\n\t  function mapNodeRange(node, end, op) {\n\t    var next;\n\t    while (node !== end) {\n\t      next = node.nextSibling;\n\t      op(node);\n\t      node = next;\n\t    }\n\t    op(end);\n\t  }\n\t\n\t  /**\n\t   * Remove a range of nodes with transition, store\n\t   * the nodes in a fragment with correct ordering,\n\t   * and call callback when done.\n\t   *\n\t   * @param {Node} start\n\t   * @param {Node} end\n\t   * @param {Vue} vm\n\t   * @param {DocumentFragment} frag\n\t   * @param {Function} cb\n\t   */\n\t\n\t  function removeNodeRange(start, end, vm, frag, cb) {\n\t    var done = false;\n\t    var removed = 0;\n\t    var nodes = [];\n\t    mapNodeRange(start, end, function (node) {\n\t      if (node === end) done = true;\n\t      nodes.push(node);\n\t      removeWithTransition(node, vm, onRemoved);\n\t    });\n\t    function onRemoved() {\n\t      removed++;\n\t      if (done && removed >= nodes.length) {\n\t        for (var i = 0; i < nodes.length; i++) {\n\t          frag.appendChild(nodes[i]);\n\t        }\n\t        cb && cb();\n\t      }\n\t    }\n\t  }\n\t\n\t  var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/;\n\t  var reservedTagRE = /^(slot|partial|component)$/;\n\t\n\t  /**\n\t   * Check if an element is a component, if yes return its\n\t   * component id.\n\t   *\n\t   * @param {Element} el\n\t   * @param {Object} options\n\t   * @return {Object|undefined}\n\t   */\n\t\n\t  function checkComponentAttr(el, options) {\n\t    var tag = el.tagName.toLowerCase();\n\t    var hasAttrs = el.hasAttributes();\n\t    if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\n\t      if (resolveAsset(options, 'components', tag)) {\n\t        return { id: tag };\n\t      } else {\n\t        var is = hasAttrs && getIsBinding(el);\n\t        if (is) {\n\t          return is;\n\t        } else if (true) {\n\t          if (tag.indexOf('-') > -1 || /HTMLUnknownElement/.test(el.toString()) &&\n\t          // Chrome returns unknown for several HTML5 elements.\n\t          // https://code.google.com/p/chromium/issues/detail?id=540526\n\t          !/^(data|time|rtc|rb)$/.test(tag)) {\n\t            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly?');\n\t          }\n\t        }\n\t      }\n\t    } else if (hasAttrs) {\n\t      return getIsBinding(el);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Get \"is\" binding from an element.\n\t   *\n\t   * @param {Element} el\n\t   * @return {Object|undefined}\n\t   */\n\t\n\t  function getIsBinding(el) {\n\t    // dynamic syntax\n\t    var exp = getAttr(el, 'is');\n\t    if (exp != null) {\n\t      return { id: exp };\n\t    } else {\n\t      exp = getBindAttr(el, 'is');\n\t      if (exp != null) {\n\t        return { id: exp, dynamic: true };\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Set a prop's initial value on a vm and its data object.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Object} prop\n\t   * @param {*} value\n\t   */\n\t\n\t  function initProp(vm, prop, value) {\n\t    var key = prop.path;\n\t    value = coerceProp(prop, value);\n\t    vm[key] = vm._data[key] = assertProp(prop, value) ? value : undefined;\n\t  }\n\t\n\t  /**\n\t   * Assert whether a prop is valid.\n\t   *\n\t   * @param {Object} prop\n\t   * @param {*} value\n\t   */\n\t\n\t  function assertProp(prop, value) {\n\t    // if a prop is not provided and is not required,\n\t    // skip the check.\n\t    if (prop.raw === null && !prop.required) {\n\t      return true;\n\t    }\n\t    var options = prop.options;\n\t    var type = options.type;\n\t    var valid = true;\n\t    var expectedType;\n\t    if (type) {\n\t      if (type === String) {\n\t        expectedType = 'string';\n\t        valid = typeof value === expectedType;\n\t      } else if (type === Number) {\n\t        expectedType = 'number';\n\t        valid = typeof value === 'number';\n\t      } else if (type === Boolean) {\n\t        expectedType = 'boolean';\n\t        valid = typeof value === 'boolean';\n\t      } else if (type === Function) {\n\t        expectedType = 'function';\n\t        valid = typeof value === 'function';\n\t      } else if (type === Object) {\n\t        expectedType = 'object';\n\t        valid = isPlainObject(value);\n\t      } else if (type === Array) {\n\t        expectedType = 'array';\n\t        valid = isArray(value);\n\t      } else {\n\t        valid = value instanceof type;\n\t      }\n\t    }\n\t    if (!valid) {\n\t      'development' !== 'production' && warn('Invalid prop: type check failed for ' + prop.path + '=\"' + prop.raw + '\".' + ' Expected ' + formatType(expectedType) + ', got ' + formatValue(value) + '.');\n\t      return false;\n\t    }\n\t    var validator = options.validator;\n\t    if (validator) {\n\t      if (!validator.call(null, value)) {\n\t        'development' !== 'production' && warn('Invalid prop: custom validator check failed for ' + prop.path + '=\"' + prop.raw + '\"');\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t\n\t  /**\n\t   * Force parsing value with coerce option.\n\t   *\n\t   * @param {*} value\n\t   * @param {Object} options\n\t   * @return {*}\n\t   */\n\t\n\t  function coerceProp(prop, value) {\n\t    var coerce = prop.options.coerce;\n\t    if (!coerce) {\n\t      return value;\n\t    }\n\t    // coerce is a function\n\t    return coerce(value);\n\t  }\n\t\n\t  function formatType(val) {\n\t    return val ? val.charAt(0).toUpperCase() + val.slice(1) : 'custom type';\n\t  }\n\t\n\t  function formatValue(val) {\n\t    return Object.prototype.toString.call(val).slice(8, -1);\n\t  }\n\t\n\t  /**\n\t   * Option overwriting strategies are functions that handle\n\t   * how to merge a parent option value and a child option\n\t   * value into the final value.\n\t   *\n\t   * All strategy functions follow the same signature:\n\t   *\n\t   * @param {*} parentVal\n\t   * @param {*} childVal\n\t   * @param {Vue} [vm]\n\t   */\n\t\n\t  var strats = config.optionMergeStrategies = Object.create(null);\n\t\n\t  /**\n\t   * Helper that recursively merges two data objects together.\n\t   */\n\t\n\t  function mergeData(to, from) {\n\t    var key, toVal, fromVal;\n\t    for (key in from) {\n\t      toVal = to[key];\n\t      fromVal = from[key];\n\t      if (!hasOwn(to, key)) {\n\t        set(to, key, fromVal);\n\t      } else if (isObject(toVal) && isObject(fromVal)) {\n\t        mergeData(toVal, fromVal);\n\t      }\n\t    }\n\t    return to;\n\t  }\n\t\n\t  /**\n\t   * Data\n\t   */\n\t\n\t  strats.data = function (parentVal, childVal, vm) {\n\t    if (!vm) {\n\t      // in a Vue.extend merge, both should be functions\n\t      if (!childVal) {\n\t        return parentVal;\n\t      }\n\t      if (typeof childVal !== 'function') {\n\t        'development' !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');\n\t        return parentVal;\n\t      }\n\t      if (!parentVal) {\n\t        return childVal;\n\t      }\n\t      // when parentVal & childVal are both present,\n\t      // we need to return a function that returns the\n\t      // merged result of both functions... no need to\n\t      // check if parentVal is a function here because\n\t      // it has to be a function to pass previous merges.\n\t      return function mergedDataFn() {\n\t        return mergeData(childVal.call(this), parentVal.call(this));\n\t      };\n\t    } else if (parentVal || childVal) {\n\t      return function mergedInstanceDataFn() {\n\t        // instance merge\n\t        var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n\t        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n\t        if (instanceData) {\n\t          return mergeData(instanceData, defaultData);\n\t        } else {\n\t          return defaultData;\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  /**\n\t   * El\n\t   */\n\t\n\t  strats.el = function (parentVal, childVal, vm) {\n\t    if (!vm && childVal && typeof childVal !== 'function') {\n\t      'development' !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');\n\t      return;\n\t    }\n\t    var ret = childVal || parentVal;\n\t    // invoke the element factory if this is instance merge\n\t    return vm && typeof ret === 'function' ? ret.call(vm) : ret;\n\t  };\n\t\n\t  /**\n\t   * Hooks and param attributes are merged as arrays.\n\t   */\n\t\n\t  strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = function (parentVal, childVal) {\n\t    return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\n\t  };\n\t\n\t  /**\n\t   * 0.11 deprecation warning\n\t   */\n\t\n\t  strats.paramAttributes = function () {\n\t    /* istanbul ignore next */\n\t    'development' !== 'production' && warn('\"paramAttributes\" option has been deprecated in 0.12. ' + 'Use \"props\" instead.');\n\t  };\n\t\n\t  /**\n\t   * Assets\n\t   *\n\t   * When a vm is present (instance creation), we need to do\n\t   * a three-way merge between constructor options, instance\n\t   * options and parent options.\n\t   */\n\t\n\t  function mergeAssets(parentVal, childVal) {\n\t    var res = Object.create(parentVal);\n\t    return childVal ? extend(res, guardArrayAssets(childVal)) : res;\n\t  }\n\t\n\t  config._assetTypes.forEach(function (type) {\n\t    strats[type + 's'] = mergeAssets;\n\t  });\n\t\n\t  /**\n\t   * Events & Watchers.\n\t   *\n\t   * Events & watchers hashes should not overwrite one\n\t   * another, so we merge them as arrays.\n\t   */\n\t\n\t  strats.watch = strats.events = function (parentVal, childVal) {\n\t    if (!childVal) return parentVal;\n\t    if (!parentVal) return childVal;\n\t    var ret = {};\n\t    extend(ret, parentVal);\n\t    for (var key in childVal) {\n\t      var parent = ret[key];\n\t      var child = childVal[key];\n\t      if (parent && !isArray(parent)) {\n\t        parent = [parent];\n\t      }\n\t      ret[key] = parent ? parent.concat(child) : [child];\n\t    }\n\t    return ret;\n\t  };\n\t\n\t  /**\n\t   * Other object hashes.\n\t   */\n\t\n\t  strats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n\t    if (!childVal) return parentVal;\n\t    if (!parentVal) return childVal;\n\t    var ret = Object.create(null);\n\t    extend(ret, parentVal);\n\t    extend(ret, childVal);\n\t    return ret;\n\t  };\n\t\n\t  /**\n\t   * Default strategy.\n\t   */\n\t\n\t  var defaultStrat = function defaultStrat(parentVal, childVal) {\n\t    return childVal === undefined ? parentVal : childVal;\n\t  };\n\t\n\t  /**\n\t   * Make sure component options get converted to actual\n\t   * constructors.\n\t   *\n\t   * @param {Object} options\n\t   */\n\t\n\t  function guardComponents(options) {\n\t    if (options.components) {\n\t      var components = options.components = guardArrayAssets(options.components);\n\t      var def;\n\t      var ids = Object.keys(components);\n\t      for (var i = 0, l = ids.length; i < l; i++) {\n\t        var key = ids[i];\n\t        if (commonTagRE.test(key) || reservedTagRE.test(key)) {\n\t          'development' !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n\t          continue;\n\t        }\n\t        def = components[key];\n\t        if (isPlainObject(def)) {\n\t          components[key] = Vue.extend(def);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Ensure all props option syntax are normalized into the\n\t   * Object-based format.\n\t   *\n\t   * @param {Object} options\n\t   */\n\t\n\t  function guardProps(options) {\n\t    var props = options.props;\n\t    var i, val;\n\t    if (isArray(props)) {\n\t      options.props = {};\n\t      i = props.length;\n\t      while (i--) {\n\t        val = props[i];\n\t        if (typeof val === 'string') {\n\t          options.props[val] = null;\n\t        } else if (val.name) {\n\t          options.props[val.name] = val;\n\t        }\n\t      }\n\t    } else if (isPlainObject(props)) {\n\t      var keys = Object.keys(props);\n\t      i = keys.length;\n\t      while (i--) {\n\t        val = props[keys[i]];\n\t        if (typeof val === 'function') {\n\t          props[keys[i]] = { type: val };\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Guard an Array-format assets option and converted it\n\t   * into the key-value Object format.\n\t   *\n\t   * @param {Object|Array} assets\n\t   * @return {Object}\n\t   */\n\t\n\t  function guardArrayAssets(assets) {\n\t    if (isArray(assets)) {\n\t      var res = {};\n\t      var i = assets.length;\n\t      var asset;\n\t      while (i--) {\n\t        asset = assets[i];\n\t        var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\n\t        if (!id) {\n\t          'development' !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\n\t        } else {\n\t          res[id] = asset;\n\t        }\n\t      }\n\t      return res;\n\t    }\n\t    return assets;\n\t  }\n\t\n\t  /**\n\t   * Merge two option objects into a new one.\n\t   * Core utility used in both instantiation and inheritance.\n\t   *\n\t   * @param {Object} parent\n\t   * @param {Object} child\n\t   * @param {Vue} [vm] - if vm is present, indicates this is\n\t   *                     an instantiation merge.\n\t   */\n\t\n\t  function mergeOptions(parent, child, vm) {\n\t    guardComponents(child);\n\t    guardProps(child);\n\t    var options = {};\n\t    var key;\n\t    if (child.mixins) {\n\t      for (var i = 0, l = child.mixins.length; i < l; i++) {\n\t        parent = mergeOptions(parent, child.mixins[i], vm);\n\t      }\n\t    }\n\t    for (key in parent) {\n\t      mergeField(key);\n\t    }\n\t    for (key in child) {\n\t      if (!hasOwn(parent, key)) {\n\t        mergeField(key);\n\t      }\n\t    }\n\t    function mergeField(key) {\n\t      var strat = strats[key] || defaultStrat;\n\t      options[key] = strat(parent[key], child[key], vm, key);\n\t    }\n\t    return options;\n\t  }\n\t\n\t  /**\n\t   * Resolve an asset.\n\t   * This function is used because child instances need access\n\t   * to assets defined in its ancestor chain.\n\t   *\n\t   * @param {Object} options\n\t   * @param {String} type\n\t   * @param {String} id\n\t   * @return {Object|Function}\n\t   */\n\t\n\t  function resolveAsset(options, type, id) {\n\t    var assets = options[type];\n\t    var camelizedId;\n\t    return assets[id] ||\n\t    // camelCase ID\n\t    assets[camelizedId = camelize(id)] ||\n\t    // Pascal Case ID\n\t    assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\n\t  }\n\t\n\t  /**\n\t   * Assert asset exists\n\t   */\n\t\n\t  function assertAsset(val, type, id) {\n\t    if (!val) {\n\t      'development' !== 'production' && warn('Failed to resolve ' + type + ': ' + id);\n\t    }\n\t  }\n\t\n\t  var arrayProto = Array.prototype;\n\t  var arrayMethods = Object.create(arrayProto)\n\t\n\t  /**\n\t   * Intercept mutating methods and emit events\n\t   */\n\t\n\t  ;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n\t    // cache original method\n\t    var original = arrayProto[method];\n\t    def(arrayMethods, method, function mutator() {\n\t      // avoid leaking arguments:\n\t      // http://jsperf.com/closure-with-arguments\n\t      var i = arguments.length;\n\t      var args = new Array(i);\n\t      while (i--) {\n\t        args[i] = arguments[i];\n\t      }\n\t      var result = original.apply(this, args);\n\t      var ob = this.__ob__;\n\t      var inserted;\n\t      switch (method) {\n\t        case 'push':\n\t          inserted = args;\n\t          break;\n\t        case 'unshift':\n\t          inserted = args;\n\t          break;\n\t        case 'splice':\n\t          inserted = args.slice(2);\n\t          break;\n\t      }\n\t      if (inserted) ob.observeArray(inserted);\n\t      // notify change\n\t      ob.dep.notify();\n\t      return result;\n\t    });\n\t  });\n\t\n\t  /**\n\t   * Swap the element at the given index with a new value\n\t   * and emits corresponding event.\n\t   *\n\t   * @param {Number} index\n\t   * @param {*} val\n\t   * @return {*} - replaced element\n\t   */\n\t\n\t  def(arrayProto, '$set', function $set(index, val) {\n\t    if (index >= this.length) {\n\t      this.length = Number(index) + 1;\n\t    }\n\t    return this.splice(index, 1, val)[0];\n\t  });\n\t\n\t  /**\n\t   * Convenience method to remove the element at given index.\n\t   *\n\t   * @param {Number} index\n\t   * @param {*} val\n\t   */\n\t\n\t  def(arrayProto, '$remove', function $remove(item) {\n\t    /* istanbul ignore if */\n\t    if (!this.length) return;\n\t    var index = indexOf(this, item);\n\t    if (index > -1) {\n\t      return this.splice(index, 1);\n\t    }\n\t  });\n\t\n\t  var uid$3 = 0;\n\t\n\t  /**\n\t   * A dep is an observable that can have multiple\n\t   * directives subscribing to it.\n\t   *\n\t   * @constructor\n\t   */\n\t  function Dep() {\n\t    this.id = uid$3++;\n\t    this.subs = [];\n\t  }\n\t\n\t  // the current target watcher being evaluated.\n\t  // this is globally unique because there could be only one\n\t  // watcher being evaluated at any time.\n\t  Dep.target = null;\n\t\n\t  /**\n\t   * Add a directive subscriber.\n\t   *\n\t   * @param {Directive} sub\n\t   */\n\t\n\t  Dep.prototype.addSub = function (sub) {\n\t    this.subs.push(sub);\n\t  };\n\t\n\t  /**\n\t   * Remove a directive subscriber.\n\t   *\n\t   * @param {Directive} sub\n\t   */\n\t\n\t  Dep.prototype.removeSub = function (sub) {\n\t    this.subs.$remove(sub);\n\t  };\n\t\n\t  /**\n\t   * Add self as a dependency to the target watcher.\n\t   */\n\t\n\t  Dep.prototype.depend = function () {\n\t    Dep.target.addDep(this);\n\t  };\n\t\n\t  /**\n\t   * Notify all subscribers of a new value.\n\t   */\n\t\n\t  Dep.prototype.notify = function () {\n\t    // stablize the subscriber list first\n\t    var subs = toArray(this.subs);\n\t    for (var i = 0, l = subs.length; i < l; i++) {\n\t      subs[i].update();\n\t    }\n\t  };\n\t\n\t  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\t\n\t  /**\n\t   * Observer class that are attached to each observed\n\t   * object. Once attached, the observer converts target\n\t   * object's property keys into getter/setters that\n\t   * collect dependencies and dispatches updates.\n\t   *\n\t   * @param {Array|Object} value\n\t   * @constructor\n\t   */\n\t\n\t  function Observer(value) {\n\t    this.value = value;\n\t    this.dep = new Dep();\n\t    def(value, '__ob__', this);\n\t    if (isArray(value)) {\n\t      var augment = hasProto ? protoAugment : copyAugment;\n\t      augment(value, arrayMethods, arrayKeys);\n\t      this.observeArray(value);\n\t    } else {\n\t      this.walk(value);\n\t    }\n\t  }\n\t\n\t  // Instance methods\n\t\n\t  /**\n\t   * Walk through each property and convert them into\n\t   * getter/setters. This method should only be called when\n\t   * value type is Object.\n\t   *\n\t   * @param {Object} obj\n\t   */\n\t\n\t  Observer.prototype.walk = function (obj) {\n\t    var keys = Object.keys(obj);\n\t    for (var i = 0, l = keys.length; i < l; i++) {\n\t      this.convert(keys[i], obj[keys[i]]);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Observe a list of Array items.\n\t   *\n\t   * @param {Array} items\n\t   */\n\t\n\t  Observer.prototype.observeArray = function (items) {\n\t    for (var i = 0, l = items.length; i < l; i++) {\n\t      observe(items[i]);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Convert a property into getter/setter so we can emit\n\t   * the events when the property is accessed/changed.\n\t   *\n\t   * @param {String} key\n\t   * @param {*} val\n\t   */\n\t\n\t  Observer.prototype.convert = function (key, val) {\n\t    defineReactive(this.value, key, val);\n\t  };\n\t\n\t  /**\n\t   * Add an owner vm, so that when $set/$delete mutations\n\t   * happen we can notify owner vms to proxy the keys and\n\t   * digest the watchers. This is only called when the object\n\t   * is observed as an instance's root $data.\n\t   *\n\t   * @param {Vue} vm\n\t   */\n\t\n\t  Observer.prototype.addVm = function (vm) {\n\t    (this.vms || (this.vms = [])).push(vm);\n\t  };\n\t\n\t  /**\n\t   * Remove an owner vm. This is called when the object is\n\t   * swapped out as an instance's $data object.\n\t   *\n\t   * @param {Vue} vm\n\t   */\n\t\n\t  Observer.prototype.removeVm = function (vm) {\n\t    this.vms.$remove(vm);\n\t  };\n\t\n\t  // helpers\n\t\n\t  /**\n\t   * Augment an target Object or Array by intercepting\n\t   * the prototype chain using __proto__\n\t   *\n\t   * @param {Object|Array} target\n\t   * @param {Object} proto\n\t   */\n\t\n\t  function protoAugment(target, src) {\n\t    target.__proto__ = src;\n\t  }\n\t\n\t  /**\n\t   * Augment an target Object or Array by defining\n\t   * hidden properties.\n\t   *\n\t   * @param {Object|Array} target\n\t   * @param {Object} proto\n\t   */\n\t\n\t  function copyAugment(target, src, keys) {\n\t    for (var i = 0, l = keys.length; i < l; i++) {\n\t      var key = keys[i];\n\t      def(target, key, src[key]);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Attempt to create an observer instance for a value,\n\t   * returns the new observer if successfully observed,\n\t   * or the existing observer if the value already has one.\n\t   *\n\t   * @param {*} value\n\t   * @param {Vue} [vm]\n\t   * @return {Observer|undefined}\n\t   * @static\n\t   */\n\t\n\t  function observe(value, vm) {\n\t    if (!value || typeof value !== 'object') {\n\t      return;\n\t    }\n\t    var ob;\n\t    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n\t      ob = value.__ob__;\n\t    } else if ((isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n\t      ob = new Observer(value);\n\t    }\n\t    if (ob && vm) {\n\t      ob.addVm(vm);\n\t    }\n\t    return ob;\n\t  }\n\t\n\t  /**\n\t   * Define a reactive property on an Object.\n\t   *\n\t   * @param {Object} obj\n\t   * @param {String} key\n\t   * @param {*} val\n\t   */\n\t\n\t  function defineReactive(obj, key, val) {\n\t    var dep = new Dep();\n\t\n\t    // cater for pre-defined getter/setters\n\t    var getter, setter;\n\t    if (config.convertAllProperties) {\n\t      var property = Object.getOwnPropertyDescriptor(obj, key);\n\t      if (property && property.configurable === false) {\n\t        return;\n\t      }\n\t      getter = property && property.get;\n\t      setter = property && property.set;\n\t    }\n\t\n\t    var childOb = observe(val);\n\t    Object.defineProperty(obj, key, {\n\t      enumerable: true,\n\t      configurable: true,\n\t      get: function reactiveGetter() {\n\t        var value = getter ? getter.call(obj) : val;\n\t        if (Dep.target) {\n\t          dep.depend();\n\t          if (childOb) {\n\t            childOb.dep.depend();\n\t          }\n\t          if (isArray(value)) {\n\t            for (var e, i = 0, l = value.length; i < l; i++) {\n\t              e = value[i];\n\t              e && e.__ob__ && e.__ob__.dep.depend();\n\t            }\n\t          }\n\t        }\n\t        return value;\n\t      },\n\t      set: function reactiveSetter(newVal) {\n\t        var value = getter ? getter.call(obj) : val;\n\t        if (newVal === value) {\n\t          return;\n\t        }\n\t        if (setter) {\n\t          setter.call(obj, newVal);\n\t        } else {\n\t          val = newVal;\n\t        }\n\t        childOb = observe(newVal);\n\t        dep.notify();\n\t      }\n\t    });\n\t  }\n\t\n\t  var util = Object.freeze({\n\t  \tdefineReactive: defineReactive,\n\t  \tset: set,\n\t  \tdel: del,\n\t  \thasOwn: hasOwn,\n\t  \tisLiteral: isLiteral,\n\t  \tisReserved: isReserved,\n\t  \t_toString: _toString,\n\t  \ttoNumber: toNumber,\n\t  \ttoBoolean: toBoolean,\n\t  \tstripQuotes: stripQuotes,\n\t  \tcamelize: camelize,\n\t  \thyphenate: hyphenate,\n\t  \tclassify: classify,\n\t  \tbind: bind$1,\n\t  \ttoArray: toArray,\n\t  \textend: extend,\n\t  \tisObject: isObject,\n\t  \tisPlainObject: isPlainObject,\n\t  \tdef: def,\n\t  \tdebounce: _debounce,\n\t  \tindexOf: indexOf,\n\t  \tcancellable: cancellable,\n\t  \tlooseEqual: looseEqual,\n\t  \tisArray: isArray,\n\t  \thasProto: hasProto,\n\t  \tinBrowser: inBrowser,\n\t  \tisIE9: isIE9,\n\t  \tisAndroid: isAndroid,\n\t  \tget transitionProp () { return transitionProp; },\n\t  \tget transitionEndEvent () { return transitionEndEvent; },\n\t  \tget animationProp () { return animationProp; },\n\t  \tget animationEndEvent () { return animationEndEvent; },\n\t  \tnextTick: nextTick,\n\t  \tquery: query,\n\t  \tinDoc: inDoc,\n\t  \tgetAttr: getAttr,\n\t  \tgetBindAttr: getBindAttr,\n\t  \thasBindAttr: hasBindAttr,\n\t  \tbefore: before,\n\t  \tafter: after,\n\t  \tremove: remove,\n\t  \tprepend: prepend,\n\t  \treplace: replace,\n\t  \ton: on$1,\n\t  \toff: off,\n\t  \tsetClass: setClass,\n\t  \taddClass: addClass,\n\t  \tremoveClass: removeClass,\n\t  \textractContent: extractContent,\n\t  \ttrimNode: trimNode,\n\t  \tisTemplate: isTemplate,\n\t  \tcreateAnchor: createAnchor,\n\t  \tfindRef: findRef,\n\t  \tmapNodeRange: mapNodeRange,\n\t  \tremoveNodeRange: removeNodeRange,\n\t  \tmergeOptions: mergeOptions,\n\t  \tresolveAsset: resolveAsset,\n\t  \tassertAsset: assertAsset,\n\t  \tcheckComponentAttr: checkComponentAttr,\n\t  \tinitProp: initProp,\n\t  \tassertProp: assertProp,\n\t  \tcoerceProp: coerceProp,\n\t  \tcommonTagRE: commonTagRE,\n\t  \treservedTagRE: reservedTagRE,\n\t  \tget warn () { return warn; }\n\t  });\n\t\n\t  var uid = 0;\n\t\n\t  function initMixin (Vue) {\n\t\n\t    /**\n\t     * The main init sequence. This is called for every\n\t     * instance, including ones that are created from extended\n\t     * constructors.\n\t     *\n\t     * @param {Object} options - this options object should be\n\t     *                           the result of merging class\n\t     *                           options and the options passed\n\t     *                           in to the constructor.\n\t     */\n\t\n\t    Vue.prototype._init = function (options) {\n\t\n\t      options = options || {};\n\t\n\t      this.$el = null;\n\t      this.$parent = options.parent;\n\t      this.$root = this.$parent ? this.$parent.$root : this;\n\t      this.$children = [];\n\t      this.$refs = {}; // child vm references\n\t      this.$els = {}; // element references\n\t      this._watchers = []; // all watchers as an array\n\t      this._directives = []; // all directives\n\t\n\t      // a uid\n\t      this._uid = uid++;\n\t\n\t      // a flag to avoid this being observed\n\t      this._isVue = true;\n\t\n\t      // events bookkeeping\n\t      this._events = {}; // registered callbacks\n\t      this._eventsCount = {}; // for $broadcast optimization\n\t\n\t      // fragment instance properties\n\t      this._isFragment = false;\n\t      this._fragment = // @type {DocumentFragment}\n\t      this._fragmentStart = // @type {Text|Comment}\n\t      this._fragmentEnd = null; // @type {Text|Comment}\n\t\n\t      // lifecycle state\n\t      this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = false;\n\t      this._unlinkFn = null;\n\t\n\t      // context:\n\t      // if this is a transcluded component, context\n\t      // will be the common parent vm of this instance\n\t      // and its host.\n\t      this._context = options._context || this.$parent;\n\t\n\t      // scope:\n\t      // if this is inside an inline v-for, the scope\n\t      // will be the intermediate scope created for this\n\t      // repeat fragment. this is used for linking props\n\t      // and container directives.\n\t      this._scope = options._scope;\n\t\n\t      // fragment:\n\t      // if this instance is compiled inside a Fragment, it\n\t      // needs to reigster itself as a child of that fragment\n\t      // for attach/detach to work properly.\n\t      this._frag = options._frag;\n\t      if (this._frag) {\n\t        this._frag.children.push(this);\n\t      }\n\t\n\t      // push self into parent / transclusion host\n\t      if (this.$parent) {\n\t        this.$parent.$children.push(this);\n\t      }\n\t\n\t      // merge options.\n\t      options = this.$options = mergeOptions(this.constructor.options, options, this);\n\t\n\t      // set ref\n\t      this._updateRef();\n\t\n\t      // initialize data as empty object.\n\t      // it will be filled up in _initScope().\n\t      this._data = {};\n\t\n\t      // call init hook\n\t      this._callHook('init');\n\t\n\t      // initialize data observation and scope inheritance.\n\t      this._initState();\n\t\n\t      // setup event system and option events.\n\t      this._initEvents();\n\t\n\t      // call created hook\n\t      this._callHook('created');\n\t\n\t      // if `el` option is passed, start compilation.\n\t      if (options.el) {\n\t        this.$mount(options.el);\n\t      }\n\t    };\n\t  }\n\t\n\t  var pathCache = new Cache(1000);\n\t\n\t  // actions\n\t  var APPEND = 0;\n\t  var PUSH = 1;\n\t  var INC_SUB_PATH_DEPTH = 2;\n\t  var PUSH_SUB_PATH = 3;\n\t\n\t  // states\n\t  var BEFORE_PATH = 0;\n\t  var IN_PATH = 1;\n\t  var BEFORE_IDENT = 2;\n\t  var IN_IDENT = 3;\n\t  var IN_SUB_PATH = 4;\n\t  var IN_SINGLE_QUOTE = 5;\n\t  var IN_DOUBLE_QUOTE = 6;\n\t  var AFTER_PATH = 7;\n\t  var ERROR = 8;\n\t\n\t  var pathStateMachine = [];\n\t\n\t  pathStateMachine[BEFORE_PATH] = {\n\t    'ws': [BEFORE_PATH],\n\t    'ident': [IN_IDENT, APPEND],\n\t    '[': [IN_SUB_PATH],\n\t    'eof': [AFTER_PATH]\n\t  };\n\t\n\t  pathStateMachine[IN_PATH] = {\n\t    'ws': [IN_PATH],\n\t    '.': [BEFORE_IDENT],\n\t    '[': [IN_SUB_PATH],\n\t    'eof': [AFTER_PATH]\n\t  };\n\t\n\t  pathStateMachine[BEFORE_IDENT] = {\n\t    'ws': [BEFORE_IDENT],\n\t    'ident': [IN_IDENT, APPEND]\n\t  };\n\t\n\t  pathStateMachine[IN_IDENT] = {\n\t    'ident': [IN_IDENT, APPEND],\n\t    '0': [IN_IDENT, APPEND],\n\t    'number': [IN_IDENT, APPEND],\n\t    'ws': [IN_PATH, PUSH],\n\t    '.': [BEFORE_IDENT, PUSH],\n\t    '[': [IN_SUB_PATH, PUSH],\n\t    'eof': [AFTER_PATH, PUSH]\n\t  };\n\t\n\t  pathStateMachine[IN_SUB_PATH] = {\n\t    \"'\": [IN_SINGLE_QUOTE, APPEND],\n\t    '\"': [IN_DOUBLE_QUOTE, APPEND],\n\t    '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n\t    ']': [IN_PATH, PUSH_SUB_PATH],\n\t    'eof': ERROR,\n\t    'else': [IN_SUB_PATH, APPEND]\n\t  };\n\t\n\t  pathStateMachine[IN_SINGLE_QUOTE] = {\n\t    \"'\": [IN_SUB_PATH, APPEND],\n\t    'eof': ERROR,\n\t    'else': [IN_SINGLE_QUOTE, APPEND]\n\t  };\n\t\n\t  pathStateMachine[IN_DOUBLE_QUOTE] = {\n\t    '\"': [IN_SUB_PATH, APPEND],\n\t    'eof': ERROR,\n\t    'else': [IN_DOUBLE_QUOTE, APPEND]\n\t  };\n\t\n\t  /**\n\t   * Determine the type of a character in a keypath.\n\t   *\n\t   * @param {Char} ch\n\t   * @return {String} type\n\t   */\n\t\n\t  function getPathCharType(ch) {\n\t    if (ch === undefined) {\n\t      return 'eof';\n\t    }\n\t\n\t    var code = ch.charCodeAt(0);\n\t\n\t    switch (code) {\n\t      case 0x5B: // [\n\t      case 0x5D: // ]\n\t      case 0x2E: // .\n\t      case 0x22: // \"\n\t      case 0x27: // '\n\t      case 0x30:\n\t        // 0\n\t        return ch;\n\t\n\t      case 0x5F: // _\n\t      case 0x24:\n\t        // $\n\t        return 'ident';\n\t\n\t      case 0x20: // Space\n\t      case 0x09: // Tab\n\t      case 0x0A: // Newline\n\t      case 0x0D: // Return\n\t      case 0xA0: // No-break space\n\t      case 0xFEFF: // Byte Order Mark\n\t      case 0x2028: // Line Separator\n\t      case 0x2029:\n\t        // Paragraph Separator\n\t        return 'ws';\n\t    }\n\t\n\t    // a-z, A-Z\n\t    if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\n\t      return 'ident';\n\t    }\n\t\n\t    // 1-9\n\t    if (code >= 0x31 && code <= 0x39) {\n\t      return 'number';\n\t    }\n\t\n\t    return 'else';\n\t  }\n\t\n\t  /**\n\t   * Format a subPath, return its plain form if it is\n\t   * a literal string or number. Otherwise prepend the\n\t   * dynamic indicator (*).\n\t   *\n\t   * @param {String} path\n\t   * @return {String}\n\t   */\n\t\n\t  function formatSubPath(path) {\n\t    var trimmed = path.trim();\n\t    // invalid leading 0\n\t    if (path.charAt(0) === '0' && isNaN(path)) {\n\t      return false;\n\t    }\n\t    return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\n\t  }\n\t\n\t  /**\n\t   * Parse a string path into an array of segments\n\t   *\n\t   * @param {String} path\n\t   * @return {Array|undefined}\n\t   */\n\t\n\t  function parse(path) {\n\t    var keys = [];\n\t    var index = -1;\n\t    var mode = BEFORE_PATH;\n\t    var subPathDepth = 0;\n\t    var c, newChar, key, type, transition, action, typeMap;\n\t\n\t    var actions = [];\n\t\n\t    actions[PUSH] = function () {\n\t      if (key !== undefined) {\n\t        keys.push(key);\n\t        key = undefined;\n\t      }\n\t    };\n\t\n\t    actions[APPEND] = function () {\n\t      if (key === undefined) {\n\t        key = newChar;\n\t      } else {\n\t        key += newChar;\n\t      }\n\t    };\n\t\n\t    actions[INC_SUB_PATH_DEPTH] = function () {\n\t      actions[APPEND]();\n\t      subPathDepth++;\n\t    };\n\t\n\t    actions[PUSH_SUB_PATH] = function () {\n\t      if (subPathDepth > 0) {\n\t        subPathDepth--;\n\t        mode = IN_SUB_PATH;\n\t        actions[APPEND]();\n\t      } else {\n\t        subPathDepth = 0;\n\t        key = formatSubPath(key);\n\t        if (key === false) {\n\t          return false;\n\t        } else {\n\t          actions[PUSH]();\n\t        }\n\t      }\n\t    };\n\t\n\t    function maybeUnescapeQuote() {\n\t      var nextChar = path[index + 1];\n\t      if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\n\t        index++;\n\t        newChar = '\\\\' + nextChar;\n\t        actions[APPEND]();\n\t        return true;\n\t      }\n\t    }\n\t\n\t    while (mode != null) {\n\t      index++;\n\t      c = path[index];\n\t\n\t      if (c === '\\\\' && maybeUnescapeQuote()) {\n\t        continue;\n\t      }\n\t\n\t      type = getPathCharType(c);\n\t      typeMap = pathStateMachine[mode];\n\t      transition = typeMap[type] || typeMap['else'] || ERROR;\n\t\n\t      if (transition === ERROR) {\n\t        return; // parse error\n\t      }\n\t\n\t      mode = transition[0];\n\t      action = actions[transition[1]];\n\t      if (action) {\n\t        newChar = transition[2];\n\t        newChar = newChar === undefined ? c : newChar;\n\t        if (action() === false) {\n\t          return;\n\t        }\n\t      }\n\t\n\t      if (mode === AFTER_PATH) {\n\t        keys.raw = path;\n\t        return keys;\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * External parse that check for a cache hit first\n\t   *\n\t   * @param {String} path\n\t   * @return {Array|undefined}\n\t   */\n\t\n\t  function parsePath(path) {\n\t    var hit = pathCache.get(path);\n\t    if (!hit) {\n\t      hit = parse(path);\n\t      if (hit) {\n\t        pathCache.put(path, hit);\n\t      }\n\t    }\n\t    return hit;\n\t  }\n\t\n\t  /**\n\t   * Get from an object from a path string\n\t   *\n\t   * @param {Object} obj\n\t   * @param {String} path\n\t   */\n\t\n\t  function getPath(obj, path) {\n\t    return parseExpression(path).get(obj);\n\t  }\n\t\n\t  /**\n\t   * Warn against setting non-existent root path on a vm.\n\t   */\n\t\n\t  var warnNonExistent;\n\t  if (true) {\n\t    warnNonExistent = function (path) {\n\t      warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.');\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Set on an object from a path\n\t   *\n\t   * @param {Object} obj\n\t   * @param {String | Array} path\n\t   * @param {*} val\n\t   */\n\t\n\t  function setPath(obj, path, val) {\n\t    var original = obj;\n\t    if (typeof path === 'string') {\n\t      path = parse(path);\n\t    }\n\t    if (!path || !isObject(obj)) {\n\t      return false;\n\t    }\n\t    var last, key;\n\t    for (var i = 0, l = path.length; i < l; i++) {\n\t      last = obj;\n\t      key = path[i];\n\t      if (key.charAt(0) === '*') {\n\t        key = parseExpression(key.slice(1)).get.call(original, original);\n\t      }\n\t      if (i < l - 1) {\n\t        obj = obj[key];\n\t        if (!isObject(obj)) {\n\t          obj = {};\n\t          if ('development' !== 'production' && last._isVue) {\n\t            warnNonExistent(path);\n\t          }\n\t          set(last, key, obj);\n\t        }\n\t      } else {\n\t        if (isArray(obj)) {\n\t          obj.$set(key, val);\n\t        } else if (key in obj) {\n\t          obj[key] = val;\n\t        } else {\n\t          if ('development' !== 'production' && obj._isVue) {\n\t            warnNonExistent(path);\n\t          }\n\t          set(obj, key, val);\n\t        }\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t\n\t  var path = Object.freeze({\n\t    parsePath: parsePath,\n\t    getPath: getPath,\n\t    setPath: setPath\n\t  });\n\t\n\t  var expressionCache = new Cache(1000);\n\t\n\t  var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\n\t  var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\t\n\t  // keywords that don't make sense inside expressions\n\t  var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'proctected,static,interface,private,public';\n\t  var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\t\n\t  var wsRE = /\\s/g;\n\t  var newlineRE = /\\n/g;\n\t  var saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\")|new |typeof |void /g;\n\t  var restoreRE = /\"(\\d+)\"/g;\n\t  var pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\n\t  var identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\n\t  var booleanLiteralRE = /^(?:true|false)$/;\n\t\n\t  /**\n\t   * Save / Rewrite / Restore\n\t   *\n\t   * When rewriting paths found in an expression, it is\n\t   * possible for the same letter sequences to be found in\n\t   * strings and Object literal property keys. Therefore we\n\t   * remove and store these parts in a temporary array, and\n\t   * restore them after the path rewrite.\n\t   */\n\t\n\t  var saved = [];\n\t\n\t  /**\n\t   * Save replacer\n\t   *\n\t   * The save regex can match two possible cases:\n\t   * 1. An opening object literal\n\t   * 2. A string\n\t   * If matched as a plain string, we need to escape its\n\t   * newlines, since the string needs to be preserved when\n\t   * generating the function body.\n\t   *\n\t   * @param {String} str\n\t   * @param {String} isString - str if matched as a string\n\t   * @return {String} - placeholder with index\n\t   */\n\t\n\t  function save(str, isString) {\n\t    var i = saved.length;\n\t    saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\n\t    return '\"' + i + '\"';\n\t  }\n\t\n\t  /**\n\t   * Path rewrite replacer\n\t   *\n\t   * @param {String} raw\n\t   * @return {String}\n\t   */\n\t\n\t  function rewrite(raw) {\n\t    var c = raw.charAt(0);\n\t    var path = raw.slice(1);\n\t    if (allowedKeywordsRE.test(path)) {\n\t      return raw;\n\t    } else {\n\t      path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\n\t      return c + 'scope.' + path;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Restore replacer\n\t   *\n\t   * @param {String} str\n\t   * @param {String} i - matched save index\n\t   * @return {String}\n\t   */\n\t\n\t  function restore(str, i) {\n\t    return saved[i];\n\t  }\n\t\n\t  /**\n\t   * Rewrite an expression, prefixing all path accessors with\n\t   * `scope.` and generate getter/setter functions.\n\t   *\n\t   * @param {String} exp\n\t   * @return {Function}\n\t   */\n\t\n\t  function compileGetter(exp) {\n\t    if (improperKeywordsRE.test(exp)) {\n\t      'development' !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\n\t    }\n\t    // reset state\n\t    saved.length = 0;\n\t    // save strings and object literal keys\n\t    var body = exp.replace(saveRE, save).replace(wsRE, '');\n\t    // rewrite all paths\n\t    // pad 1 space here becaue the regex matches 1 extra char\n\t    body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\n\t    return makeGetterFn(body);\n\t  }\n\t\n\t  /**\n\t   * Build a getter function. Requires eval.\n\t   *\n\t   * We isolate the try/catch so it doesn't affect the\n\t   * optimization of the parse function when it is not called.\n\t   *\n\t   * @param {String} body\n\t   * @return {Function|undefined}\n\t   */\n\t\n\t  function makeGetterFn(body) {\n\t    try {\n\t      return new Function('scope', 'return ' + body + ';');\n\t    } catch (e) {\n\t      'development' !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Compile a setter function for the expression.\n\t   *\n\t   * @param {String} exp\n\t   * @return {Function|undefined}\n\t   */\n\t\n\t  function compileSetter(exp) {\n\t    var path = parsePath(exp);\n\t    if (path) {\n\t      return function (scope, val) {\n\t        setPath(scope, path, val);\n\t      };\n\t    } else {\n\t      'development' !== 'production' && warn('Invalid setter expression: ' + exp);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Parse an expression into re-written getter/setters.\n\t   *\n\t   * @param {String} exp\n\t   * @param {Boolean} needSet\n\t   * @return {Function}\n\t   */\n\t\n\t  function parseExpression(exp, needSet) {\n\t    exp = exp.trim();\n\t    // try cache\n\t    var hit = expressionCache.get(exp);\n\t    if (hit) {\n\t      if (needSet && !hit.set) {\n\t        hit.set = compileSetter(hit.exp);\n\t      }\n\t      return hit;\n\t    }\n\t    var res = { exp: exp };\n\t    res.get = isSimplePath(exp) && exp.indexOf('[') < 0\n\t    // optimized super simple getter\n\t    ? makeGetterFn('scope.' + exp)\n\t    // dynamic getter\n\t    : compileGetter(exp);\n\t    if (needSet) {\n\t      res.set = compileSetter(exp);\n\t    }\n\t    expressionCache.put(exp, res);\n\t    return res;\n\t  }\n\t\n\t  /**\n\t   * Check if an expression is a simple path.\n\t   *\n\t   * @param {String} exp\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function isSimplePath(exp) {\n\t    return pathTestRE.test(exp) &&\n\t    // don't treat true/false as paths\n\t    !booleanLiteralRE.test(exp) &&\n\t    // Math constants e.g. Math.PI, Math.E etc.\n\t    exp.slice(0, 5) !== 'Math.';\n\t  }\n\t\n\t  var expression = Object.freeze({\n\t    parseExpression: parseExpression,\n\t    isSimplePath: isSimplePath\n\t  });\n\t\n\t  // we have two separate queues: one for directive updates\n\t  // and one for user watcher registered via $watch().\n\t  // we want to guarantee directive updates to be called\n\t  // before user watchers so that when user watchers are\n\t  // triggered, the DOM would have already been in updated\n\t  // state.\n\t  var queue = [];\n\t  var userQueue = [];\n\t  var has = {};\n\t  var circular = {};\n\t  var waiting = false;\n\t  var internalQueueDepleted = false;\n\t\n\t  /**\n\t   * Reset the batcher's state.\n\t   */\n\t\n\t  function resetBatcherState() {\n\t    queue = [];\n\t    userQueue = [];\n\t    has = {};\n\t    circular = {};\n\t    waiting = internalQueueDepleted = false;\n\t  }\n\t\n\t  /**\n\t   * Flush both queues and run the watchers.\n\t   */\n\t\n\t  function flushBatcherQueue() {\n\t    runBatcherQueue(queue);\n\t    internalQueueDepleted = true;\n\t    runBatcherQueue(userQueue);\n\t    // dev tool hook\n\t    /* istanbul ignore if */\n\t    if (true) {\n\t      if (inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {\n\t        window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush');\n\t      }\n\t    }\n\t    resetBatcherState();\n\t  }\n\t\n\t  /**\n\t   * Run the watchers in a single queue.\n\t   *\n\t   * @param {Array} queue\n\t   */\n\t\n\t  function runBatcherQueue(queue) {\n\t    // do not cache length because more watchers might be pushed\n\t    // as we run existing watchers\n\t    for (var i = 0; i < queue.length; i++) {\n\t      var watcher = queue[i];\n\t      var id = watcher.id;\n\t      has[id] = null;\n\t      watcher.run();\n\t      // in dev build, check and stop circular updates.\n\t      if ('development' !== 'production' && has[id] != null) {\n\t        circular[id] = (circular[id] || 0) + 1;\n\t        if (circular[id] > config._maxUpdateCount) {\n\t          queue.splice(has[id], 1);\n\t          warn('You may have an infinite update loop for watcher ' + 'with expression: ' + watcher.expression);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Push a watcher into the watcher queue.\n\t   * Jobs with duplicate IDs will be skipped unless it's\n\t   * pushed when the queue is being flushed.\n\t   *\n\t   * @param {Watcher} watcher\n\t   *   properties:\n\t   *   - {Number} id\n\t   *   - {Function} run\n\t   */\n\t\n\t  function pushWatcher(watcher) {\n\t    var id = watcher.id;\n\t    if (has[id] == null) {\n\t      // if an internal watcher is pushed, but the internal\n\t      // queue is already depleted, we run it immediately.\n\t      if (internalQueueDepleted && !watcher.user) {\n\t        watcher.run();\n\t        return;\n\t      }\n\t      // push watcher into appropriate queue\n\t      var q = watcher.user ? userQueue : queue;\n\t      has[id] = q.length;\n\t      q.push(watcher);\n\t      // queue the flush\n\t      if (!waiting) {\n\t        waiting = true;\n\t        nextTick(flushBatcherQueue);\n\t      }\n\t    }\n\t  }\n\t\n\t  var uid$2 = 0;\n\t\n\t  /**\n\t   * A watcher parses an expression, collects dependencies,\n\t   * and fires callback when the expression value changes.\n\t   * This is used for both the $watch() api and directives.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {String} expression\n\t   * @param {Function} cb\n\t   * @param {Object} options\n\t   *                 - {Array} filters\n\t   *                 - {Boolean} twoWay\n\t   *                 - {Boolean} deep\n\t   *                 - {Boolean} user\n\t   *                 - {Boolean} sync\n\t   *                 - {Boolean} lazy\n\t   *                 - {Function} [preProcess]\n\t   *                 - {Function} [postProcess]\n\t   * @constructor\n\t   */\n\t  function Watcher(vm, expOrFn, cb, options) {\n\t    // mix in options\n\t    if (options) {\n\t      extend(this, options);\n\t    }\n\t    var isFn = typeof expOrFn === 'function';\n\t    this.vm = vm;\n\t    vm._watchers.push(this);\n\t    this.expression = isFn ? expOrFn.toString() : expOrFn;\n\t    this.cb = cb;\n\t    this.id = ++uid$2; // uid for batching\n\t    this.active = true;\n\t    this.dirty = this.lazy; // for lazy watchers\n\t    this.deps = Object.create(null);\n\t    this.newDeps = null;\n\t    this.prevError = null; // for async error stacks\n\t    // parse expression for getter/setter\n\t    if (isFn) {\n\t      this.getter = expOrFn;\n\t      this.setter = undefined;\n\t    } else {\n\t      var res = parseExpression(expOrFn, this.twoWay);\n\t      this.getter = res.get;\n\t      this.setter = res.set;\n\t    }\n\t    this.value = this.lazy ? undefined : this.get();\n\t    // state for avoiding false triggers for deep and Array\n\t    // watchers during vm._digest()\n\t    this.queued = this.shallow = false;\n\t  }\n\t\n\t  /**\n\t   * Add a dependency to this directive.\n\t   *\n\t   * @param {Dep} dep\n\t   */\n\t\n\t  Watcher.prototype.addDep = function (dep) {\n\t    var id = dep.id;\n\t    if (!this.newDeps[id]) {\n\t      this.newDeps[id] = dep;\n\t      if (!this.deps[id]) {\n\t        this.deps[id] = dep;\n\t        dep.addSub(this);\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Evaluate the getter, and re-collect dependencies.\n\t   */\n\t\n\t  Watcher.prototype.get = function () {\n\t    this.beforeGet();\n\t    var scope = this.scope || this.vm;\n\t    var value;\n\t    try {\n\t      value = this.getter.call(scope, scope);\n\t    } catch (e) {\n\t      if ('development' !== 'production' && config.warnExpressionErrors) {\n\t        warn('Error when evaluating expression \"' + this.expression + '\". ' + (config.debug ? '' : 'Turn on debug mode to see stack trace.'), e);\n\t      }\n\t    }\n\t    // \"touch\" every property so they are all tracked as\n\t    // dependencies for deep watching\n\t    if (this.deep) {\n\t      traverse(value);\n\t    }\n\t    if (this.preProcess) {\n\t      value = this.preProcess(value);\n\t    }\n\t    if (this.filters) {\n\t      value = scope._applyFilters(value, null, this.filters, false);\n\t    }\n\t    if (this.postProcess) {\n\t      value = this.postProcess(value);\n\t    }\n\t    this.afterGet();\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * Set the corresponding value with the setter.\n\t   *\n\t   * @param {*} value\n\t   */\n\t\n\t  Watcher.prototype.set = function (value) {\n\t    var scope = this.scope || this.vm;\n\t    if (this.filters) {\n\t      value = scope._applyFilters(value, this.value, this.filters, true);\n\t    }\n\t    try {\n\t      this.setter.call(scope, scope, value);\n\t    } catch (e) {\n\t      if ('development' !== 'production' && config.warnExpressionErrors) {\n\t        warn('Error when evaluating setter \"' + this.expression + '\"', e);\n\t      }\n\t    }\n\t    // two-way sync for v-for alias\n\t    var forContext = scope.$forContext;\n\t    if (forContext && forContext.alias === this.expression) {\n\t      if (forContext.filters) {\n\t        'development' !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.');\n\t        return;\n\t      }\n\t      forContext._withLock(function () {\n\t        if (scope.$key) {\n\t          // original is an object\n\t          forContext.rawValue[scope.$key] = value;\n\t        } else {\n\t          forContext.rawValue.$set(scope.$index, value);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Prepare for dependency collection.\n\t   */\n\t\n\t  Watcher.prototype.beforeGet = function () {\n\t    Dep.target = this;\n\t    this.newDeps = Object.create(null);\n\t  };\n\t\n\t  /**\n\t   * Clean up for dependency collection.\n\t   */\n\t\n\t  Watcher.prototype.afterGet = function () {\n\t    Dep.target = null;\n\t    var ids = Object.keys(this.deps);\n\t    var i = ids.length;\n\t    while (i--) {\n\t      var id = ids[i];\n\t      if (!this.newDeps[id]) {\n\t        this.deps[id].removeSub(this);\n\t      }\n\t    }\n\t    this.deps = this.newDeps;\n\t  };\n\t\n\t  /**\n\t   * Subscriber interface.\n\t   * Will be called when a dependency changes.\n\t   *\n\t   * @param {Boolean} shallow\n\t   */\n\t\n\t  Watcher.prototype.update = function (shallow) {\n\t    if (this.lazy) {\n\t      this.dirty = true;\n\t    } else if (this.sync || !config.async) {\n\t      this.run();\n\t    } else {\n\t      // if queued, only overwrite shallow with non-shallow,\n\t      // but not the other way around.\n\t      this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\n\t      this.queued = true;\n\t      // record before-push error stack in debug mode\n\t      /* istanbul ignore if */\n\t      if ('development' !== 'production' && config.debug) {\n\t        this.prevError = new Error('[vue] async stack trace');\n\t      }\n\t      pushWatcher(this);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Batcher job interface.\n\t   * Will be called by the batcher.\n\t   */\n\t\n\t  Watcher.prototype.run = function () {\n\t    if (this.active) {\n\t      var value = this.get();\n\t      if (value !== this.value ||\n\t      // Deep watchers and watchers on Object/Arrays should fire even\n\t      // when the value is the same, because the value may\n\t      // have mutated; but only do so if this is a\n\t      // non-shallow update (caused by a vm digest).\n\t      (isObject(value) || this.deep) && !this.shallow) {\n\t        // set new value\n\t        var oldValue = this.value;\n\t        this.value = value;\n\t        // in debug + async mode, when a watcher callbacks\n\t        // throws, we also throw the saved before-push error\n\t        // so the full cross-tick stack trace is available.\n\t        var prevError = this.prevError;\n\t        /* istanbul ignore if */\n\t        if ('development' !== 'production' && config.debug && prevError) {\n\t          this.prevError = null;\n\t          try {\n\t            this.cb.call(this.vm, value, oldValue);\n\t          } catch (e) {\n\t            nextTick(function () {\n\t              throw prevError;\n\t            }, 0);\n\t            throw e;\n\t          }\n\t        } else {\n\t          this.cb.call(this.vm, value, oldValue);\n\t        }\n\t      }\n\t      this.queued = this.shallow = false;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Evaluate the value of the watcher.\n\t   * This only gets called for lazy watchers.\n\t   */\n\t\n\t  Watcher.prototype.evaluate = function () {\n\t    // avoid overwriting another watcher that is being\n\t    // collected.\n\t    var current = Dep.target;\n\t    this.value = this.get();\n\t    this.dirty = false;\n\t    Dep.target = current;\n\t  };\n\t\n\t  /**\n\t   * Depend on all deps collected by this watcher.\n\t   */\n\t\n\t  Watcher.prototype.depend = function () {\n\t    var depIds = Object.keys(this.deps);\n\t    var i = depIds.length;\n\t    while (i--) {\n\t      this.deps[depIds[i]].depend();\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Remove self from all dependencies' subcriber list.\n\t   */\n\t\n\t  Watcher.prototype.teardown = function () {\n\t    if (this.active) {\n\t      // remove self from vm's watcher list\n\t      // we can skip this if the vm if being destroyed\n\t      // which can improve teardown performance.\n\t      if (!this.vm._isBeingDestroyed) {\n\t        this.vm._watchers.$remove(this);\n\t      }\n\t      var depIds = Object.keys(this.deps);\n\t      var i = depIds.length;\n\t      while (i--) {\n\t        this.deps[depIds[i]].removeSub(this);\n\t      }\n\t      this.active = false;\n\t      this.vm = this.cb = this.value = null;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Recrusively traverse an object to evoke all converted\n\t   * getters, so that every nested property inside the object\n\t   * is collected as a \"deep\" dependency.\n\t   *\n\t   * @param {*} val\n\t   */\n\t\n\t  function traverse(val) {\n\t    var i, keys;\n\t    if (isArray(val)) {\n\t      i = val.length;\n\t      while (i--) traverse(val[i]);\n\t    } else if (isObject(val)) {\n\t      keys = Object.keys(val);\n\t      i = keys.length;\n\t      while (i--) traverse(val[keys[i]]);\n\t    }\n\t  }\n\t\n\t  var cloak = {\n\t    bind: function bind() {\n\t      var el = this.el;\n\t      this.vm.$once('pre-hook:compiled', function () {\n\t        el.removeAttribute('v-cloak');\n\t      });\n\t    }\n\t  };\n\t\n\t  var ref = {\n\t    bind: function bind() {\n\t      'development' !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.');\n\t    }\n\t  };\n\t\n\t  var ON = 700;\n\t  var MODEL = 800;\n\t  var BIND = 850;\n\t  var TRANSITION = 1100;\n\t  var EL = 1500;\n\t  var COMPONENT = 1500;\n\t  var PARTIAL = 1750;\n\t  var SLOT = 1750;\n\t  var FOR = 2000;\n\t  var IF = 2000;\n\t\n\t  var el = {\n\t\n\t    priority: EL,\n\t\n\t    bind: function bind() {\n\t      /* istanbul ignore if */\n\t      if (!this.arg) {\n\t        return;\n\t      }\n\t      var id = this.id = camelize(this.arg);\n\t      var refs = (this._scope || this.vm).$els;\n\t      if (hasOwn(refs, id)) {\n\t        refs[id] = this.el;\n\t      } else {\n\t        defineReactive(refs, id, this.el);\n\t      }\n\t    },\n\t\n\t    unbind: function unbind() {\n\t      var refs = (this._scope || this.vm).$els;\n\t      if (refs[this.id] === this.el) {\n\t        refs[this.id] = null;\n\t      }\n\t    }\n\t  };\n\t\n\t  var prefixes = ['-webkit-', '-moz-', '-ms-'];\n\t  var camelPrefixes = ['Webkit', 'Moz', 'ms'];\n\t  var importantRE = /!important;?$/;\n\t  var propCache = Object.create(null);\n\t\n\t  var testEl = null;\n\t\n\t  var style = {\n\t\n\t    deep: true,\n\t\n\t    update: function update(value) {\n\t      if (typeof value === 'string') {\n\t        this.el.style.cssText = value;\n\t      } else if (isArray(value)) {\n\t        this.handleObject(value.reduce(extend, {}));\n\t      } else {\n\t        this.handleObject(value || {});\n\t      }\n\t    },\n\t\n\t    handleObject: function handleObject(value) {\n\t      // cache object styles so that only changed props\n\t      // are actually updated.\n\t      var cache = this.cache || (this.cache = {});\n\t      var name, val;\n\t      for (name in cache) {\n\t        if (!(name in value)) {\n\t          this.handleSingle(name, null);\n\t          delete cache[name];\n\t        }\n\t      }\n\t      for (name in value) {\n\t        val = value[name];\n\t        if (val !== cache[name]) {\n\t          cache[name] = val;\n\t          this.handleSingle(name, val);\n\t        }\n\t      }\n\t    },\n\t\n\t    handleSingle: function handleSingle(prop, value) {\n\t      prop = normalize(prop);\n\t      if (!prop) return; // unsupported prop\n\t      // cast possible numbers/booleans into strings\n\t      if (value != null) value += '';\n\t      if (value) {\n\t        var isImportant = importantRE.test(value) ? 'important' : '';\n\t        if (isImportant) {\n\t          value = value.replace(importantRE, '').trim();\n\t        }\n\t        this.el.style.setProperty(prop, value, isImportant);\n\t      } else {\n\t        this.el.style.removeProperty(prop);\n\t      }\n\t    }\n\t\n\t  };\n\t\n\t  /**\n\t   * Normalize a CSS property name.\n\t   * - cache result\n\t   * - auto prefix\n\t   * - camelCase -> dash-case\n\t   *\n\t   * @param {String} prop\n\t   * @return {String}\n\t   */\n\t\n\t  function normalize(prop) {\n\t    if (propCache[prop]) {\n\t      return propCache[prop];\n\t    }\n\t    var res = prefix(prop);\n\t    propCache[prop] = propCache[res] = res;\n\t    return res;\n\t  }\n\t\n\t  /**\n\t   * Auto detect the appropriate prefix for a CSS property.\n\t   * https://gist.github.com/paulirish/523692\n\t   *\n\t   * @param {String} prop\n\t   * @return {String}\n\t   */\n\t\n\t  function prefix(prop) {\n\t    prop = hyphenate(prop);\n\t    var camel = camelize(prop);\n\t    var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\n\t    if (!testEl) {\n\t      testEl = document.createElement('div');\n\t    }\n\t    if (camel in testEl.style) {\n\t      return prop;\n\t    }\n\t    var i = prefixes.length;\n\t    var prefixed;\n\t    while (i--) {\n\t      prefixed = camelPrefixes[i] + upper;\n\t      if (prefixed in testEl.style) {\n\t        return prefixes[i] + prop;\n\t      }\n\t    }\n\t  }\n\t\n\t  // xlink\n\t  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\t  var xlinkRE = /^xlink:/;\n\t\n\t  // check for attributes that prohibit interpolations\n\t  var disallowedInterpAttrRE = /^v-|^:|^@|^(is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\n\t\n\t  // these attributes should also set their corresponding properties\n\t  // because they only affect the initial state of the element\n\t  var attrWithPropsRE = /^(value|checked|selected|muted)$/;\n\t\n\t  // these attributes should set a hidden property for\n\t  // binding v-model to object values\n\t  var modelProps = {\n\t    value: '_value',\n\t    'true-value': '_trueValue',\n\t    'false-value': '_falseValue'\n\t  };\n\t\n\t  var bind = {\n\t\n\t    priority: BIND,\n\t\n\t    bind: function bind() {\n\t      var attr = this.arg;\n\t      var tag = this.el.tagName;\n\t      // should be deep watch on object mode\n\t      if (!attr) {\n\t        this.deep = true;\n\t      }\n\t      // handle interpolation bindings\n\t      var descriptor = this.descriptor;\n\t      var tokens = descriptor.interp;\n\t      if (tokens) {\n\t        // handle interpolations with one-time tokens\n\t        if (descriptor.hasOneTime) {\n\t          this.expression = tokensToExp(tokens, this._scope || this.vm);\n\t        }\n\t\n\t        // only allow binding on native attributes\n\t        if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\n\t          'development' !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.');\n\t          this.el.removeAttribute(attr);\n\t          this.invalid = true;\n\t        }\n\t\n\t        /* istanbul ignore if */\n\t        if (true) {\n\t          var raw = attr + '=\"' + descriptor.raw + '\": ';\n\t          // warn src\n\t          if (attr === 'src') {\n\t            warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.');\n\t          }\n\t\n\t          // warn style\n\t          if (attr === 'style') {\n\t            warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.');\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    update: function update(value) {\n\t      if (this.invalid) {\n\t        return;\n\t      }\n\t      var attr = this.arg;\n\t      if (this.arg) {\n\t        this.handleSingle(attr, value);\n\t      } else {\n\t        this.handleObject(value || {});\n\t      }\n\t    },\n\t\n\t    // share object handler with v-bind:class\n\t    handleObject: style.handleObject,\n\t\n\t    handleSingle: function handleSingle(attr, value) {\n\t      var el = this.el;\n\t      var interp = this.descriptor.interp;\n\t      if (!interp && attrWithPropsRE.test(attr) && attr in el) {\n\t        el[attr] = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\n\t        ? '' : value : value;\n\t      }\n\t      // set model props\n\t      var modelProp = modelProps[attr];\n\t      if (!interp && modelProp) {\n\t        el[modelProp] = value;\n\t        // update v-model if present\n\t        var model = el.__v_model;\n\t        if (model) {\n\t          model.listener();\n\t        }\n\t      }\n\t      // do not set value attribute for textarea\n\t      if (attr === 'value' && el.tagName === 'TEXTAREA') {\n\t        el.removeAttribute(attr);\n\t        return;\n\t      }\n\t      // update attribute\n\t      if (value != null && value !== false) {\n\t        if (attr === 'class') {\n\t          // handle edge case #1960:\n\t          // class interpolation should not overwrite Vue transition class\n\t          if (el.__v_trans) {\n\t            value += ' ' + el.__v_trans.id + '-transition';\n\t          }\n\t          setClass(el, value);\n\t        } else if (xlinkRE.test(attr)) {\n\t          el.setAttributeNS(xlinkNS, attr, value);\n\t        } else {\n\t          el.setAttribute(attr, value);\n\t        }\n\t      } else {\n\t        el.removeAttribute(attr);\n\t      }\n\t    }\n\t  };\n\t\n\t  // keyCode aliases\n\t  var keyCodes = {\n\t    esc: 27,\n\t    tab: 9,\n\t    enter: 13,\n\t    space: 32,\n\t    'delete': 46,\n\t    up: 38,\n\t    left: 37,\n\t    right: 39,\n\t    down: 40\n\t  };\n\t\n\t  function keyFilter(handler, keys) {\n\t    var codes = keys.map(function (key) {\n\t      var charCode = key.charCodeAt(0);\n\t      if (charCode > 47 && charCode < 58) {\n\t        return parseInt(key, 10);\n\t      }\n\t      if (key.length === 1) {\n\t        charCode = key.toUpperCase().charCodeAt(0);\n\t        if (charCode > 64 && charCode < 91) {\n\t          return charCode;\n\t        }\n\t      }\n\t      return keyCodes[key];\n\t    });\n\t    return function keyHandler(e) {\n\t      if (codes.indexOf(e.keyCode) > -1) {\n\t        return handler.call(this, e);\n\t      }\n\t    };\n\t  }\n\t\n\t  function stopFilter(handler) {\n\t    return function stopHandler(e) {\n\t      e.stopPropagation();\n\t      return handler.call(this, e);\n\t    };\n\t  }\n\t\n\t  function preventFilter(handler) {\n\t    return function preventHandler(e) {\n\t      e.preventDefault();\n\t      return handler.call(this, e);\n\t    };\n\t  }\n\t\n\t  var on = {\n\t\n\t    acceptStatement: true,\n\t    priority: ON,\n\t\n\t    bind: function bind() {\n\t      // deal with iframes\n\t      if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\n\t        var self = this;\n\t        this.iframeBind = function () {\n\t          on$1(self.el.contentWindow, self.arg, self.handler);\n\t        };\n\t        this.on('load', this.iframeBind);\n\t      }\n\t    },\n\t\n\t    update: function update(handler) {\n\t      // stub a noop for v-on with no value,\n\t      // e.g. @mousedown.prevent\n\t      if (!this.descriptor.raw) {\n\t        handler = function () {};\n\t      }\n\t\n\t      if (typeof handler !== 'function') {\n\t        'development' !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler);\n\t        return;\n\t      }\n\t\n\t      // apply modifiers\n\t      if (this.modifiers.stop) {\n\t        handler = stopFilter(handler);\n\t      }\n\t      if (this.modifiers.prevent) {\n\t        handler = preventFilter(handler);\n\t      }\n\t      // key filter\n\t      var keys = Object.keys(this.modifiers).filter(function (key) {\n\t        return key !== 'stop' && key !== 'prevent';\n\t      });\n\t      if (keys.length) {\n\t        handler = keyFilter(handler, keys);\n\t      }\n\t\n\t      this.reset();\n\t      this.handler = handler;\n\t\n\t      if (this.iframeBind) {\n\t        this.iframeBind();\n\t      } else {\n\t        on$1(this.el, this.arg, this.handler);\n\t      }\n\t    },\n\t\n\t    reset: function reset() {\n\t      var el = this.iframeBind ? this.el.contentWindow : this.el;\n\t      if (this.handler) {\n\t        off(el, this.arg, this.handler);\n\t      }\n\t    },\n\t\n\t    unbind: function unbind() {\n\t      this.reset();\n\t    }\n\t  };\n\t\n\t  var checkbox = {\n\t\n\t    bind: function bind() {\n\t      var self = this;\n\t      var el = this.el;\n\t\n\t      this.getValue = function () {\n\t        return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\n\t      };\n\t\n\t      function getBooleanValue() {\n\t        var val = el.checked;\n\t        if (val && el.hasOwnProperty('_trueValue')) {\n\t          return el._trueValue;\n\t        }\n\t        if (!val && el.hasOwnProperty('_falseValue')) {\n\t          return el._falseValue;\n\t        }\n\t        return val;\n\t      }\n\t\n\t      this.listener = function () {\n\t        var model = self._watcher.value;\n\t        if (isArray(model)) {\n\t          var val = self.getValue();\n\t          if (el.checked) {\n\t            if (indexOf(model, val) < 0) {\n\t              model.push(val);\n\t            }\n\t          } else {\n\t            model.$remove(val);\n\t          }\n\t        } else {\n\t          self.set(getBooleanValue());\n\t        }\n\t      };\n\t\n\t      this.on('change', this.listener);\n\t      if (el.hasAttribute('checked')) {\n\t        this.afterBind = this.listener;\n\t      }\n\t    },\n\t\n\t    update: function update(value) {\n\t      var el = this.el;\n\t      if (isArray(value)) {\n\t        el.checked = indexOf(value, this.getValue()) > -1;\n\t      } else {\n\t        if (el.hasOwnProperty('_trueValue')) {\n\t          el.checked = looseEqual(value, el._trueValue);\n\t        } else {\n\t          el.checked = !!value;\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  var select = {\n\t\n\t    bind: function bind() {\n\t      var self = this;\n\t      var el = this.el;\n\t\n\t      // method to force update DOM using latest value.\n\t      this.forceUpdate = function () {\n\t        if (self._watcher) {\n\t          self.update(self._watcher.get());\n\t        }\n\t      };\n\t\n\t      // check if this is a multiple select\n\t      var multiple = this.multiple = el.hasAttribute('multiple');\n\t\n\t      // attach listener\n\t      this.listener = function () {\n\t        var value = getValue(el, multiple);\n\t        value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\n\t        self.set(value);\n\t      };\n\t      this.on('change', this.listener);\n\t\n\t      // if has initial value, set afterBind\n\t      var initValue = getValue(el, multiple, true);\n\t      if (multiple && initValue.length || !multiple && initValue !== null) {\n\t        this.afterBind = this.listener;\n\t      }\n\t\n\t      // All major browsers except Firefox resets\n\t      // selectedIndex with value -1 to 0 when the element\n\t      // is appended to a new parent, therefore we have to\n\t      // force a DOM update whenever that happens...\n\t      this.vm.$on('hook:attached', this.forceUpdate);\n\t    },\n\t\n\t    update: function update(value) {\n\t      var el = this.el;\n\t      el.selectedIndex = -1;\n\t      var multi = this.multiple && isArray(value);\n\t      var options = el.options;\n\t      var i = options.length;\n\t      var op, val;\n\t      while (i--) {\n\t        op = options[i];\n\t        val = op.hasOwnProperty('_value') ? op._value : op.value;\n\t        /* eslint-disable eqeqeq */\n\t        op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\n\t        /* eslint-enable eqeqeq */\n\t      }\n\t    },\n\t\n\t    unbind: function unbind() {\n\t      /* istanbul ignore next */\n\t      this.vm.$off('hook:attached', this.forceUpdate);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Get select value\n\t   *\n\t   * @param {SelectElement} el\n\t   * @param {Boolean} multi\n\t   * @param {Boolean} init\n\t   * @return {Array|*}\n\t   */\n\t\n\t  function getValue(el, multi, init) {\n\t    var res = multi ? [] : null;\n\t    var op, val, selected;\n\t    for (var i = 0, l = el.options.length; i < l; i++) {\n\t      op = el.options[i];\n\t      selected = init ? op.hasAttribute('selected') : op.selected;\n\t      if (selected) {\n\t        val = op.hasOwnProperty('_value') ? op._value : op.value;\n\t        if (multi) {\n\t          res.push(val);\n\t        } else {\n\t          return val;\n\t        }\n\t      }\n\t    }\n\t    return res;\n\t  }\n\t\n\t  /**\n\t   * Native Array.indexOf uses strict equal, but in this\n\t   * case we need to match string/numbers with custom equal.\n\t   *\n\t   * @param {Array} arr\n\t   * @param {*} val\n\t   */\n\t\n\t  function indexOf$1(arr, val) {\n\t    var i = arr.length;\n\t    while (i--) {\n\t      if (looseEqual(arr[i], val)) {\n\t        return i;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  var radio = {\n\t\n\t    bind: function bind() {\n\t      var self = this;\n\t      var el = this.el;\n\t\n\t      this.getValue = function () {\n\t        // value overwrite via v-bind:value\n\t        if (el.hasOwnProperty('_value')) {\n\t          return el._value;\n\t        }\n\t        var val = el.value;\n\t        if (self.params.number) {\n\t          val = toNumber(val);\n\t        }\n\t        return val;\n\t      };\n\t\n\t      this.listener = function () {\n\t        self.set(self.getValue());\n\t      };\n\t      this.on('change', this.listener);\n\t\n\t      if (el.hasAttribute('checked')) {\n\t        this.afterBind = this.listener;\n\t      }\n\t    },\n\t\n\t    update: function update(value) {\n\t      this.el.checked = looseEqual(value, this.getValue());\n\t    }\n\t  };\n\t\n\t  var text$2 = {\n\t\n\t    bind: function bind() {\n\t      var self = this;\n\t      var el = this.el;\n\t      var isRange = el.type === 'range';\n\t      var lazy = this.params.lazy;\n\t      var number = this.params.number;\n\t      var debounce = this.params.debounce;\n\t\n\t      // handle composition events.\n\t      //   http://blog.evanyou.me/2014/01/03/composition-event/\n\t      // skip this for Android because it handles composition\n\t      // events quite differently. Android doesn't trigger\n\t      // composition events for language input methods e.g.\n\t      // Chinese, but instead triggers them for spelling\n\t      // suggestions... (see Discussion/#162)\n\t      var composing = false;\n\t      if (!isAndroid && !isRange) {\n\t        this.on('compositionstart', function () {\n\t          composing = true;\n\t        });\n\t        this.on('compositionend', function () {\n\t          composing = false;\n\t          // in IE11 the \"compositionend\" event fires AFTER\n\t          // the \"input\" event, so the input handler is blocked\n\t          // at the end... have to call it here.\n\t          //\n\t          // #1327: in lazy mode this is unecessary.\n\t          if (!lazy) {\n\t            self.listener();\n\t          }\n\t        });\n\t      }\n\t\n\t      // prevent messing with the input when user is typing,\n\t      // and force update on blur.\n\t      this.focused = false;\n\t      if (!isRange && !lazy) {\n\t        this.on('focus', function () {\n\t          self.focused = true;\n\t        });\n\t        this.on('blur', function () {\n\t          self.focused = false;\n\t          // do not sync value after fragment removal (#2017)\n\t          if (!self._frag || self._frag.inserted) {\n\t            self.rawListener();\n\t          }\n\t        });\n\t      }\n\t\n\t      // Now attach the main listener\n\t      this.listener = this.rawListener = function () {\n\t        if (composing || !self._bound) {\n\t          return;\n\t        }\n\t        var val = number || isRange ? toNumber(el.value) : el.value;\n\t        self.set(val);\n\t        // force update on next tick to avoid lock & same value\n\t        // also only update when user is not typing\n\t        nextTick(function () {\n\t          if (self._bound && !self.focused) {\n\t            self.update(self._watcher.value);\n\t          }\n\t        });\n\t      };\n\t\n\t      // apply debounce\n\t      if (debounce) {\n\t        this.listener = _debounce(this.listener, debounce);\n\t      }\n\t\n\t      // Support jQuery events, since jQuery.trigger() doesn't\n\t      // trigger native events in some cases and some plugins\n\t      // rely on $.trigger()\n\t      //\n\t      // We want to make sure if a listener is attached using\n\t      // jQuery, it is also removed with jQuery, that's why\n\t      // we do the check for each directive instance and\n\t      // store that check result on itself. This also allows\n\t      // easier test coverage control by unsetting the global\n\t      // jQuery variable in tests.\n\t      this.hasjQuery = typeof jQuery === 'function';\n\t      if (this.hasjQuery) {\n\t        jQuery(el).on('change', this.listener);\n\t        if (!lazy) {\n\t          jQuery(el).on('input', this.listener);\n\t        }\n\t      } else {\n\t        this.on('change', this.listener);\n\t        if (!lazy) {\n\t          this.on('input', this.listener);\n\t        }\n\t      }\n\t\n\t      // IE9 doesn't fire input event on backspace/del/cut\n\t      if (!lazy && isIE9) {\n\t        this.on('cut', function () {\n\t          nextTick(self.listener);\n\t        });\n\t        this.on('keyup', function (e) {\n\t          if (e.keyCode === 46 || e.keyCode === 8) {\n\t            self.listener();\n\t          }\n\t        });\n\t      }\n\t\n\t      // set initial value if present\n\t      if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\n\t        this.afterBind = this.listener;\n\t      }\n\t    },\n\t\n\t    update: function update(value) {\n\t      this.el.value = _toString(value);\n\t    },\n\t\n\t    unbind: function unbind() {\n\t      var el = this.el;\n\t      if (this.hasjQuery) {\n\t        jQuery(el).off('change', this.listener);\n\t        jQuery(el).off('input', this.listener);\n\t      }\n\t    }\n\t  };\n\t\n\t  var handlers = {\n\t    text: text$2,\n\t    radio: radio,\n\t    select: select,\n\t    checkbox: checkbox\n\t  };\n\t\n\t  var model = {\n\t\n\t    priority: MODEL,\n\t    twoWay: true,\n\t    handlers: handlers,\n\t    params: ['lazy', 'number', 'debounce'],\n\t\n\t    /**\n\t     * Possible elements:\n\t     *   <select>\n\t     *   <textarea>\n\t     *   <input type=\"*\">\n\t     *     - text\n\t     *     - checkbox\n\t     *     - radio\n\t     *     - number\n\t     */\n\t\n\t    bind: function bind() {\n\t      // friendly warning...\n\t      this.checkFilters();\n\t      if (this.hasRead && !this.hasWrite) {\n\t        'development' !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model. You might want to use a two-way filter ' + 'to ensure correct behavior.');\n\t      }\n\t      var el = this.el;\n\t      var tag = el.tagName;\n\t      var handler;\n\t      if (tag === 'INPUT') {\n\t        handler = handlers[el.type] || handlers.text;\n\t      } else if (tag === 'SELECT') {\n\t        handler = handlers.select;\n\t      } else if (tag === 'TEXTAREA') {\n\t        handler = handlers.text;\n\t      } else {\n\t        'development' !== 'production' && warn('v-model does not support element type: ' + tag);\n\t        return;\n\t      }\n\t      el.__v_model = this;\n\t      handler.bind.call(this);\n\t      this.update = handler.update;\n\t      this._unbind = handler.unbind;\n\t    },\n\t\n\t    /**\n\t     * Check read/write filter stats.\n\t     */\n\t\n\t    checkFilters: function checkFilters() {\n\t      var filters = this.filters;\n\t      if (!filters) return;\n\t      var i = filters.length;\n\t      while (i--) {\n\t        var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\n\t        if (typeof filter === 'function' || filter.read) {\n\t          this.hasRead = true;\n\t        }\n\t        if (filter.write) {\n\t          this.hasWrite = true;\n\t        }\n\t      }\n\t    },\n\t\n\t    unbind: function unbind() {\n\t      this.el.__v_model = null;\n\t      this._unbind && this._unbind();\n\t    }\n\t  };\n\t\n\t  var show = {\n\t\n\t    bind: function bind() {\n\t      // check else block\n\t      var next = this.el.nextElementSibling;\n\t      if (next && getAttr(next, 'v-else') !== null) {\n\t        this.elseEl = next;\n\t      }\n\t    },\n\t\n\t    update: function update(value) {\n\t      this.apply(this.el, value);\n\t      if (this.elseEl) {\n\t        this.apply(this.elseEl, !value);\n\t      }\n\t    },\n\t\n\t    apply: function apply(el, value) {\n\t      if (inDoc(el)) {\n\t        applyTransition(el, value ? 1 : -1, toggle, this.vm);\n\t      } else {\n\t        toggle();\n\t      }\n\t      function toggle() {\n\t        el.style.display = value ? '' : 'none';\n\t      }\n\t    }\n\t  };\n\t\n\t  var templateCache = new Cache(1000);\n\t  var idSelectorCache = new Cache(1000);\n\t\n\t  var map = {\n\t    efault: [0, '', ''],\n\t    legend: [1, '<fieldset>', '</fieldset>'],\n\t    tr: [2, '<table><tbody>', '</tbody></table>'],\n\t    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\n\t  };\n\t\n\t  map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\t\n\t  map.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\t\n\t  map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\n\t\n\t  map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\n\t\n\t  /**\n\t   * Check if a node is a supported template node with a\n\t   * DocumentFragment content.\n\t   *\n\t   * @param {Node} node\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function isRealTemplate(node) {\n\t    return isTemplate(node) && node.content instanceof DocumentFragment;\n\t  }\n\t\n\t  var tagRE$1 = /<([\\w:]+)/;\n\t  var entityRE = /&#?\\w+?;/;\n\t\n\t  /**\n\t   * Convert a string template to a DocumentFragment.\n\t   * Determines correct wrapping by tag types. Wrapping\n\t   * strategy found in jQuery & component/domify.\n\t   *\n\t   * @param {String} templateString\n\t   * @param {Boolean} raw\n\t   * @return {DocumentFragment}\n\t   */\n\t\n\t  function stringToFragment(templateString, raw) {\n\t    // try a cache hit first\n\t    var hit = templateCache.get(templateString);\n\t    if (hit) {\n\t      return hit;\n\t    }\n\t\n\t    var frag = document.createDocumentFragment();\n\t    var tagMatch = templateString.match(tagRE$1);\n\t    var entityMatch = entityRE.test(templateString);\n\t\n\t    if (!tagMatch && !entityMatch) {\n\t      // text only, return a single text node.\n\t      frag.appendChild(document.createTextNode(templateString));\n\t    } else {\n\t\n\t      var tag = tagMatch && tagMatch[1];\n\t      var wrap = map[tag] || map.efault;\n\t      var depth = wrap[0];\n\t      var prefix = wrap[1];\n\t      var suffix = wrap[2];\n\t      var node = document.createElement('div');\n\t\n\t      if (!raw) {\n\t        templateString = templateString.trim();\n\t      }\n\t      node.innerHTML = prefix + templateString + suffix;\n\t      while (depth--) {\n\t        node = node.lastChild;\n\t      }\n\t\n\t      var child;\n\t      /* eslint-disable no-cond-assign */\n\t      while (child = node.firstChild) {\n\t        /* eslint-enable no-cond-assign */\n\t        frag.appendChild(child);\n\t      }\n\t    }\n\t\n\t    templateCache.put(templateString, frag);\n\t    return frag;\n\t  }\n\t\n\t  /**\n\t   * Convert a template node to a DocumentFragment.\n\t   *\n\t   * @param {Node} node\n\t   * @return {DocumentFragment}\n\t   */\n\t\n\t  function nodeToFragment(node) {\n\t    // if its a template tag and the browser supports it,\n\t    // its content is already a document fragment.\n\t    if (isRealTemplate(node)) {\n\t      trimNode(node.content);\n\t      return node.content;\n\t    }\n\t    // script template\n\t    if (node.tagName === 'SCRIPT') {\n\t      return stringToFragment(node.textContent);\n\t    }\n\t    // normal node, clone it to avoid mutating the original\n\t    var clonedNode = cloneNode(node);\n\t    var frag = document.createDocumentFragment();\n\t    var child;\n\t    /* eslint-disable no-cond-assign */\n\t    while (child = clonedNode.firstChild) {\n\t      /* eslint-enable no-cond-assign */\n\t      frag.appendChild(child);\n\t    }\n\t    trimNode(frag);\n\t    return frag;\n\t  }\n\t\n\t  // Test for the presence of the Safari template cloning bug\n\t  // https://bugs.webkit.org/showug.cgi?id=137755\n\t  var hasBrokenTemplate = (function () {\n\t    /* istanbul ignore else */\n\t    if (inBrowser) {\n\t      var a = document.createElement('div');\n\t      a.innerHTML = '<template>1</template>';\n\t      return !a.cloneNode(true).firstChild.innerHTML;\n\t    } else {\n\t      return false;\n\t    }\n\t  })();\n\t\n\t  // Test for IE10/11 textarea placeholder clone bug\n\t  var hasTextareaCloneBug = (function () {\n\t    /* istanbul ignore else */\n\t    if (inBrowser) {\n\t      var t = document.createElement('textarea');\n\t      t.placeholder = 't';\n\t      return t.cloneNode(true).value === 't';\n\t    } else {\n\t      return false;\n\t    }\n\t  })();\n\t\n\t  /**\n\t   * 1. Deal with Safari cloning nested <template> bug by\n\t   *    manually cloning all template instances.\n\t   * 2. Deal with IE10/11 textarea placeholder bug by setting\n\t   *    the correct value after cloning.\n\t   *\n\t   * @param {Element|DocumentFragment} node\n\t   * @return {Element|DocumentFragment}\n\t   */\n\t\n\t  function cloneNode(node) {\n\t    if (!node.querySelectorAll) {\n\t      return node.cloneNode();\n\t    }\n\t    var res = node.cloneNode(true);\n\t    var i, original, cloned;\n\t    /* istanbul ignore if */\n\t    if (hasBrokenTemplate) {\n\t      var tempClone = res;\n\t      if (isRealTemplate(node)) {\n\t        node = node.content;\n\t        tempClone = res.content;\n\t      }\n\t      original = node.querySelectorAll('template');\n\t      if (original.length) {\n\t        cloned = tempClone.querySelectorAll('template');\n\t        i = cloned.length;\n\t        while (i--) {\n\t          cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\n\t        }\n\t      }\n\t    }\n\t    /* istanbul ignore if */\n\t    if (hasTextareaCloneBug) {\n\t      if (node.tagName === 'TEXTAREA') {\n\t        res.value = node.value;\n\t      } else {\n\t        original = node.querySelectorAll('textarea');\n\t        if (original.length) {\n\t          cloned = res.querySelectorAll('textarea');\n\t          i = cloned.length;\n\t          while (i--) {\n\t            cloned[i].value = original[i].value;\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return res;\n\t  }\n\t\n\t  /**\n\t   * Process the template option and normalizes it into a\n\t   * a DocumentFragment that can be used as a partial or a\n\t   * instance template.\n\t   *\n\t   * @param {*} template\n\t   *        Possible values include:\n\t   *        - DocumentFragment object\n\t   *        - Node object of type Template\n\t   *        - id selector: '#some-template-id'\n\t   *        - template string: '<div><span>{{msg}}</span></div>'\n\t   * @param {Boolean} shouldClone\n\t   * @param {Boolean} raw\n\t   *        inline HTML interpolation. Do not check for id\n\t   *        selector and keep whitespace in the string.\n\t   * @return {DocumentFragment|undefined}\n\t   */\n\t\n\t  function parseTemplate(template, shouldClone, raw) {\n\t    var node, frag;\n\t\n\t    // if the template is already a document fragment,\n\t    // do nothing\n\t    if (template instanceof DocumentFragment) {\n\t      trimNode(template);\n\t      return shouldClone ? cloneNode(template) : template;\n\t    }\n\t\n\t    if (typeof template === 'string') {\n\t      // id selector\n\t      if (!raw && template.charAt(0) === '#') {\n\t        // id selector can be cached too\n\t        frag = idSelectorCache.get(template);\n\t        if (!frag) {\n\t          node = document.getElementById(template.slice(1));\n\t          if (node) {\n\t            frag = nodeToFragment(node);\n\t            // save selector to cache\n\t            idSelectorCache.put(template, frag);\n\t          }\n\t        }\n\t      } else {\n\t        // normal string template\n\t        frag = stringToFragment(template, raw);\n\t      }\n\t    } else if (template.nodeType) {\n\t      // a direct node\n\t      frag = nodeToFragment(template);\n\t    }\n\t\n\t    return frag && shouldClone ? cloneNode(frag) : frag;\n\t  }\n\t\n\t  var template = Object.freeze({\n\t    cloneNode: cloneNode,\n\t    parseTemplate: parseTemplate\n\t  });\n\t\n\t  /**\n\t   * Abstraction for a partially-compiled fragment.\n\t   * Can optionally compile content with a child scope.\n\t   *\n\t   * @param {Function} linker\n\t   * @param {Vue} vm\n\t   * @param {DocumentFragment} frag\n\t   * @param {Vue} [host]\n\t   * @param {Object} [scope]\n\t   */\n\t  function Fragment(linker, vm, frag, host, scope, parentFrag) {\n\t    this.children = [];\n\t    this.childFrags = [];\n\t    this.vm = vm;\n\t    this.scope = scope;\n\t    this.inserted = false;\n\t    this.parentFrag = parentFrag;\n\t    if (parentFrag) {\n\t      parentFrag.childFrags.push(this);\n\t    }\n\t    this.unlink = linker(vm, frag, host, scope, this);\n\t    var single = this.single = frag.childNodes.length === 1 &&\n\t    // do not go single mode if the only node is an anchor\n\t    !frag.childNodes[0].__vue_anchor;\n\t    if (single) {\n\t      this.node = frag.childNodes[0];\n\t      this.before = singleBefore;\n\t      this.remove = singleRemove;\n\t    } else {\n\t      this.node = createAnchor('fragment-start');\n\t      this.end = createAnchor('fragment-end');\n\t      this.frag = frag;\n\t      prepend(this.node, frag);\n\t      frag.appendChild(this.end);\n\t      this.before = multiBefore;\n\t      this.remove = multiRemove;\n\t    }\n\t    this.node.__vfrag__ = this;\n\t  }\n\t\n\t  /**\n\t   * Call attach/detach for all components contained within\n\t   * this fragment. Also do so recursively for all child\n\t   * fragments.\n\t   *\n\t   * @param {Function} hook\n\t   */\n\t\n\t  Fragment.prototype.callHook = function (hook) {\n\t    var i, l;\n\t    for (i = 0, l = this.childFrags.length; i < l; i++) {\n\t      this.childFrags[i].callHook(hook);\n\t    }\n\t    for (i = 0, l = this.children.length; i < l; i++) {\n\t      hook(this.children[i]);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Insert fragment before target, single node version\n\t   *\n\t   * @param {Node} target\n\t   * @param {Boolean} withTransition\n\t   */\n\t\n\t  function singleBefore(target, withTransition) {\n\t    this.inserted = true;\n\t    var method = withTransition !== false ? beforeWithTransition : before;\n\t    method(this.node, target, this.vm);\n\t    if (inDoc(this.node)) {\n\t      this.callHook(attach);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Remove fragment, single node version\n\t   */\n\t\n\t  function singleRemove() {\n\t    this.inserted = false;\n\t    var shouldCallRemove = inDoc(this.node);\n\t    var self = this;\n\t    this.beforeRemove();\n\t    removeWithTransition(this.node, this.vm, function () {\n\t      if (shouldCallRemove) {\n\t        self.callHook(detach);\n\t      }\n\t      self.destroy();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Insert fragment before target, multi-nodes version\n\t   *\n\t   * @param {Node} target\n\t   * @param {Boolean} withTransition\n\t   */\n\t\n\t  function multiBefore(target, withTransition) {\n\t    this.inserted = true;\n\t    var vm = this.vm;\n\t    var method = withTransition !== false ? beforeWithTransition : before;\n\t    mapNodeRange(this.node, this.end, function (node) {\n\t      method(node, target, vm);\n\t    });\n\t    if (inDoc(this.node)) {\n\t      this.callHook(attach);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Remove fragment, multi-nodes version\n\t   */\n\t\n\t  function multiRemove() {\n\t    this.inserted = false;\n\t    var self = this;\n\t    var shouldCallRemove = inDoc(this.node);\n\t    this.beforeRemove();\n\t    removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n\t      if (shouldCallRemove) {\n\t        self.callHook(detach);\n\t      }\n\t      self.destroy();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Prepare the fragment for removal.\n\t   */\n\t\n\t  Fragment.prototype.beforeRemove = function () {\n\t    var i, l;\n\t    for (i = 0, l = this.childFrags.length; i < l; i++) {\n\t      // call the same method recursively on child\n\t      // fragments, depth-first\n\t      this.childFrags[i].beforeRemove(false);\n\t    }\n\t    for (i = 0, l = this.children.length; i < l; i++) {\n\t      // Call destroy for all contained instances,\n\t      // with remove:false and defer:true.\n\t      // Defer is necessary because we need to\n\t      // keep the children to call detach hooks\n\t      // on them.\n\t      this.children[i].$destroy(false, true);\n\t    }\n\t    var dirs = this.unlink.dirs;\n\t    for (i = 0, l = dirs.length; i < l; i++) {\n\t      // disable the watchers on all the directives\n\t      // so that the rendered content stays the same\n\t      // during removal.\n\t      dirs[i]._watcher && dirs[i]._watcher.teardown();\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Destroy the fragment.\n\t   */\n\t\n\t  Fragment.prototype.destroy = function () {\n\t    if (this.parentFrag) {\n\t      this.parentFrag.childFrags.$remove(this);\n\t    }\n\t    this.unlink();\n\t  };\n\t\n\t  /**\n\t   * Call attach hook for a Vue instance.\n\t   *\n\t   * @param {Vue} child\n\t   */\n\t\n\t  function attach(child) {\n\t    if (!child._isAttached) {\n\t      child._callHook('attached');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Call detach hook for a Vue instance.\n\t   *\n\t   * @param {Vue} child\n\t   */\n\t\n\t  function detach(child) {\n\t    if (child._isAttached) {\n\t      child._callHook('detached');\n\t    }\n\t  }\n\t\n\t  var linkerCache = new Cache(5000);\n\t\n\t  /**\n\t   * A factory that can be used to create instances of a\n\t   * fragment. Caches the compiled linker if possible.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element|String} el\n\t   */\n\t  function FragmentFactory(vm, el) {\n\t    this.vm = vm;\n\t    var template;\n\t    var isString = typeof el === 'string';\n\t    if (isString || isTemplate(el)) {\n\t      template = parseTemplate(el, true);\n\t    } else {\n\t      template = document.createDocumentFragment();\n\t      template.appendChild(el);\n\t    }\n\t    this.template = template;\n\t    // linker can be cached, but only for components\n\t    var linker;\n\t    var cid = vm.constructor.cid;\n\t    if (cid > 0) {\n\t      var cacheId = cid + (isString ? el : el.outerHTML);\n\t      linker = linkerCache.get(cacheId);\n\t      if (!linker) {\n\t        linker = compile(template, vm.$options, true);\n\t        linkerCache.put(cacheId, linker);\n\t      }\n\t    } else {\n\t      linker = compile(template, vm.$options, true);\n\t    }\n\t    this.linker = linker;\n\t  }\n\t\n\t  /**\n\t   * Create a fragment instance with given host and scope.\n\t   *\n\t   * @param {Vue} host\n\t   * @param {Object} scope\n\t   * @param {Fragment} parentFrag\n\t   */\n\t\n\t  FragmentFactory.prototype.create = function (host, scope, parentFrag) {\n\t    var frag = cloneNode(this.template);\n\t    return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\n\t  };\n\t\n\t  var vIf = {\n\t\n\t    priority: IF,\n\t\n\t    bind: function bind() {\n\t      var el = this.el;\n\t      if (!el.__vue__) {\n\t        // check else block\n\t        var next = el.nextElementSibling;\n\t        if (next && getAttr(next, 'v-else') !== null) {\n\t          remove(next);\n\t          this.elseFactory = new FragmentFactory(this.vm, next);\n\t        }\n\t        // check main block\n\t        this.anchor = createAnchor('v-if');\n\t        replace(el, this.anchor);\n\t        this.factory = new FragmentFactory(this.vm, el);\n\t      } else {\n\t        'development' !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.');\n\t        this.invalid = true;\n\t      }\n\t    },\n\t\n\t    update: function update(value) {\n\t      if (this.invalid) return;\n\t      if (value) {\n\t        if (!this.frag) {\n\t          this.insert();\n\t        }\n\t      } else {\n\t        this.remove();\n\t      }\n\t    },\n\t\n\t    insert: function insert() {\n\t      if (this.elseFrag) {\n\t        this.elseFrag.remove();\n\t        this.elseFrag = null;\n\t      }\n\t      this.frag = this.factory.create(this._host, this._scope, this._frag);\n\t      this.frag.before(this.anchor);\n\t    },\n\t\n\t    remove: function remove() {\n\t      if (this.frag) {\n\t        this.frag.remove();\n\t        this.frag = null;\n\t      }\n\t      if (this.elseFactory && !this.elseFrag) {\n\t        this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\n\t        this.elseFrag.before(this.anchor);\n\t      }\n\t    },\n\t\n\t    unbind: function unbind() {\n\t      if (this.frag) {\n\t        this.frag.destroy();\n\t      }\n\t    }\n\t  };\n\t\n\t  var uid$1 = 0;\n\t\n\t  var vFor = {\n\t\n\t    priority: FOR,\n\t\n\t    params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\n\t\n\t    bind: function bind() {\n\t      // support \"item in items\" syntax\n\t      var inMatch = this.expression.match(/(.*) in (.*)/);\n\t      if (inMatch) {\n\t        var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n\t        if (itMatch) {\n\t          this.iterator = itMatch[1].trim();\n\t          this.alias = itMatch[2].trim();\n\t        } else {\n\t          this.alias = inMatch[1].trim();\n\t        }\n\t        this.expression = inMatch[2];\n\t      }\n\t\n\t      if (!this.alias) {\n\t        'development' !== 'production' && warn('Alias is required in v-for.');\n\t        return;\n\t      }\n\t\n\t      // uid as a cache identifier\n\t      this.id = '__v-for__' + ++uid$1;\n\t\n\t      // check if this is an option list,\n\t      // so that we know if we need to update the <select>'s\n\t      // v-model when the option list has changed.\n\t      // because v-model has a lower priority than v-for,\n\t      // the v-model is not bound here yet, so we have to\n\t      // retrive it in the actual updateModel() function.\n\t      var tag = this.el.tagName;\n\t      this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\n\t\n\t      // setup anchor nodes\n\t      this.start = createAnchor('v-for-start');\n\t      this.end = createAnchor('v-for-end');\n\t      replace(this.el, this.end);\n\t      before(this.start, this.end);\n\t\n\t      // cache\n\t      this.cache = Object.create(null);\n\t\n\t      // fragment factory\n\t      this.factory = new FragmentFactory(this.vm, this.el);\n\t    },\n\t\n\t    update: function update(data) {\n\t      this.diff(data);\n\t      this.updateRef();\n\t      this.updateModel();\n\t    },\n\t\n\t    /**\n\t     * Diff, based on new data and old data, determine the\n\t     * minimum amount of DOM manipulations needed to make the\n\t     * DOM reflect the new data Array.\n\t     *\n\t     * The algorithm diffs the new data Array by storing a\n\t     * hidden reference to an owner vm instance on previously\n\t     * seen data. This allows us to achieve O(n) which is\n\t     * better than a levenshtein distance based algorithm,\n\t     * which is O(m * n).\n\t     *\n\t     * @param {Array} data\n\t     */\n\t\n\t    diff: function diff(data) {\n\t      // check if the Array was converted from an Object\n\t      var item = data[0];\n\t      var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\n\t\n\t      var trackByKey = this.params.trackBy;\n\t      var oldFrags = this.frags;\n\t      var frags = this.frags = new Array(data.length);\n\t      var alias = this.alias;\n\t      var iterator = this.iterator;\n\t      var start = this.start;\n\t      var end = this.end;\n\t      var inDocument = inDoc(start);\n\t      var init = !oldFrags;\n\t      var i, l, frag, key, value, primitive;\n\t\n\t      // First pass, go through the new Array and fill up\n\t      // the new frags array. If a piece of data has a cached\n\t      // instance for it, we reuse it. Otherwise build a new\n\t      // instance.\n\t      for (i = 0, l = data.length; i < l; i++) {\n\t        item = data[i];\n\t        key = convertedFromObject ? item.$key : null;\n\t        value = convertedFromObject ? item.$value : item;\n\t        primitive = !isObject(value);\n\t        frag = !init && this.getCachedFrag(value, i, key);\n\t        if (frag) {\n\t          // reusable fragment\n\t          frag.reused = true;\n\t          // update $index\n\t          frag.scope.$index = i;\n\t          // update $key\n\t          if (key) {\n\t            frag.scope.$key = key;\n\t          }\n\t          // update iterator\n\t          if (iterator) {\n\t            frag.scope[iterator] = key !== null ? key : i;\n\t          }\n\t          // update data for track-by, object repeat &\n\t          // primitive values.\n\t          if (trackByKey || convertedFromObject || primitive) {\n\t            frag.scope[alias] = value;\n\t          }\n\t        } else {\n\t          // new isntance\n\t          frag = this.create(value, alias, i, key);\n\t          frag.fresh = !init;\n\t        }\n\t        frags[i] = frag;\n\t        if (init) {\n\t          frag.before(end);\n\t        }\n\t      }\n\t\n\t      // we're done for the initial render.\n\t      if (init) {\n\t        return;\n\t      }\n\t\n\t      // Second pass, go through the old fragments and\n\t      // destroy those who are not reused (and remove them\n\t      // from cache)\n\t      var removalIndex = 0;\n\t      var totalRemoved = oldFrags.length - frags.length;\n\t      for (i = 0, l = oldFrags.length; i < l; i++) {\n\t        frag = oldFrags[i];\n\t        if (!frag.reused) {\n\t          this.deleteCachedFrag(frag);\n\t          this.remove(frag, removalIndex++, totalRemoved, inDocument);\n\t        }\n\t      }\n\t\n\t      // Final pass, move/insert new fragments into the\n\t      // right place.\n\t      var targetPrev, prevEl, currentPrev;\n\t      var insertionIndex = 0;\n\t      for (i = 0, l = frags.length; i < l; i++) {\n\t        frag = frags[i];\n\t        // this is the frag that we should be after\n\t        targetPrev = frags[i - 1];\n\t        prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n\t        if (frag.reused && !frag.staggerCb) {\n\t          currentPrev = findPrevFrag(frag, start, this.id);\n\t          if (currentPrev !== targetPrev && (!currentPrev ||\n\t          // optimization for moving a single item.\n\t          // thanks to suggestions by @livoras in #1807\n\t          findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\n\t            this.move(frag, prevEl);\n\t          }\n\t        } else {\n\t          // new instance, or still in stagger.\n\t          // insert with updated stagger index.\n\t          this.insert(frag, insertionIndex++, prevEl, inDocument);\n\t        }\n\t        frag.reused = frag.fresh = false;\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Create a new fragment instance.\n\t     *\n\t     * @param {*} value\n\t     * @param {String} alias\n\t     * @param {Number} index\n\t     * @param {String} [key]\n\t     * @return {Fragment}\n\t     */\n\t\n\t    create: function create(value, alias, index, key) {\n\t      var host = this._host;\n\t      // create iteration scope\n\t      var parentScope = this._scope || this.vm;\n\t      var scope = Object.create(parentScope);\n\t      // ref holder for the scope\n\t      scope.$refs = Object.create(parentScope.$refs);\n\t      scope.$els = Object.create(parentScope.$els);\n\t      // make sure point $parent to parent scope\n\t      scope.$parent = parentScope;\n\t      // for two-way binding on alias\n\t      scope.$forContext = this;\n\t      // define scope properties\n\t      defineReactive(scope, alias, value);\n\t      defineReactive(scope, '$index', index);\n\t      if (key) {\n\t        defineReactive(scope, '$key', key);\n\t      } else if (scope.$key) {\n\t        // avoid accidental fallback\n\t        def(scope, '$key', null);\n\t      }\n\t      if (this.iterator) {\n\t        defineReactive(scope, this.iterator, key !== null ? key : index);\n\t      }\n\t      var frag = this.factory.create(host, scope, this._frag);\n\t      frag.forId = this.id;\n\t      this.cacheFrag(value, frag, index, key);\n\t      return frag;\n\t    },\n\t\n\t    /**\n\t     * Update the v-ref on owner vm.\n\t     */\n\t\n\t    updateRef: function updateRef() {\n\t      var ref = this.descriptor.ref;\n\t      if (!ref) return;\n\t      var hash = (this._scope || this.vm).$refs;\n\t      var refs;\n\t      if (!this.fromObject) {\n\t        refs = this.frags.map(findVmFromFrag);\n\t      } else {\n\t        refs = {};\n\t        this.frags.forEach(function (frag) {\n\t          refs[frag.scope.$key] = findVmFromFrag(frag);\n\t        });\n\t      }\n\t      hash[ref] = refs;\n\t    },\n\t\n\t    /**\n\t     * For option lists, update the containing v-model on\n\t     * parent <select>.\n\t     */\n\t\n\t    updateModel: function updateModel() {\n\t      if (this.isOption) {\n\t        var parent = this.start.parentNode;\n\t        var model = parent && parent.__v_model;\n\t        if (model) {\n\t          model.forceUpdate();\n\t        }\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Insert a fragment. Handles staggering.\n\t     *\n\t     * @param {Fragment} frag\n\t     * @param {Number} index\n\t     * @param {Node} prevEl\n\t     * @param {Boolean} inDocument\n\t     */\n\t\n\t    insert: function insert(frag, index, prevEl, inDocument) {\n\t      if (frag.staggerCb) {\n\t        frag.staggerCb.cancel();\n\t        frag.staggerCb = null;\n\t      }\n\t      var staggerAmount = this.getStagger(frag, index, null, 'enter');\n\t      if (inDocument && staggerAmount) {\n\t        // create an anchor and insert it synchronously,\n\t        // so that we can resolve the correct order without\n\t        // worrying about some elements not inserted yet\n\t        var anchor = frag.staggerAnchor;\n\t        if (!anchor) {\n\t          anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\n\t          anchor.__vfrag__ = frag;\n\t        }\n\t        after(anchor, prevEl);\n\t        var op = frag.staggerCb = cancellable(function () {\n\t          frag.staggerCb = null;\n\t          frag.before(anchor);\n\t          remove(anchor);\n\t        });\n\t        setTimeout(op, staggerAmount);\n\t      } else {\n\t        frag.before(prevEl.nextSibling);\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Remove a fragment. Handles staggering.\n\t     *\n\t     * @param {Fragment} frag\n\t     * @param {Number} index\n\t     * @param {Number} total\n\t     * @param {Boolean} inDocument\n\t     */\n\t\n\t    remove: function remove(frag, index, total, inDocument) {\n\t      if (frag.staggerCb) {\n\t        frag.staggerCb.cancel();\n\t        frag.staggerCb = null;\n\t        // it's not possible for the same frag to be removed\n\t        // twice, so if we have a pending stagger callback,\n\t        // it means this frag is queued for enter but removed\n\t        // before its transition started. Since it is already\n\t        // destroyed, we can just leave it in detached state.\n\t        return;\n\t      }\n\t      var staggerAmount = this.getStagger(frag, index, total, 'leave');\n\t      if (inDocument && staggerAmount) {\n\t        var op = frag.staggerCb = cancellable(function () {\n\t          frag.staggerCb = null;\n\t          frag.remove();\n\t        });\n\t        setTimeout(op, staggerAmount);\n\t      } else {\n\t        frag.remove();\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Move a fragment to a new position.\n\t     * Force no transition.\n\t     *\n\t     * @param {Fragment} frag\n\t     * @param {Node} prevEl\n\t     */\n\t\n\t    move: function move(frag, prevEl) {\n\t      frag.before(prevEl.nextSibling, false);\n\t    },\n\t\n\t    /**\n\t     * Cache a fragment using track-by or the object key.\n\t     *\n\t     * @param {*} value\n\t     * @param {Fragment} frag\n\t     * @param {Number} index\n\t     * @param {String} [key]\n\t     */\n\t\n\t    cacheFrag: function cacheFrag(value, frag, index, key) {\n\t      var trackByKey = this.params.trackBy;\n\t      var cache = this.cache;\n\t      var primitive = !isObject(value);\n\t      var id;\n\t      if (key || trackByKey || primitive) {\n\t        id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;\n\t        if (!cache[id]) {\n\t          cache[id] = frag;\n\t        } else if (trackByKey !== '$index') {\n\t          'development' !== 'production' && this.warnDuplicate(value);\n\t        }\n\t      } else {\n\t        id = this.id;\n\t        if (hasOwn(value, id)) {\n\t          if (value[id] === null) {\n\t            value[id] = frag;\n\t          } else {\n\t            'development' !== 'production' && this.warnDuplicate(value);\n\t          }\n\t        } else {\n\t          def(value, id, frag);\n\t        }\n\t      }\n\t      frag.raw = value;\n\t    },\n\t\n\t    /**\n\t     * Get a cached fragment from the value/index/key\n\t     *\n\t     * @param {*} value\n\t     * @param {Number} index\n\t     * @param {String} key\n\t     * @return {Fragment}\n\t     */\n\t\n\t    getCachedFrag: function getCachedFrag(value, index, key) {\n\t      var trackByKey = this.params.trackBy;\n\t      var primitive = !isObject(value);\n\t      var frag;\n\t      if (key || trackByKey || primitive) {\n\t        var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;\n\t        frag = this.cache[id];\n\t      } else {\n\t        frag = value[this.id];\n\t      }\n\t      if (frag && (frag.reused || frag.fresh)) {\n\t        'development' !== 'production' && this.warnDuplicate(value);\n\t      }\n\t      return frag;\n\t    },\n\t\n\t    /**\n\t     * Delete a fragment from cache.\n\t     *\n\t     * @param {Fragment} frag\n\t     */\n\t\n\t    deleteCachedFrag: function deleteCachedFrag(frag) {\n\t      var value = frag.raw;\n\t      var trackByKey = this.params.trackBy;\n\t      var scope = frag.scope;\n\t      var index = scope.$index;\n\t      // fix #948: avoid accidentally fall through to\n\t      // a parent repeater which happens to have $key.\n\t      var key = hasOwn(scope, '$key') && scope.$key;\n\t      var primitive = !isObject(value);\n\t      if (trackByKey || key || primitive) {\n\t        var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;\n\t        this.cache[id] = null;\n\t      } else {\n\t        value[this.id] = null;\n\t        frag.raw = null;\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Get the stagger amount for an insertion/removal.\n\t     *\n\t     * @param {Fragment} frag\n\t     * @param {Number} index\n\t     * @param {Number} total\n\t     * @param {String} type\n\t     */\n\t\n\t    getStagger: function getStagger(frag, index, total, type) {\n\t      type = type + 'Stagger';\n\t      var trans = frag.node.__v_trans;\n\t      var hooks = trans && trans.hooks;\n\t      var hook = hooks && (hooks[type] || hooks.stagger);\n\t      return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\n\t    },\n\t\n\t    /**\n\t     * Pre-process the value before piping it through the\n\t     * filters. This is passed to and called by the watcher.\n\t     */\n\t\n\t    _preProcess: function _preProcess(value) {\n\t      // regardless of type, store the un-filtered raw value.\n\t      this.rawValue = value;\n\t      return value;\n\t    },\n\t\n\t    /**\n\t     * Post-process the value after it has been piped through\n\t     * the filters. This is passed to and called by the watcher.\n\t     *\n\t     * It is necessary for this to be called during the\n\t     * wathcer's dependency collection phase because we want\n\t     * the v-for to update when the source Object is mutated.\n\t     */\n\t\n\t    _postProcess: function _postProcess(value) {\n\t      if (isArray(value)) {\n\t        return value;\n\t      } else if (isPlainObject(value)) {\n\t        // convert plain object to array.\n\t        var keys = Object.keys(value);\n\t        var i = keys.length;\n\t        var res = new Array(i);\n\t        var key;\n\t        while (i--) {\n\t          key = keys[i];\n\t          res[i] = {\n\t            $key: key,\n\t            $value: value[key]\n\t          };\n\t        }\n\t        return res;\n\t      } else {\n\t        if (typeof value === 'number') {\n\t          value = range(value);\n\t        }\n\t        return value || [];\n\t      }\n\t    },\n\t\n\t    unbind: function unbind() {\n\t      if (this.descriptor.ref) {\n\t        (this._scope || this.vm).$refs[this.descriptor.ref] = null;\n\t      }\n\t      if (this.frags) {\n\t        var i = this.frags.length;\n\t        var frag;\n\t        while (i--) {\n\t          frag = this.frags[i];\n\t          this.deleteCachedFrag(frag);\n\t          frag.destroy();\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Helper to find the previous element that is a fragment\n\t   * anchor. This is necessary because a destroyed frag's\n\t   * element could still be lingering in the DOM before its\n\t   * leaving transition finishes, but its inserted flag\n\t   * should have been set to false so we can skip them.\n\t   *\n\t   * If this is a block repeat, we want to make sure we only\n\t   * return frag that is bound to this v-for. (see #929)\n\t   *\n\t   * @param {Fragment} frag\n\t   * @param {Comment|Text} anchor\n\t   * @param {String} id\n\t   * @return {Fragment}\n\t   */\n\t\n\t  function findPrevFrag(frag, anchor, id) {\n\t    var el = frag.node.previousSibling;\n\t    /* istanbul ignore if */\n\t    if (!el) return;\n\t    frag = el.__vfrag__;\n\t    while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\n\t      el = el.previousSibling;\n\t      /* istanbul ignore if */\n\t      if (!el) return;\n\t      frag = el.__vfrag__;\n\t    }\n\t    return frag;\n\t  }\n\t\n\t  /**\n\t   * Find a vm from a fragment.\n\t   *\n\t   * @param {Fragment} frag\n\t   * @return {Vue|undefined}\n\t   */\n\t\n\t  function findVmFromFrag(frag) {\n\t    var node = frag.node;\n\t    // handle multi-node frag\n\t    if (frag.end) {\n\t      while (!node.__vue__ && node !== frag.end && node.nextSibling) {\n\t        node = node.nextSibling;\n\t      }\n\t    }\n\t    return node.__vue__;\n\t  }\n\t\n\t  /**\n\t   * Create a range array from given number.\n\t   *\n\t   * @param {Number} n\n\t   * @return {Array}\n\t   */\n\t\n\t  function range(n) {\n\t    var i = -1;\n\t    var ret = new Array(n);\n\t    while (++i < n) {\n\t      ret[i] = i;\n\t    }\n\t    return ret;\n\t  }\n\t\n\t  if (true) {\n\t    vFor.warnDuplicate = function (value) {\n\t      warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.');\n\t    };\n\t  }\n\t\n\t  var html = {\n\t\n\t    bind: function bind() {\n\t      // a comment node means this is a binding for\n\t      // {{{ inline unescaped html }}}\n\t      if (this.el.nodeType === 8) {\n\t        // hold nodes\n\t        this.nodes = [];\n\t        // replace the placeholder with proper anchor\n\t        this.anchor = createAnchor('v-html');\n\t        replace(this.el, this.anchor);\n\t      }\n\t    },\n\t\n\t    update: function update(value) {\n\t      value = _toString(value);\n\t      if (this.nodes) {\n\t        this.swap(value);\n\t      } else {\n\t        this.el.innerHTML = value;\n\t      }\n\t    },\n\t\n\t    swap: function swap(value) {\n\t      // remove old nodes\n\t      var i = this.nodes.length;\n\t      while (i--) {\n\t        remove(this.nodes[i]);\n\t      }\n\t      // convert new value to a fragment\n\t      // do not attempt to retrieve from id selector\n\t      var frag = parseTemplate(value, true, true);\n\t      // save a reference to these nodes so we can remove later\n\t      this.nodes = toArray(frag.childNodes);\n\t      before(frag, this.anchor);\n\t    }\n\t  };\n\t\n\t  var text = {\n\t\n\t    bind: function bind() {\n\t      this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n\t    },\n\t\n\t    update: function update(value) {\n\t      this.el[this.attr] = _toString(value);\n\t    }\n\t  };\n\t\n\t  // must export plain object\n\t  var publicDirectives = {\n\t    text: text,\n\t    html: html,\n\t    'for': vFor,\n\t    'if': vIf,\n\t    show: show,\n\t    model: model,\n\t    on: on,\n\t    bind: bind,\n\t    el: el,\n\t    ref: ref,\n\t    cloak: cloak\n\t  };\n\t\n\t  var queue$1 = [];\n\t  var queued = false;\n\t\n\t  /**\n\t   * Push a job into the queue.\n\t   *\n\t   * @param {Function} job\n\t   */\n\t\n\t  function pushJob(job) {\n\t    queue$1.push(job);\n\t    if (!queued) {\n\t      queued = true;\n\t      nextTick(flush);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Flush the queue, and do one forced reflow before\n\t   * triggering transitions.\n\t   */\n\t\n\t  function flush() {\n\t    // Force layout\n\t    var f = document.documentElement.offsetHeight;\n\t    for (var i = 0; i < queue$1.length; i++) {\n\t      queue$1[i]();\n\t    }\n\t    queue$1 = [];\n\t    queued = false;\n\t    // dummy return, so js linters don't complain about\n\t    // unused variable f\n\t    return f;\n\t  }\n\t\n\t  var TYPE_TRANSITION = 'transition';\n\t  var TYPE_ANIMATION = 'animation';\n\t  var transDurationProp = transitionProp + 'Duration';\n\t  var animDurationProp = animationProp + 'Duration';\n\t\n\t  /**\n\t   * A Transition object that encapsulates the state and logic\n\t   * of the transition.\n\t   *\n\t   * @param {Element} el\n\t   * @param {String} id\n\t   * @param {Object} hooks\n\t   * @param {Vue} vm\n\t   */\n\t  function Transition(el, id, hooks, vm) {\n\t    this.id = id;\n\t    this.el = el;\n\t    this.enterClass = hooks && hooks.enterClass || id + '-enter';\n\t    this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\n\t    this.hooks = hooks;\n\t    this.vm = vm;\n\t    // async state\n\t    this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\n\t    this.justEntered = false;\n\t    this.entered = this.left = false;\n\t    this.typeCache = {};\n\t    // check css transition type\n\t    this.type = hooks && hooks.type;\n\t    /* istanbul ignore if */\n\t    if (true) {\n\t      if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\n\t        warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type);\n\t      }\n\t    }\n\t    // bind\n\t    var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\n\t      self[m] = bind$1(self[m], self);\n\t    });\n\t  }\n\t\n\t  var p$1 = Transition.prototype;\n\t\n\t  /**\n\t   * Start an entering transition.\n\t   *\n\t   * 1. enter transition triggered\n\t   * 2. call beforeEnter hook\n\t   * 3. add enter class\n\t   * 4. insert/show element\n\t   * 5. call enter hook (with possible explicit js callback)\n\t   * 6. reflow\n\t   * 7. based on transition type:\n\t   *    - transition:\n\t   *        remove class now, wait for transitionend,\n\t   *        then done if there's no explicit js callback.\n\t   *    - animation:\n\t   *        wait for animationend, remove class,\n\t   *        then done if there's no explicit js callback.\n\t   *    - no css transition:\n\t   *        done now if there's no explicit js callback.\n\t   * 8. wait for either done or js callback, then call\n\t   *    afterEnter hook.\n\t   *\n\t   * @param {Function} op - insert/show the element\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  p$1.enter = function (op, cb) {\n\t    this.cancelPending();\n\t    this.callHook('beforeEnter');\n\t    this.cb = cb;\n\t    addClass(this.el, this.enterClass);\n\t    op();\n\t    this.entered = false;\n\t    this.callHookWithCb('enter');\n\t    if (this.entered) {\n\t      return; // user called done synchronously.\n\t    }\n\t    this.cancel = this.hooks && this.hooks.enterCancelled;\n\t    pushJob(this.enterNextTick);\n\t  };\n\t\n\t  /**\n\t   * The \"nextTick\" phase of an entering transition, which is\n\t   * to be pushed into a queue and executed after a reflow so\n\t   * that removing the class can trigger a CSS transition.\n\t   */\n\t\n\t  p$1.enterNextTick = function () {\n\t\n\t    // Important hack:\n\t    // in Chrome, if a just-entered element is applied the\n\t    // leave class while its interpolated property still has\n\t    // a very small value (within one frame), Chrome will\n\t    // skip the leave transition entirely and not firing the\n\t    // transtionend event. Therefore we need to protected\n\t    // against such cases using a one-frame timeout.\n\t    this.justEntered = true;\n\t    var self = this;\n\t    setTimeout(function () {\n\t      self.justEntered = false;\n\t    }, 17);\n\t\n\t    var enterDone = this.enterDone;\n\t    var type = this.getCssTransitionType(this.enterClass);\n\t    if (!this.pendingJsCb) {\n\t      if (type === TYPE_TRANSITION) {\n\t        // trigger transition by removing enter class now\n\t        removeClass(this.el, this.enterClass);\n\t        this.setupCssCb(transitionEndEvent, enterDone);\n\t      } else if (type === TYPE_ANIMATION) {\n\t        this.setupCssCb(animationEndEvent, enterDone);\n\t      } else {\n\t        enterDone();\n\t      }\n\t    } else if (type === TYPE_TRANSITION) {\n\t      removeClass(this.el, this.enterClass);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * The \"cleanup\" phase of an entering transition.\n\t   */\n\t\n\t  p$1.enterDone = function () {\n\t    this.entered = true;\n\t    this.cancel = this.pendingJsCb = null;\n\t    removeClass(this.el, this.enterClass);\n\t    this.callHook('afterEnter');\n\t    if (this.cb) this.cb();\n\t  };\n\t\n\t  /**\n\t   * Start a leaving transition.\n\t   *\n\t   * 1. leave transition triggered.\n\t   * 2. call beforeLeave hook\n\t   * 3. add leave class (trigger css transition)\n\t   * 4. call leave hook (with possible explicit js callback)\n\t   * 5. reflow if no explicit js callback is provided\n\t   * 6. based on transition type:\n\t   *    - transition or animation:\n\t   *        wait for end event, remove class, then done if\n\t   *        there's no explicit js callback.\n\t   *    - no css transition:\n\t   *        done if there's no explicit js callback.\n\t   * 7. wait for either done or js callback, then call\n\t   *    afterLeave hook.\n\t   *\n\t   * @param {Function} op - remove/hide the element\n\t   * @param {Function} [cb]\n\t   */\n\t\n\t  p$1.leave = function (op, cb) {\n\t    this.cancelPending();\n\t    this.callHook('beforeLeave');\n\t    this.op = op;\n\t    this.cb = cb;\n\t    addClass(this.el, this.leaveClass);\n\t    this.left = false;\n\t    this.callHookWithCb('leave');\n\t    if (this.left) {\n\t      return; // user called done synchronously.\n\t    }\n\t    this.cancel = this.hooks && this.hooks.leaveCancelled;\n\t    // only need to handle leaveDone if\n\t    // 1. the transition is already done (synchronously called\n\t    //    by the user, which causes this.op set to null)\n\t    // 2. there's no explicit js callback\n\t    if (this.op && !this.pendingJsCb) {\n\t      // if a CSS transition leaves immediately after enter,\n\t      // the transitionend event never fires. therefore we\n\t      // detect such cases and end the leave immediately.\n\t      if (this.justEntered) {\n\t        this.leaveDone();\n\t      } else {\n\t        pushJob(this.leaveNextTick);\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * The \"nextTick\" phase of a leaving transition.\n\t   */\n\t\n\t  p$1.leaveNextTick = function () {\n\t    var type = this.getCssTransitionType(this.leaveClass);\n\t    if (type) {\n\t      var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\n\t      this.setupCssCb(event, this.leaveDone);\n\t    } else {\n\t      this.leaveDone();\n\t    }\n\t  };\n\t\n\t  /**\n\t   * The \"cleanup\" phase of a leaving transition.\n\t   */\n\t\n\t  p$1.leaveDone = function () {\n\t    this.left = true;\n\t    this.cancel = this.pendingJsCb = null;\n\t    this.op();\n\t    removeClass(this.el, this.leaveClass);\n\t    this.callHook('afterLeave');\n\t    if (this.cb) this.cb();\n\t    this.op = null;\n\t  };\n\t\n\t  /**\n\t   * Cancel any pending callbacks from a previously running\n\t   * but not finished transition.\n\t   */\n\t\n\t  p$1.cancelPending = function () {\n\t    this.op = this.cb = null;\n\t    var hasPending = false;\n\t    if (this.pendingCssCb) {\n\t      hasPending = true;\n\t      off(this.el, this.pendingCssEvent, this.pendingCssCb);\n\t      this.pendingCssEvent = this.pendingCssCb = null;\n\t    }\n\t    if (this.pendingJsCb) {\n\t      hasPending = true;\n\t      this.pendingJsCb.cancel();\n\t      this.pendingJsCb = null;\n\t    }\n\t    if (hasPending) {\n\t      removeClass(this.el, this.enterClass);\n\t      removeClass(this.el, this.leaveClass);\n\t    }\n\t    if (this.cancel) {\n\t      this.cancel.call(this.vm, this.el);\n\t      this.cancel = null;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Call a user-provided synchronous hook function.\n\t   *\n\t   * @param {String} type\n\t   */\n\t\n\t  p$1.callHook = function (type) {\n\t    if (this.hooks && this.hooks[type]) {\n\t      this.hooks[type].call(this.vm, this.el);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Call a user-provided, potentially-async hook function.\n\t   * We check for the length of arguments to see if the hook\n\t   * expects a `done` callback. If true, the transition's end\n\t   * will be determined by when the user calls that callback;\n\t   * otherwise, the end is determined by the CSS transition or\n\t   * animation.\n\t   *\n\t   * @param {String} type\n\t   */\n\t\n\t  p$1.callHookWithCb = function (type) {\n\t    var hook = this.hooks && this.hooks[type];\n\t    if (hook) {\n\t      if (hook.length > 1) {\n\t        this.pendingJsCb = cancellable(this[type + 'Done']);\n\t      }\n\t      hook.call(this.vm, this.el, this.pendingJsCb);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Get an element's transition type based on the\n\t   * calculated styles.\n\t   *\n\t   * @param {String} className\n\t   * @return {Number}\n\t   */\n\t\n\t  p$1.getCssTransitionType = function (className) {\n\t    /* istanbul ignore if */\n\t    if (!transitionEndEvent ||\n\t    // skip CSS transitions if page is not visible -\n\t    // this solves the issue of transitionend events not\n\t    // firing until the page is visible again.\n\t    // pageVisibility API is supported in IE10+, same as\n\t    // CSS transitions.\n\t    document.hidden ||\n\t    // explicit js-only transition\n\t    this.hooks && this.hooks.css === false ||\n\t    // element is hidden\n\t    isHidden(this.el)) {\n\t      return;\n\t    }\n\t    var type = this.type || this.typeCache[className];\n\t    if (type) return type;\n\t    var inlineStyles = this.el.style;\n\t    var computedStyles = window.getComputedStyle(this.el);\n\t    var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\n\t    if (transDuration && transDuration !== '0s') {\n\t      type = TYPE_TRANSITION;\n\t    } else {\n\t      var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\n\t      if (animDuration && animDuration !== '0s') {\n\t        type = TYPE_ANIMATION;\n\t      }\n\t    }\n\t    if (type) {\n\t      this.typeCache[className] = type;\n\t    }\n\t    return type;\n\t  };\n\t\n\t  /**\n\t   * Setup a CSS transitionend/animationend callback.\n\t   *\n\t   * @param {String} event\n\t   * @param {Function} cb\n\t   */\n\t\n\t  p$1.setupCssCb = function (event, cb) {\n\t    this.pendingCssEvent = event;\n\t    var self = this;\n\t    var el = this.el;\n\t    var onEnd = this.pendingCssCb = function (e) {\n\t      if (e.target === el) {\n\t        off(el, event, onEnd);\n\t        self.pendingCssEvent = self.pendingCssCb = null;\n\t        if (!self.pendingJsCb && cb) {\n\t          cb();\n\t        }\n\t      }\n\t    };\n\t    on$1(el, event, onEnd);\n\t  };\n\t\n\t  /**\n\t   * Check if an element is hidden - in that case we can just\n\t   * skip the transition alltogether.\n\t   *\n\t   * @param {Element} el\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function isHidden(el) {\n\t    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n\t  }\n\t\n\t  var transition = {\n\t\n\t    priority: TRANSITION,\n\t\n\t    update: function update(id, oldId) {\n\t      var el = this.el;\n\t      // resolve on owner vm\n\t      var hooks = resolveAsset(this.vm.$options, 'transitions', id);\n\t      id = id || 'v';\n\t      // apply on closest vm\n\t      el.__v_trans = new Transition(el, id, hooks, this.el.__vue__ || this.vm);\n\t      if (oldId) {\n\t        removeClass(el, oldId + '-transition');\n\t      }\n\t      addClass(el, id + '-transition');\n\t    }\n\t  };\n\t\n\t  var bindingModes = config._propBindingModes;\n\t\n\t  var propDef = {\n\t\n\t    bind: function bind() {\n\t\n\t      var child = this.vm;\n\t      var parent = child._context;\n\t      // passed in from compiler directly\n\t      var prop = this.descriptor.prop;\n\t      var childKey = prop.path;\n\t      var parentKey = prop.parentPath;\n\t      var twoWay = prop.mode === bindingModes.TWO_WAY;\n\t\n\t      var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\n\t        val = coerceProp(prop, val);\n\t        if (assertProp(prop, val)) {\n\t          child[childKey] = val;\n\t        }\n\t      }, {\n\t        twoWay: twoWay,\n\t        filters: prop.filters,\n\t        // important: props need to be observed on the\n\t        // v-for scope if present\n\t        scope: this._scope\n\t      });\n\t\n\t      // set the child initial value.\n\t      initProp(child, prop, parentWatcher.value);\n\t\n\t      // setup two-way binding\n\t      if (twoWay) {\n\t        // important: defer the child watcher creation until\n\t        // the created hook (after data observation)\n\t        var self = this;\n\t        child.$once('pre-hook:created', function () {\n\t          self.childWatcher = new Watcher(child, childKey, function (val) {\n\t            parentWatcher.set(val);\n\t          }, {\n\t            // ensure sync upward before parent sync down.\n\t            // this is necessary in cases e.g. the child\n\t            // mutates a prop array, then replaces it. (#1683)\n\t            sync: true\n\t          });\n\t        });\n\t      }\n\t    },\n\t\n\t    unbind: function unbind() {\n\t      this.parentWatcher.teardown();\n\t      if (this.childWatcher) {\n\t        this.childWatcher.teardown();\n\t      }\n\t    }\n\t  };\n\t\n\t  var component = {\n\t\n\t    priority: COMPONENT,\n\t\n\t    params: ['keep-alive', 'transition-mode', 'inline-template'],\n\t\n\t    /**\n\t     * Setup. Two possible usages:\n\t     *\n\t     * - static:\n\t     *   <comp> or <div v-component=\"comp\">\n\t     *\n\t     * - dynamic:\n\t     *   <component :is=\"view\">\n\t     */\n\t\n\t    bind: function bind() {\n\t      if (!this.el.__vue__) {\n\t        // keep-alive cache\n\t        this.keepAlive = this.params.keepAlive;\n\t        if (this.keepAlive) {\n\t          this.cache = {};\n\t        }\n\t        // check inline-template\n\t        if (this.params.inlineTemplate) {\n\t          // extract inline template as a DocumentFragment\n\t          this.inlineTemplate = extractContent(this.el, true);\n\t        }\n\t        // component resolution related state\n\t        this.pendingComponentCb = this.Component = null;\n\t        // transition related state\n\t        this.pendingRemovals = 0;\n\t        this.pendingRemovalCb = null;\n\t        // create a ref anchor\n\t        this.anchor = createAnchor('v-component');\n\t        replace(this.el, this.anchor);\n\t        // remove is attribute.\n\t        // this is removed during compilation, but because compilation is\n\t        // cached, when the component is used elsewhere this attribute\n\t        // will remain at link time.\n\t        this.el.removeAttribute('is');\n\t        // remove ref, same as above\n\t        if (this.descriptor.ref) {\n\t          this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\n\t        }\n\t        // if static, build right now.\n\t        if (this.literal) {\n\t          this.setComponent(this.expression);\n\t        }\n\t      } else {\n\t        'development' !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Public update, called by the watcher in the dynamic\n\t     * literal scenario, e.g. <component :is=\"view\">\n\t     */\n\t\n\t    update: function update(value) {\n\t      if (!this.literal) {\n\t        this.setComponent(value);\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Switch dynamic components. May resolve the component\n\t     * asynchronously, and perform transition based on\n\t     * specified transition mode. Accepts a few additional\n\t     * arguments specifically for vue-router.\n\t     *\n\t     * The callback is called when the full transition is\n\t     * finished.\n\t     *\n\t     * @param {String} value\n\t     * @param {Function} [cb]\n\t     */\n\t\n\t    setComponent: function setComponent(value, cb) {\n\t      this.invalidatePending();\n\t      if (!value) {\n\t        // just remove current\n\t        this.unbuild(true);\n\t        this.remove(this.childVM, cb);\n\t        this.childVM = null;\n\t      } else {\n\t        var self = this;\n\t        this.resolveComponent(value, function () {\n\t          self.mountComponent(cb);\n\t        });\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Resolve the component constructor to use when creating\n\t     * the child vm.\n\t     */\n\t\n\t    resolveComponent: function resolveComponent(id, cb) {\n\t      var self = this;\n\t      this.pendingComponentCb = cancellable(function (Component) {\n\t        self.ComponentName = Component.options.name || id;\n\t        self.Component = Component;\n\t        cb();\n\t      });\n\t      this.vm._resolveComponent(id, this.pendingComponentCb);\n\t    },\n\t\n\t    /**\n\t     * Create a new instance using the current constructor and\n\t     * replace the existing instance. This method doesn't care\n\t     * whether the new component and the old one are actually\n\t     * the same.\n\t     *\n\t     * @param {Function} [cb]\n\t     */\n\t\n\t    mountComponent: function mountComponent(cb) {\n\t      // actual mount\n\t      this.unbuild(true);\n\t      var self = this;\n\t      var activateHook = this.Component.options.activate;\n\t      var cached = this.getCached();\n\t      var newComponent = this.build();\n\t      if (activateHook && !cached) {\n\t        this.waitingFor = newComponent;\n\t        activateHook.call(newComponent, function () {\n\t          if (self.waitingFor !== newComponent) {\n\t            return;\n\t          }\n\t          self.waitingFor = null;\n\t          self.transition(newComponent, cb);\n\t        });\n\t      } else {\n\t        // update ref for kept-alive component\n\t        if (cached) {\n\t          newComponent._updateRef();\n\t        }\n\t        this.transition(newComponent, cb);\n\t      }\n\t    },\n\t\n\t    /**\n\t     * When the component changes or unbinds before an async\n\t     * constructor is resolved, we need to invalidate its\n\t     * pending callback.\n\t     */\n\t\n\t    invalidatePending: function invalidatePending() {\n\t      if (this.pendingComponentCb) {\n\t        this.pendingComponentCb.cancel();\n\t        this.pendingComponentCb = null;\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Instantiate/insert a new child vm.\n\t     * If keep alive and has cached instance, insert that\n\t     * instance; otherwise build a new one and cache it.\n\t     *\n\t     * @param {Object} [extraOptions]\n\t     * @return {Vue} - the created instance\n\t     */\n\t\n\t    build: function build(extraOptions) {\n\t      var cached = this.getCached();\n\t      if (cached) {\n\t        return cached;\n\t      }\n\t      if (this.Component) {\n\t        // default options\n\t        var options = {\n\t          name: this.ComponentName,\n\t          el: cloneNode(this.el),\n\t          template: this.inlineTemplate,\n\t          // make sure to add the child with correct parent\n\t          // if this is a transcluded component, its parent\n\t          // should be the transclusion host.\n\t          parent: this._host || this.vm,\n\t          // if no inline-template, then the compiled\n\t          // linker can be cached for better performance.\n\t          _linkerCachable: !this.inlineTemplate,\n\t          _ref: this.descriptor.ref,\n\t          _asComponent: true,\n\t          _isRouterView: this._isRouterView,\n\t          // if this is a transcluded component, context\n\t          // will be the common parent vm of this instance\n\t          // and its host.\n\t          _context: this.vm,\n\t          // if this is inside an inline v-for, the scope\n\t          // will be the intermediate scope created for this\n\t          // repeat fragment. this is used for linking props\n\t          // and container directives.\n\t          _scope: this._scope,\n\t          // pass in the owner fragment of this component.\n\t          // this is necessary so that the fragment can keep\n\t          // track of its contained components in order to\n\t          // call attach/detach hooks for them.\n\t          _frag: this._frag\n\t        };\n\t        // extra options\n\t        // in 1.0.0 this is used by vue-router only\n\t        /* istanbul ignore if */\n\t        if (extraOptions) {\n\t          extend(options, extraOptions);\n\t        }\n\t        var child = new this.Component(options);\n\t        if (this.keepAlive) {\n\t          this.cache[this.Component.cid] = child;\n\t        }\n\t        /* istanbul ignore if */\n\t        if ('development' !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {\n\t          warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template);\n\t        }\n\t        return child;\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Try to get a cached instance of the current component.\n\t     *\n\t     * @return {Vue|undefined}\n\t     */\n\t\n\t    getCached: function getCached() {\n\t      return this.keepAlive && this.cache[this.Component.cid];\n\t    },\n\t\n\t    /**\n\t     * Teardown the current child, but defers cleanup so\n\t     * that we can separate the destroy and removal steps.\n\t     *\n\t     * @param {Boolean} defer\n\t     */\n\t\n\t    unbuild: function unbuild(defer) {\n\t      if (this.waitingFor) {\n\t        this.waitingFor.$destroy();\n\t        this.waitingFor = null;\n\t      }\n\t      var child = this.childVM;\n\t      if (!child || this.keepAlive) {\n\t        if (child) {\n\t          // remove ref\n\t          child._updateRef(true);\n\t        }\n\t        return;\n\t      }\n\t      // the sole purpose of `deferCleanup` is so that we can\n\t      // \"deactivate\" the vm right now and perform DOM removal\n\t      // later.\n\t      child.$destroy(false, defer);\n\t    },\n\t\n\t    /**\n\t     * Remove current destroyed child and manually do\n\t     * the cleanup after removal.\n\t     *\n\t     * @param {Function} cb\n\t     */\n\t\n\t    remove: function remove(child, cb) {\n\t      var keepAlive = this.keepAlive;\n\t      if (child) {\n\t        // we may have a component switch when a previous\n\t        // component is still being transitioned out.\n\t        // we want to trigger only one lastest insertion cb\n\t        // when the existing transition finishes. (#1119)\n\t        this.pendingRemovals++;\n\t        this.pendingRemovalCb = cb;\n\t        var self = this;\n\t        child.$remove(function () {\n\t          self.pendingRemovals--;\n\t          if (!keepAlive) child._cleanup();\n\t          if (!self.pendingRemovals && self.pendingRemovalCb) {\n\t            self.pendingRemovalCb();\n\t            self.pendingRemovalCb = null;\n\t          }\n\t        });\n\t      } else if (cb) {\n\t        cb();\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Actually swap the components, depending on the\n\t     * transition mode. Defaults to simultaneous.\n\t     *\n\t     * @param {Vue} target\n\t     * @param {Function} [cb]\n\t     */\n\t\n\t    transition: function transition(target, cb) {\n\t      var self = this;\n\t      var current = this.childVM;\n\t      // for devtool inspection\n\t      if (true) {\n\t        if (current) current._inactive = true;\n\t        target._inactive = false;\n\t      }\n\t      this.childVM = target;\n\t      switch (self.params.transitionMode) {\n\t        case 'in-out':\n\t          target.$before(self.anchor, function () {\n\t            self.remove(current, cb);\n\t          });\n\t          break;\n\t        case 'out-in':\n\t          self.remove(current, function () {\n\t            target.$before(self.anchor, cb);\n\t          });\n\t          break;\n\t        default:\n\t          self.remove(current);\n\t          target.$before(self.anchor, cb);\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Unbind.\n\t     */\n\t\n\t    unbind: function unbind() {\n\t      this.invalidatePending();\n\t      // Do not defer cleanup when unbinding\n\t      this.unbuild();\n\t      // destroy all keep-alive cached instances\n\t      if (this.cache) {\n\t        for (var key in this.cache) {\n\t          this.cache[key].$destroy();\n\t        }\n\t        this.cache = null;\n\t      }\n\t    }\n\t  };\n\t\n\t  var vClass = {\n\t\n\t    deep: true,\n\t\n\t    update: function update(value) {\n\t      if (value && typeof value === 'string') {\n\t        this.handleObject(stringToObject(value));\n\t      } else if (isPlainObject(value)) {\n\t        this.handleObject(value);\n\t      } else if (isArray(value)) {\n\t        this.handleArray(value);\n\t      } else {\n\t        this.cleanup();\n\t      }\n\t    },\n\t\n\t    handleObject: function handleObject(value) {\n\t      this.cleanup(value);\n\t      var keys = this.prevKeys = Object.keys(value);\n\t      for (var i = 0, l = keys.length; i < l; i++) {\n\t        var key = keys[i];\n\t        if (value[key]) {\n\t          addClass(this.el, key);\n\t        } else {\n\t          removeClass(this.el, key);\n\t        }\n\t      }\n\t    },\n\t\n\t    handleArray: function handleArray(value) {\n\t      this.cleanup(value);\n\t      for (var i = 0, l = value.length; i < l; i++) {\n\t        if (value[i]) {\n\t          addClass(this.el, value[i]);\n\t        }\n\t      }\n\t      this.prevKeys = value.slice();\n\t    },\n\t\n\t    cleanup: function cleanup(value) {\n\t      if (this.prevKeys) {\n\t        var i = this.prevKeys.length;\n\t        while (i--) {\n\t          var key = this.prevKeys[i];\n\t          if (key && (!value || !contains$1(value, key))) {\n\t            removeClass(this.el, key);\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  function stringToObject(value) {\n\t    var res = {};\n\t    var keys = value.trim().split(/\\s+/);\n\t    var i = keys.length;\n\t    while (i--) {\n\t      res[keys[i]] = true;\n\t    }\n\t    return res;\n\t  }\n\t\n\t  function contains$1(value, key) {\n\t    return isArray(value) ? value.indexOf(key) > -1 : hasOwn(value, key);\n\t  }\n\t\n\t  var internalDirectives = {\n\t    style: style,\n\t    'class': vClass,\n\t    component: component,\n\t    prop: propDef,\n\t    transition: transition\n\t  };\n\t\n\t  var propBindingModes = config._propBindingModes;\n\t  var empty = {};\n\t\n\t  // regexes\n\t  var identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\n\t  var settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\n\t\n\t  /**\n\t   * Compile props on a root element and return\n\t   * a props link function.\n\t   *\n\t   * @param {Element|DocumentFragment} el\n\t   * @param {Array} propOptions\n\t   * @return {Function} propsLinkFn\n\t   */\n\t\n\t  function compileProps(el, propOptions) {\n\t    var props = [];\n\t    var names = Object.keys(propOptions);\n\t    var i = names.length;\n\t    var options, name, attr, value, path, parsed, prop;\n\t    while (i--) {\n\t      name = names[i];\n\t      options = propOptions[name] || empty;\n\t\n\t      if ('development' !== 'production' && name === '$data') {\n\t        warn('Do not use $data as prop.');\n\t        continue;\n\t      }\n\t\n\t      // props could contain dashes, which will be\n\t      // interpreted as minus calculations by the parser\n\t      // so we need to camelize the path here\n\t      path = camelize(name);\n\t      if (!identRE$1.test(path)) {\n\t        'development' !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.');\n\t        continue;\n\t      }\n\t\n\t      prop = {\n\t        name: name,\n\t        path: path,\n\t        options: options,\n\t        mode: propBindingModes.ONE_WAY,\n\t        raw: null\n\t      };\n\t\n\t      attr = hyphenate(name);\n\t      // first check dynamic version\n\t      if ((value = getBindAttr(el, attr)) === null) {\n\t        if ((value = getBindAttr(el, attr + '.sync')) !== null) {\n\t          prop.mode = propBindingModes.TWO_WAY;\n\t        } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\n\t          prop.mode = propBindingModes.ONE_TIME;\n\t        }\n\t      }\n\t      if (value !== null) {\n\t        // has dynamic binding!\n\t        prop.raw = value;\n\t        parsed = parseDirective(value);\n\t        value = parsed.expression;\n\t        prop.filters = parsed.filters;\n\t        // check binding type\n\t        if (isLiteral(value) && !parsed.filters) {\n\t          // for expressions containing literal numbers and\n\t          // booleans, there's no need to setup a prop binding,\n\t          // so we can optimize them as a one-time set.\n\t          prop.optimizedLiteral = true;\n\t        } else {\n\t          prop.dynamic = true;\n\t          // check non-settable path for two-way bindings\n\t          if ('development' !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {\n\t            prop.mode = propBindingModes.ONE_WAY;\n\t            warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value);\n\t          }\n\t        }\n\t        prop.parentPath = value;\n\t\n\t        // warn required two-way\n\t        if ('development' !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {\n\t          warn('Prop \"' + name + '\" expects a two-way binding type.');\n\t        }\n\t      } else if ((value = getAttr(el, attr)) !== null) {\n\t        // has literal binding!\n\t        prop.raw = value;\n\t      } else if (options.required) {\n\t        // warn missing required\n\t        'development' !== 'production' && warn('Missing required prop: ' + name);\n\t      }\n\t      // push prop\n\t      props.push(prop);\n\t    }\n\t    return makePropsLinkFn(props);\n\t  }\n\t\n\t  /**\n\t   * Build a function that applies props to a vm.\n\t   *\n\t   * @param {Array} props\n\t   * @return {Function} propsLinkFn\n\t   */\n\t\n\t  function makePropsLinkFn(props) {\n\t    return function propsLinkFn(vm, scope) {\n\t      // store resolved props info\n\t      vm._props = {};\n\t      var i = props.length;\n\t      var prop, path, options, value, raw;\n\t      while (i--) {\n\t        prop = props[i];\n\t        raw = prop.raw;\n\t        path = prop.path;\n\t        options = prop.options;\n\t        vm._props[path] = prop;\n\t        if (raw === null) {\n\t          // initialize absent prop\n\t          initProp(vm, prop, getDefault(vm, options));\n\t        } else if (prop.dynamic) {\n\t          // dynamic prop\n\t          if (vm._context) {\n\t            if (prop.mode === propBindingModes.ONE_TIME) {\n\t              // one time binding\n\t              value = (scope || vm._context).$get(prop.parentPath);\n\t              initProp(vm, prop, value);\n\t            } else {\n\t              // dynamic binding\n\t              vm._bindDir({\n\t                name: 'prop',\n\t                def: propDef,\n\t                prop: prop\n\t              }, null, null, scope); // el, host, scope\n\t            }\n\t          } else {\n\t              'development' !== 'production' && warn('Cannot bind dynamic prop on a root instance' + ' with no parent: ' + prop.name + '=\"' + raw + '\"');\n\t            }\n\t        } else if (prop.optimizedLiteral) {\n\t          // optimized literal, cast it and just set once\n\t          var stripped = stripQuotes(raw);\n\t          value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\n\t          initProp(vm, prop, value);\n\t        } else {\n\t          // string literal, but we need to cater for\n\t          // Boolean props with no value\n\t          value = options.type === Boolean && raw === '' ? true : raw;\n\t          initProp(vm, prop, value);\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Get the default value of a prop.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Object} options\n\t   * @return {*}\n\t   */\n\t\n\t  function getDefault(vm, options) {\n\t    // no default, return undefined\n\t    if (!hasOwn(options, 'default')) {\n\t      // absent boolean value defaults to false\n\t      return options.type === Boolean ? false : undefined;\n\t    }\n\t    var def = options['default'];\n\t    // warn against non-factory defaults for Object & Array\n\t    if (isObject(def)) {\n\t      'development' !== 'production' && warn('Object/Array as default prop values will be shared ' + 'across multiple instances. Use a factory function ' + 'to return the default value instead.');\n\t    }\n\t    // call factory function for non-Function types\n\t    return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\n\t  }\n\t\n\t  // special binding prefixes\n\t  var bindRE = /^v-bind:|^:/;\n\t  var onRE = /^v-on:|^@/;\n\t  var argRE = /:(.*)$/;\n\t  var modifierRE = /\\.[^\\.]+/g;\n\t  var transitionRE = /^(v-bind:|:)?transition$/;\n\t\n\t  // terminal directives\n\t  var terminalDirectives = ['for', 'if'];\n\t\n\t  // default directive priority\n\t  var DEFAULT_PRIORITY = 1000;\n\t\n\t  /**\n\t   * Compile a template and return a reusable composite link\n\t   * function, which recursively contains more link functions\n\t   * inside. This top level compile function would normally\n\t   * be called on instance root nodes, but can also be used\n\t   * for partial compilation if the partial argument is true.\n\t   *\n\t   * The returned composite link function, when called, will\n\t   * return an unlink function that tearsdown all directives\n\t   * created during the linking phase.\n\t   *\n\t   * @param {Element|DocumentFragment} el\n\t   * @param {Object} options\n\t   * @param {Boolean} partial\n\t   * @return {Function}\n\t   */\n\t\n\t  function compile(el, options, partial) {\n\t    // link function for the node itself.\n\t    var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\n\t    // link function for the childNodes\n\t    var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && el.tagName !== 'SCRIPT' && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\n\t\n\t    /**\n\t     * A composite linker function to be called on a already\n\t     * compiled piece of DOM, which instantiates all directive\n\t     * instances.\n\t     *\n\t     * @param {Vue} vm\n\t     * @param {Element|DocumentFragment} el\n\t     * @param {Vue} [host] - host vm of transcluded content\n\t     * @param {Object} [scope] - v-for scope\n\t     * @param {Fragment} [frag] - link context fragment\n\t     * @return {Function|undefined}\n\t     */\n\t\n\t    return function compositeLinkFn(vm, el, host, scope, frag) {\n\t      // cache childNodes before linking parent, fix #657\n\t      var childNodes = toArray(el.childNodes);\n\t      // link\n\t      var dirs = linkAndCapture(function compositeLinkCapturer() {\n\t        if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n\t        if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\n\t      }, vm);\n\t      return makeUnlinkFn(vm, dirs);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Apply a linker to a vm/element pair and capture the\n\t   * directives created during the process.\n\t   *\n\t   * @param {Function} linker\n\t   * @param {Vue} vm\n\t   */\n\t\n\t  function linkAndCapture(linker, vm) {\n\t    var originalDirCount = vm._directives.length;\n\t    linker();\n\t    var dirs = vm._directives.slice(originalDirCount);\n\t    dirs.sort(directiveComparator);\n\t    for (var i = 0, l = dirs.length; i < l; i++) {\n\t      dirs[i]._bind();\n\t    }\n\t    return dirs;\n\t  }\n\t\n\t  /**\n\t   * Directive priority sort comparator\n\t   *\n\t   * @param {Object} a\n\t   * @param {Object} b\n\t   */\n\t\n\t  function directiveComparator(a, b) {\n\t    a = a.descriptor.def.priority || DEFAULT_PRIORITY;\n\t    b = b.descriptor.def.priority || DEFAULT_PRIORITY;\n\t    return a > b ? -1 : a === b ? 0 : 1;\n\t  }\n\t\n\t  /**\n\t   * Linker functions return an unlink function that\n\t   * tearsdown all directives instances generated during\n\t   * the process.\n\t   *\n\t   * We create unlink functions with only the necessary\n\t   * information to avoid retaining additional closures.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Array} dirs\n\t   * @param {Vue} [context]\n\t   * @param {Array} [contextDirs]\n\t   * @return {Function}\n\t   */\n\t\n\t  function makeUnlinkFn(vm, dirs, context, contextDirs) {\n\t    function unlink(destroying) {\n\t      teardownDirs(vm, dirs, destroying);\n\t      if (context && contextDirs) {\n\t        teardownDirs(context, contextDirs);\n\t      }\n\t    }\n\t    // expose linked directives\n\t    unlink.dirs = dirs;\n\t    return unlink;\n\t  }\n\t\n\t  /**\n\t   * Teardown partial linked directives.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Array} dirs\n\t   * @param {Boolean} destroying\n\t   */\n\t\n\t  function teardownDirs(vm, dirs, destroying) {\n\t    var i = dirs.length;\n\t    while (i--) {\n\t      dirs[i]._teardown();\n\t      if (!destroying) {\n\t        vm._directives.$remove(dirs[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Compile link props on an instance.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element} el\n\t   * @param {Object} props\n\t   * @param {Object} [scope]\n\t   * @return {Function}\n\t   */\n\t\n\t  function compileAndLinkProps(vm, el, props, scope) {\n\t    var propsLinkFn = compileProps(el, props);\n\t    var propDirs = linkAndCapture(function () {\n\t      propsLinkFn(vm, scope);\n\t    }, vm);\n\t    return makeUnlinkFn(vm, propDirs);\n\t  }\n\t\n\t  /**\n\t   * Compile the root element of an instance.\n\t   *\n\t   * 1. attrs on context container (context scope)\n\t   * 2. attrs on the component template root node, if\n\t   *    replace:true (child scope)\n\t   *\n\t   * If this is a fragment instance, we only need to compile 1.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Element} el\n\t   * @param {Object} options\n\t   * @param {Object} contextOptions\n\t   * @return {Function}\n\t   */\n\t\n\t  function compileRoot(el, options, contextOptions) {\n\t    var containerAttrs = options._containerAttrs;\n\t    var replacerAttrs = options._replacerAttrs;\n\t    var contextLinkFn, replacerLinkFn;\n\t\n\t    // only need to compile other attributes for\n\t    // non-fragment instances\n\t    if (el.nodeType !== 11) {\n\t      // for components, container and replacer need to be\n\t      // compiled separately and linked in different scopes.\n\t      if (options._asComponent) {\n\t        // 2. container attributes\n\t        if (containerAttrs && contextOptions) {\n\t          contextLinkFn = compileDirectives(containerAttrs, contextOptions);\n\t        }\n\t        if (replacerAttrs) {\n\t          // 3. replacer attributes\n\t          replacerLinkFn = compileDirectives(replacerAttrs, options);\n\t        }\n\t      } else {\n\t        // non-component, just compile as a normal element.\n\t        replacerLinkFn = compileDirectives(el.attributes, options);\n\t      }\n\t    } else if ('development' !== 'production' && containerAttrs) {\n\t      // warn container directives for fragment instances\n\t      var names = containerAttrs.filter(function (attr) {\n\t        // allow vue-loader/vueify scoped css attributes\n\t        return attr.name.indexOf('_v-') < 0 &&\n\t        // allow event listeners\n\t        !onRE.test(attr.name) &&\n\t        // allow slots\n\t        attr.name !== 'slot';\n\t      }).map(function (attr) {\n\t        return '\"' + attr.name + '\"';\n\t      });\n\t      if (names.length) {\n\t        var plural = names.length > 1;\n\t        warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment_Instance');\n\t      }\n\t    }\n\t\n\t    options._containerAttrs = options._replacerAttrs = null;\n\t    return function rootLinkFn(vm, el, scope) {\n\t      // link context scope dirs\n\t      var context = vm._context;\n\t      var contextDirs;\n\t      if (context && contextLinkFn) {\n\t        contextDirs = linkAndCapture(function () {\n\t          contextLinkFn(context, el, null, scope);\n\t        }, context);\n\t      }\n\t\n\t      // link self\n\t      var selfDirs = linkAndCapture(function () {\n\t        if (replacerLinkFn) replacerLinkFn(vm, el);\n\t      }, vm);\n\t\n\t      // return the unlink function that tearsdown context\n\t      // container directives.\n\t      return makeUnlinkFn(vm, selfDirs, context, contextDirs);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Compile a node and return a nodeLinkFn based on the\n\t   * node type.\n\t   *\n\t   * @param {Node} node\n\t   * @param {Object} options\n\t   * @return {Function|null}\n\t   */\n\t\n\t  function compileNode(node, options) {\n\t    var type = node.nodeType;\n\t    if (type === 1 && node.tagName !== 'SCRIPT') {\n\t      return compileElement(node, options);\n\t    } else if (type === 3 && node.data.trim()) {\n\t      return compileTextNode(node, options);\n\t    } else {\n\t      return null;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Compile an element and return a nodeLinkFn.\n\t   *\n\t   * @param {Element} el\n\t   * @param {Object} options\n\t   * @return {Function|null}\n\t   */\n\t\n\t  function compileElement(el, options) {\n\t    // preprocess textareas.\n\t    // textarea treats its text content as the initial value.\n\t    // just bind it as an attr directive for value.\n\t    if (el.tagName === 'TEXTAREA') {\n\t      var tokens = parseText(el.value);\n\t      if (tokens) {\n\t        el.setAttribute(':value', tokensToExp(tokens));\n\t        el.value = '';\n\t      }\n\t    }\n\t    var linkFn;\n\t    var hasAttrs = el.hasAttributes();\n\t    // check terminal directives (for & if)\n\t    if (hasAttrs) {\n\t      linkFn = checkTerminalDirectives(el, options);\n\t    }\n\t    // check element directives\n\t    if (!linkFn) {\n\t      linkFn = checkElementDirectives(el, options);\n\t    }\n\t    // check component\n\t    if (!linkFn) {\n\t      linkFn = checkComponent(el, options);\n\t    }\n\t    // normal directives\n\t    if (!linkFn && hasAttrs) {\n\t      linkFn = compileDirectives(el.attributes, options);\n\t    }\n\t    return linkFn;\n\t  }\n\t\n\t  /**\n\t   * Compile a textNode and return a nodeLinkFn.\n\t   *\n\t   * @param {TextNode} node\n\t   * @param {Object} options\n\t   * @return {Function|null} textNodeLinkFn\n\t   */\n\t\n\t  function compileTextNode(node, options) {\n\t    // skip marked text nodes\n\t    if (node._skip) {\n\t      return removeText;\n\t    }\n\t\n\t    var tokens = parseText(node.wholeText);\n\t    if (!tokens) {\n\t      return null;\n\t    }\n\t\n\t    // mark adjacent text nodes as skipped,\n\t    // because we are using node.wholeText to compile\n\t    // all adjacent text nodes together. This fixes\n\t    // issues in IE where sometimes it splits up a single\n\t    // text node into multiple ones.\n\t    var next = node.nextSibling;\n\t    while (next && next.nodeType === 3) {\n\t      next._skip = true;\n\t      next = next.nextSibling;\n\t    }\n\t\n\t    var frag = document.createDocumentFragment();\n\t    var el, token;\n\t    for (var i = 0, l = tokens.length; i < l; i++) {\n\t      token = tokens[i];\n\t      el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\n\t      frag.appendChild(el);\n\t    }\n\t    return makeTextNodeLinkFn(tokens, frag, options);\n\t  }\n\t\n\t  /**\n\t   * Linker for an skipped text node.\n\t   *\n\t   * @param {Vue} vm\n\t   * @param {Text} node\n\t   */\n\t\n\t  function removeText(vm, node) {\n\t    remove(node);\n\t  }\n\t\n\t  /**\n\t   * Process a single text token.\n\t   *\n\t   * @param {Object} token\n\t   * @param {Object} options\n\t   * @return {Node}\n\t   */\n\t\n\t  function processTextToken(token, options) {\n\t    var el;\n\t    if (token.oneTime) {\n\t      el = document.createTextNode(token.value);\n\t    } else {\n\t      if (token.html) {\n\t        el = document.createComment('v-html');\n\t        setTokenType('html');\n\t      } else {\n\t        // IE will clean up empty textNodes during\n\t        // frag.cloneNode(true), so we have to give it\n\t        // something here...\n\t        el = document.createTextNode(' ');\n\t        setTokenType('text');\n\t      }\n\t    }\n\t    function setTokenType(type) {\n\t      if (token.descriptor) return;\n\t      var parsed = parseDirective(token.value);\n\t      token.descriptor = {\n\t        name: type,\n\t        def: publicDirectives[type],\n\t        expression: parsed.expression,\n\t        filters: parsed.filters\n\t      };\n\t    }\n\t    return el;\n\t  }\n\t\n\t  /**\n\t   * Build a function that processes a textNode.\n\t   *\n\t   * @param {Array<Object>} tokens\n\t   * @param {DocumentFragment} frag\n\t   */\n\t\n\t  function makeTextNodeLinkFn(tokens, frag) {\n\t    return function textNodeLinkFn(vm, el, host, scope) {\n\t      var fragClone = frag.cloneNode(true);\n\t      var childNodes = toArray(fragClone.childNodes);\n\t      var token, value, node;\n\t      for (var i = 0, l = tokens.length; i < l; i++) {\n\t        token = tokens[i];\n\t        value = token.value;\n\t        if (token.tag) {\n\t          node = childNodes[i];\n\t          if (token.oneTime) {\n\t            value = (scope || vm).$eval(value);\n\t            if (token.html) {\n\t              replace(node, parseTemplate(value, true));\n\t            } else {\n\t              node.data = value;\n\t            }\n\t          } else {\n\t            vm._bindDir(token.descriptor, node, host, scope);\n\t          }\n\t        }\n\t      }\n\t      replace(el, fragClone);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Compile a node list and return a childLinkFn.\n\t   *\n\t   * @param {NodeList} nodeList\n\t   * @param {Object} options\n\t   * @return {Function|undefined}\n\t   */\n\t\n\t  function compileNodeList(nodeList, options) {\n\t    var linkFns = [];\n\t    var nodeLinkFn, childLinkFn, node;\n\t    for (var i = 0, l = nodeList.length; i < l; i++) {\n\t      node = nodeList[i];\n\t      nodeLinkFn = compileNode(node, options);\n\t      childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\n\t      linkFns.push(nodeLinkFn, childLinkFn);\n\t    }\n\t    return linkFns.length ? makeChildLinkFn(linkFns) : null;\n\t  }\n\t\n\t  /**\n\t   * Make a child link function for a node's childNodes.\n\t   *\n\t   * @param {Array<Function>} linkFns\n\t   * @return {Function} childLinkFn\n\t   */\n\t\n\t  function makeChildLinkFn(linkFns) {\n\t    return function childLinkFn(vm, nodes, host, scope, frag) {\n\t      var node, nodeLinkFn, childrenLinkFn;\n\t      for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n\t        node = nodes[n];\n\t        nodeLinkFn = linkFns[i++];\n\t        childrenLinkFn = linkFns[i++];\n\t        // cache childNodes before linking parent, fix #657\n\t        var childNodes = toArray(node.childNodes);\n\t        if (nodeLinkFn) {\n\t          nodeLinkFn(vm, node, host, scope, frag);\n\t        }\n\t        if (childrenLinkFn) {\n\t          childrenLinkFn(vm, childNodes, host, scope, frag);\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Check for element directives (custom elements that should\n\t   * be resovled as terminal directives).\n\t   *\n\t   * @param {Element} el\n\t   * @param {Object} options\n\t   */\n\t\n\t  function checkElementDirectives(el, options) {\n\t    var tag = el.tagName.toLowerCase();\n\t    if (commonTagRE.test(tag)) return;\n\t    // special case: give named slot a higher priority\n\t    // than unnamed slots\n\t    if (tag === 'slot' && hasBindAttr(el, 'name')) {\n\t      tag = '_namedSlot';\n\t    }\n\t    var def = resolveAsset(options, 'elementDirectives', tag);\n\t    if (def) {\n\t      return makeTerminalNodeLinkFn(el, tag, '', options, def);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Check if an element is a component. If yes, return\n\t   * a component link function.\n\t   *\n\t   * @param {Element} el\n\t   * @param {Object} options\n\t   * @return {Function|undefined}\n\t   */\n\t\n\t  function checkComponent(el, options) {\n\t    var component = checkComponentAttr(el, options);\n\t    if (component) {\n\t      var ref = findRef(el);\n\t      var descriptor = {\n\t        name: 'component',\n\t        ref: ref,\n\t        expression: component.id,\n\t        def: internalDirectives.component,\n\t        modifiers: {\n\t          literal: !component.dynamic\n\t        }\n\t      };\n\t      var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\n\t        if (ref) {\n\t          defineReactive((scope || vm).$refs, ref, null);\n\t        }\n\t        vm._bindDir(descriptor, el, host, scope, frag);\n\t      };\n\t      componentLinkFn.terminal = true;\n\t      return componentLinkFn;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Check an element for terminal directives in fixed order.\n\t   * If it finds one, return a terminal link function.\n\t   *\n\t   * @param {Element} el\n\t   * @param {Object} options\n\t   * @return {Function} terminalLinkFn\n\t   */\n\t\n\t  function checkTerminalDirectives(el, options) {\n\t    // skip v-pre\n\t    if (getAttr(el, 'v-pre') !== null) {\n\t      return skip;\n\t    }\n\t    // skip v-else block, but only if following v-if\n\t    if (el.hasAttribute('v-else')) {\n\t      var prev = el.previousElementSibling;\n\t      if (prev && prev.hasAttribute('v-if')) {\n\t        return skip;\n\t      }\n\t    }\n\t    var value, dirName;\n\t    for (var i = 0, l = terminalDirectives.length; i < l; i++) {\n\t      dirName = terminalDirectives[i];\n\t      value = el.getAttribute('v-' + dirName);\n\t      if (value != null) {\n\t        return makeTerminalNodeLinkFn(el, dirName, value, options);\n\t      }\n\t    }\n\t  }\n\t\n\t  function skip() {}\n\t  skip.terminal = true;\n\t\n\t  /**\n\t   * Build a node link function for a terminal directive.\n\t   * A terminal link function terminates the current\n\t   * compilation recursion and handles compilation of the\n\t   * subtree in the directive.\n\t   *\n\t   * @param {Element} el\n\t   * @param {String} dirName\n\t   * @param {String} value\n\t   * @param {Object} options\n\t   * @param {Object} [def]\n\t   * @return {Function} terminalLinkFn\n\t   */\n\t\n\t  function makeTerminalNodeLinkFn(el, dirName, value, options, def) {\n\t    var parsed = parseDirective(value);\n\t    var descriptor = {\n\t      name: dirName,\n\t      expression: parsed.expression,\n\t      filters: parsed.filters,\n\t      raw: value,\n\t      // either an element directive, or if/for\n\t      def: def || publicDirectives[dirName]\n\t    };\n\t    // check ref for v-for and router-view\n\t    if (dirName === 'for' || dirName === 'router-view') {\n\t      descriptor.ref = findRef(el);\n\t    }\n\t    var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n\t      if (descriptor.ref) {\n\t        defineReactive((scope || vm).$refs, descriptor.ref, null);\n\t      }\n\t      vm._bindDir(descriptor, el, host, scope, frag);\n\t    };\n\t    fn.terminal = true;\n\t    return fn;\n\t  }\n\t\n\t  /**\n\t   * Compile the directives on an element and return a linker.\n\t   *\n\t   * @param {Array|NamedNodeMap} attrs\n\t   * @param {Object} options\n\t   * @return {Function}\n\t   */\n\t\n\t  function compileDirectives(attrs, options) {\n\t    var i = attrs.length;\n\t    var dirs = [];\n\t    var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens;\n\t    while (i--) {\n\t      attr = attrs[i];\n\t      name = rawName = attr.name;\n\t      value = rawValue = attr.value;\n\t      tokens = parseText(value);\n\t      // reset arg\n\t      arg = null;\n\t      // check modifiers\n\t      modifiers = parseModifiers(name);\n\t      name = name.replace(modifierRE, '');\n\t\n\t      // attribute interpolations\n\t      if (tokens) {\n\t        value = tokensToExp(tokens);\n\t        arg = name;\n\t        pushDir('bind', publicDirectives.bind, tokens);\n\t        // warn against mixing mustaches with v-bind\n\t        if (true) {\n\t          if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\n\t            return attr.name === ':class' || attr.name === 'v-bind:class';\n\t          })) {\n\t            warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.');\n\t          }\n\t        }\n\t      } else\n\t\n\t        // special attribute: transition\n\t        if (transitionRE.test(name)) {\n\t          modifiers.literal = !bindRE.test(name);\n\t          pushDir('transition', internalDirectives.transition);\n\t        } else\n\t\n\t          // event handlers\n\t          if (onRE.test(name)) {\n\t            arg = name.replace(onRE, '');\n\t            pushDir('on', publicDirectives.on);\n\t          } else\n\t\n\t            // attribute bindings\n\t            if (bindRE.test(name)) {\n\t              dirName = name.replace(bindRE, '');\n\t              if (dirName === 'style' || dirName === 'class') {\n\t                pushDir(dirName, internalDirectives[dirName]);\n\t              } else {\n\t                arg = dirName;\n\t                pushDir('bind', publicDirectives.bind);\n\t              }\n\t            } else\n\t\n\t              // normal directives\n\t              if (name.indexOf('v-') === 0) {\n\t                // check arg\n\t                arg = (arg = name.match(argRE)) && arg[1];\n\t                if (arg) {\n\t                  name = name.replace(argRE, '');\n\t                }\n\t                // extract directive name\n\t                dirName = name.slice(2);\n\t\n\t                // skip v-else (when used with v-show)\n\t                if (dirName === 'else') {\n\t                  continue;\n\t                }\n\t\n\t                dirDef = resolveAsset(options, 'directives', dirName);\n\t\n\t                if (true) {\n\t                  assertAsset(dirDef, 'directive', dirName);\n\t                }\n\t\n\t                if (dirDef) {\n\t                  pushDir(dirName, dirDef);\n\t                }\n\t              }\n\t    }\n\t\n\t    /**\n\t     * Push a directive.\n\t     *\n\t     * @param {String} dirName\n\t     * @param {Object|Function} def\n\t     * @param {Array} [interpTokens]\n\t     */\n\t\n\t    function pushDir(dirName, def, interpTokens) {\n\t      var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\n\t      var parsed = !hasOneTimeToken && parseDirective(value);\n\t      dirs.push({\n\t        name: dirName,\n\t        attr: rawName,\n\t        raw: rawValue,\n\t        def: def,\n\t        arg: arg,\n\t        modifiers: modifiers,\n\t        // conversion from interpolation strings with one-time token\n\t        // to expression is differed until directive bind time so that we\n\t        // have access to the actual vm context for one-time bindings.\n\t        expression: parsed && parsed.expression,\n\t        filters: parsed && parsed.filters,\n\t        interp: interpTokens,\n\t        hasOneTime: hasOneTimeToken\n\t      });\n\t    }\n\t\n\t    if (dirs.length) {\n\t      return makeNodeLinkFn(dirs);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Parse modifiers from directive attribute name.\n\t   *\n\t   * @param {String} name\n\t   * @return {Object}\n\t   */\n\t\n\t  function parseModifiers(name) {\n\t    var res = Object.create(null);\n\t    var match = name.match(modifierRE);\n\t    if (match) {\n\t      var i = match.length;\n\t      while (i--) {\n\t        res[match[i].slice(1)] = true;\n\t      }\n\t    }\n\t    return res;\n\t  }\n\t\n\t  /**\n\t   * Build a link function for all directives on a single node.\n\t   *\n\t   * @param {Array} directives\n\t   * @return {Function} directivesLinkFn\n\t   */\n\t\n\t  function makeNodeLinkFn(directives) {\n\t    return function nodeLinkFn(vm, el, host, scope, frag) {\n\t      // reverse apply because it's sorted low to high\n\t      var i = directives.length;\n\t      while (i--) {\n\t        vm._bindDir(directives[i], el, host, scope, frag);\n\t      }\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Check if an interpolation string contains one-time tokens.\n\t   *\n\t   * @param {Array} tokens\n\t   * @return {Boolean}\n\t   */\n\t\n\t  function hasOneTime(tokens) {\n\t    var i = tokens.length;\n\t    while (i--) {\n\t      if (tokens[i].oneTime) return true;\n\t    }\n\t  }\n\t\n\t  var specialCharRE = /[^\\w\\-:\\.]/;\n\t\n\t  /**\n\t   * Process an element or a DocumentFragment based on a\n\t   * instance option object. This allows us to transclude\n\t   * a template node/fragment before the instance is created,\n\t   * so the processed fragment can then be cloned and reused\n\t   * in v-for.\n\t   *\n\t   * @param {Element} el\n\t   * @param {Object} options\n\t   * @return {Element|DocumentFragment}\n\t   */\n\t\n\t  function transclude(el, options) {\n\t    // extract container attributes to pass them down\n\t    // to compiler, because they need to be compiled in\n\t    // parent scope. we are mutating the options object here\n\t    // assuming the same object will be used for compile\n\t    // right after this.\n\t    if (options) {\n\t      options._containerAttrs = extractAttrs(el);\n\t    }\n\t    // for template tags, what we want is its content as\n\t    // a documentFragment (for fragment instances)\n\t    if (isTemplate(el)) {\n\t      el = parseTemplate(el);\n\t    }\n\t    if (options) {\n\t      if (options._asComponent && !options.template) {\n\t        options.template = '<slot></slot>';\n\t      }\n\t      if (options.template) {\n\t        options._content = extractContent(el);\n\t        el = transcludeTemplate(el, options);\n\t      }\n\t    }\n\t    if (el instanceof DocumentFragment) {\n\t      // anchors for fragment instance\n\t      // passing in `persist: true` to avoid them being\n\t      // discarded by IE during template cloning\n\t      prepend(createAnchor('v-start', true), el);\n\t      el.appendChild(createAnchor('v-end', true));\n\t    }\n\t    return el;\n\t  }\n\t\n\t  /**\n\t   * Process the template option.\n\t   * If the replace option is true this will swap the $el.\n\t   *\n\t   * @param {Element} el\n\t   * @param {Object} options\n\t   * @return {Element|DocumentFragment}\n\t   */\n\t\n\t  function transcludeTemplate(el, options) {\n\t    var template = options.template;\n\t    var frag = parseTemplate(template, true);\n\t    if (frag) {\n\t      var replacer = frag.firstChild;\n\t      var tag = replacer.tagName && replacer.tagName.toLowerCase();\n\t      if (options.replace) {\n\t        /* istanbul ignore if */\n\t        if (el === document.body) {\n\t          'development' !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\n\t        }\n\t        // there are many cases where the instance must\n\t        // become a fragment instance: basically anything that\n\t        // can create more than 1 root nodes.\n\t        if (\n\t        // multi-children template\n\t        frag.childNodes.length > 1 ||\n\t        // non-element template\n\t        replacer.nodeType !== 1 ||\n\t        // single nested component\n\t        tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\n\t        // element directive\n\t        resolveAsset(options, 'elementDirectives', tag) ||\n\t        // for block\n\t        replacer.hasAttribute('v-for') ||\n\t        // if block\n\t        replacer.hasAttribute('v-if')) {\n\t          return frag;\n\t        } else {\n\t          options._replacerAttrs = extractAttrs(replacer);\n\t          mergeAttrs(el, replacer);\n\t          return replacer;\n\t        }\n\t      } else {\n\t        el.appendChild(frag);\n\t        return el;\n\t      }\n\t    } else {\n\t      'development' !== 'production' && warn('Invalid template option: ' + template);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Helper to extract a component container's attributes\n\t   * into a plain object array.\n\t   *\n\t   * @param {Element} el\n\t   * @return {Array}\n\t   */\n\t\n\t  function extractAttrs(el) {\n\t    if (el.nodeType === 1 && el.hasAttributes()) {\n\t      return toArray(el.attributes);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Merge the attributes of two elements, and make sure\n\t   * the class names are merged properly.\n\t   *\n\t   * @param {Element} from\n\t   * @param {Element} to\n\t   */\n\t\n\t  function mergeAttrs(from, to) {\n\t    var attrs = from.attributes;\n\t    var i = attrs.length;\n\t    var name, value;\n\t    while (i--) {\n\t      name = attrs[i].name;\n\t      value = attrs[i].value;\n\t      if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n\t        to.setAttribute(name, value);\n\t      } else if (name === 'class' && !parseText(value)) {\n\t        value.split(/\\s+/).forEach(function (cls) {\n\t          addClass(to, cls);\n\t        });\n\t      }\n\t    }\n\t  }\n\t\n\t  var compiler = Object.freeze({\n\t  \tcompile: compile,\n\t  \tcompileAndLinkProps: compileAndLinkProps,\n\t  \tcompileRoot: compileRoot,\n\t  \tterminalDirectives: terminalDirectives,\n\t  \ttransclude: transclude\n\t  });\n\t\n\t  function stateMixin (Vue) {\n\t\n\t    /**\n\t     * Accessor for `$data` property, since setting $data\n\t     * requires observing the new object and updating\n\t     * proxied properties.\n\t     */\n\t\n\t    Object.defineProperty(Vue.prototype, '$data', {\n\t      get: function get() {\n\t        return this._data;\n\t      },\n\t      set: function set(newData) {\n\t        if (newData !== this._data) {\n\t          this._setData(newData);\n\t        }\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Setup the scope of an instance, which contains:\n\t     * - observed data\n\t     * - computed properties\n\t     * - user methods\n\t     * - meta properties\n\t     */\n\t\n\t    Vue.prototype._initState = function () {\n\t      this._initProps();\n\t      this._initMeta();\n\t      this._initMethods();\n\t      this._initData();\n\t      this._initComputed();\n\t    };\n\t\n\t    /**\n\t     * Initialize props.\n\t     */\n\t\n\t    Vue.prototype._initProps = function () {\n\t      var options = this.$options;\n\t      var el = options.el;\n\t      var props = options.props;\n\t      if (props && !el) {\n\t        'development' !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.');\n\t      }\n\t      // make sure to convert string selectors into element now\n\t      el = options.el = query(el);\n\t      this._propsUnlinkFn = el && el.nodeType === 1 && props\n\t      // props must be linked in proper scope if inside v-for\n\t      ? compileAndLinkProps(this, el, props, this._scope) : null;\n\t    };\n\t\n\t    /**\n\t     * Initialize the data.\n\t     */\n\t\n\t    Vue.prototype._initData = function () {\n\t      var propsData = this._data;\n\t      var optionsDataFn = this.$options.data;\n\t      var optionsData = optionsDataFn && optionsDataFn();\n\t      if (optionsData) {\n\t        this._data = optionsData;\n\t        for (var prop in propsData) {\n\t          if ('development' !== 'production' && hasOwn(optionsData, prop)) {\n\t            warn('Data field \"' + prop + '\" is already defined ' + 'as a prop. Use prop default value instead.');\n\t          }\n\t          if (this._props[prop].raw !== null || !hasOwn(optionsData, prop)) {\n\t            set(optionsData, prop, propsData[prop]);\n\t          }\n\t        }\n\t      }\n\t      var data = this._data;\n\t      // proxy data on instance\n\t      var keys = Object.keys(data);\n\t      var i, key;\n\t      i = keys.length;\n\t      while (i--) {\n\t        key = keys[i];\n\t        this._proxy(key);\n\t      }\n\t      // observe data\n\t      observe(data, this);\n\t    };\n\t\n\t    /**\n\t     * Swap the instance's $data. Called in $data's setter.\n\t     *\n\t     * @param {Object} newData\n\t     */\n\t\n\t    Vue.prototype._setData = function (newData) {\n\t      newData = newData || {};\n\t      var oldData = this._data;\n\t      this._data = newData;\n\t      var keys, key, i;\n\t      // unproxy keys not present in new data\n\t      keys = Object.keys(oldData);\n\t      i = keys.length;\n\t      while (i--) {\n\t        key = keys[i];\n\t        if (!(key in newData)) {\n\t          this._unproxy(key);\n\t        }\n\t      }\n\t      // proxy keys not already proxied,\n\t      // and trigger change for changed values\n\t      keys = Object.keys(newData);\n\t      i = keys.length;\n\t      while (i--) {\n\t        key = keys[i];\n\t        if (!hasOwn(this, key)) {\n\t          // new property\n\t          this._proxy(key);\n\t        }\n\t      }\n\t      oldData.__ob__.removeVm(this);\n\t      observe(newData, this);\n\t      this._digest();\n\t    };\n\t\n\t    /**\n\t     * Proxy a property, so that\n\t     * vm.prop === vm._data.prop\n\t     *\n\t     * @param {String} key\n\t     */\n\t\n\t    Vue.prototype._proxy = function (key) {\n\t      if (!isReserved(key)) {\n\t        // need to store ref to self here\n\t        // because these getter/setters might\n\t        // be called by child scopes via\n\t        // prototype inheritance.\n\t        var self = this;\n\t        Object.defineProperty(self, key, {\n\t          configurable: true,\n\t          enumerable: true,\n\t          get: function proxyGetter() {\n\t            return self._data[key];\n\t          },\n\t          set: function proxySetter(val) {\n\t            self._data[key] = val;\n\t          }\n\t        });\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Unproxy a property.\n\t     *\n\t     * @param {String} key\n\t     */\n\t\n\t    Vue.prototype._unproxy = function (key) {\n\t      if (!isReserved(key)) {\n\t        delete this[key];\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Force update on every watcher in scope.\n\t     */\n\t\n\t    Vue.prototype._digest = function () {\n\t      for (var i = 0, l = this._watchers.length; i < l; i++) {\n\t        this._watchers[i].update(true); // shallow updates\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Setup computed properties. They are essentially\n\t     * special getter/setters\n\t     */\n\t\n\t    function noop() {}\n\t    Vue.prototype._initComputed = function () {\n\t      var computed = this.$options.computed;\n\t      if (computed) {\n\t        for (var key in computed) {\n\t          var userDef = computed[key];\n\t          var def = {\n\t            enumerable: true,\n\t            configurable: true\n\t          };\n\t          if (typeof userDef === 'function') {\n\t            def.get = makeComputedGetter(userDef, this);\n\t            def.set = noop;\n\t          } else {\n\t            def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind$1(userDef.get, this) : noop;\n\t            def.set = userDef.set ? bind$1(userDef.set, this) : noop;\n\t          }\n\t          Object.defineProperty(this, key, def);\n\t        }\n\t      }\n\t    };\n\t\n\t    function makeComputedGetter(getter, owner) {\n\t      var watcher = new Watcher(owner, getter, null, {\n\t        lazy: true\n\t      });\n\t      return function computedGetter() {\n\t        if (watcher.dirty) {\n\t          watcher.evaluate();\n\t        }\n\t        if (Dep.target) {\n\t          watcher.depend();\n\t        }\n\t        return watcher.value;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Setup instance methods. Methods must be bound to the\n\t     * instance since they might be passed down as a prop to\n\t     * child components.\n\t     */\n\t\n\t    Vue.prototype._initMethods = function () {\n\t      var methods = this.$options.methods;\n\t      if (methods) {\n\t        for (var key in methods) {\n\t          this[key] = bind$1(methods[key], this);\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Initialize meta information like $index, $key & $value.\n\t     */\n\t\n\t    Vue.prototype._initMeta = function () {\n\t      var metas = this.$options._meta;\n\t      if (metas) {\n\t        for (var key in metas) {\n\t          defineReactive(this, key, metas[key]);\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  var eventRE = /^v-on:|^@/;\n\t\n\t  function eventsMixin (Vue) {\n\t\n\t    /**\n\t     * Setup the instance's option events & watchers.\n\t     * If the value is a string, we pull it from the\n\t     * instance's methods by name.\n\t     */\n\t\n\t    Vue.prototype._initEvents = function () {\n\t      var options = this.$options;\n\t      if (options._asComponent) {\n\t        registerComponentEvents(this, options.el);\n\t      }\n\t      registerCallbacks(this, '$on', options.events);\n\t      registerCallbacks(this, '$watch', options.watch);\n\t    };\n\t\n\t    /**\n\t     * Register v-on events on a child component\n\t     *\n\t     * @param {Vue} vm\n\t     * @param {Element} el\n\t     */\n\t\n\t    function registerComponentEvents(vm, el) {\n\t      var attrs = el.attributes;\n\t      var name, handler;\n\t      for (var i = 0, l = attrs.length; i < l; i++) {\n\t        name = attrs[i].name;\n\t        if (eventRE.test(name)) {\n\t          name = name.replace(eventRE, '');\n\t          handler = (vm._scope || vm._context).$eval(attrs[i].value, true);\n\t          handler._fromParent = true;\n\t          vm.$on(name.replace(eventRE), handler);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Register callbacks for option events and watchers.\n\t     *\n\t     * @param {Vue} vm\n\t     * @param {String} action\n\t     * @param {Object} hash\n\t     */\n\t\n\t    function registerCallbacks(vm, action, hash) {\n\t      if (!hash) return;\n\t      var handlers, key, i, j;\n\t      for (key in hash) {\n\t        handlers = hash[key];\n\t        if (isArray(handlers)) {\n\t          for (i = 0, j = handlers.length; i < j; i++) {\n\t            register(vm, action, key, handlers[i]);\n\t          }\n\t        } else {\n\t          register(vm, action, key, handlers);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Helper to register an event/watch callback.\n\t     *\n\t     * @param {Vue} vm\n\t     * @param {String} action\n\t     * @param {String} key\n\t     * @param {Function|String|Object} handler\n\t     * @param {Object} [options]\n\t     */\n\t\n\t    function register(vm, action, key, handler, options) {\n\t      var type = typeof handler;\n\t      if (type === 'function') {\n\t        vm[action](key, handler, options);\n\t      } else if (type === 'string') {\n\t        var methods = vm.$options.methods;\n\t        var method = methods && methods[handler];\n\t        if (method) {\n\t          vm[action](key, method, options);\n\t        } else {\n\t          'development' !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".');\n\t        }\n\t      } else if (handler && type === 'object') {\n\t        register(vm, action, key, handler.handler, handler);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Setup recursive attached/detached calls\n\t     */\n\t\n\t    Vue.prototype._initDOMHooks = function () {\n\t      this.$on('hook:attached', onAttached);\n\t      this.$on('hook:detached', onDetached);\n\t    };\n\t\n\t    /**\n\t     * Callback to recursively call attached hook on children\n\t     */\n\t\n\t    function onAttached() {\n\t      if (!this._isAttached) {\n\t        this._isAttached = true;\n\t        this.$children.forEach(callAttach);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Iterator to call attached hook\n\t     *\n\t     * @param {Vue} child\n\t     */\n\t\n\t    function callAttach(child) {\n\t      if (!child._isAttached && inDoc(child.$el)) {\n\t        child._callHook('attached');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Callback to recursively call detached hook on children\n\t     */\n\t\n\t    function onDetached() {\n\t      if (this._isAttached) {\n\t        this._isAttached = false;\n\t        this.$children.forEach(callDetach);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Iterator to call detached hook\n\t     *\n\t     * @param {Vue} child\n\t     */\n\t\n\t    function callDetach(child) {\n\t      if (child._isAttached && !inDoc(child.$el)) {\n\t        child._callHook('detached');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Trigger all handlers for a hook\n\t     *\n\t     * @param {String} hook\n\t     */\n\t\n\t    Vue.prototype._callHook = function (hook) {\n\t      this.$emit('pre-hook:' + hook);\n\t      var handlers = this.$options[hook];\n\t      if (handlers) {\n\t        for (var i = 0, j = handlers.length; i < j; i++) {\n\t          handlers[i].call(this);\n\t        }\n\t      }\n\t      this.$emit('hook:' + hook);\n\t    };\n\t  }\n\t\n\t  function noop() {}\n\t\n\t  /**\n\t   * A directive links a DOM element with a piece of data,\n\t   * which is the result of evaluating an expression.\n\t   * It registers a watcher with the expression and calls\n\t   * the DOM update function when a change is triggered.\n\t   *\n\t   * @param {String} name\n\t   * @param {Node} el\n\t   * @param {Vue} vm\n\t   * @param {Object} descriptor\n\t   *                 - {String} name\n\t   *                 - {Object} def\n\t   *                 - {String} expression\n\t   *                 - {Array<Object>} [filters]\n\t   *                 - {Boolean} literal\n\t   *                 - {String} attr\n\t   *                 - {String} raw\n\t   * @param {Object} def - directive definition object\n\t   * @param {Vue} [host] - transclusion host component\n\t   * @param {Object} [scope] - v-for scope\n\t   * @param {Fragment} [frag] - owner fragment\n\t   * @constructor\n\t   */\n\t  function Directive(descriptor, vm, el, host, scope, frag) {\n\t    this.vm = vm;\n\t    this.el = el;\n\t    // copy descriptor properties\n\t    this.descriptor = descriptor;\n\t    this.name = descriptor.name;\n\t    this.expression = descriptor.expression;\n\t    this.arg = descriptor.arg;\n\t    this.modifiers = descriptor.modifiers;\n\t    this.filters = descriptor.filters;\n\t    this.literal = this.modifiers && this.modifiers.literal;\n\t    // private\n\t    this._locked = false;\n\t    this._bound = false;\n\t    this._listeners = null;\n\t    // link context\n\t    this._host = host;\n\t    this._scope = scope;\n\t    this._frag = frag;\n\t    // store directives on node in dev mode\n\t    if ('development' !== 'production' && this.el) {\n\t      this.el._vue_directives = this.el._vue_directives || [];\n\t      this.el._vue_directives.push(this);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Initialize the directive, mixin definition properties,\n\t   * setup the watcher, call definition bind() and update()\n\t   * if present.\n\t   *\n\t   * @param {Object} def\n\t   */\n\t\n\t  Directive.prototype._bind = function () {\n\t    var name = this.name;\n\t    var descriptor = this.descriptor;\n\t\n\t    // remove attribute\n\t    if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\n\t      var attr = descriptor.attr || 'v-' + name;\n\t      this.el.removeAttribute(attr);\n\t    }\n\t\n\t    // copy def properties\n\t    var def = descriptor.def;\n\t    if (typeof def === 'function') {\n\t      this.update = def;\n\t    } else {\n\t      extend(this, def);\n\t    }\n\t\n\t    // setup directive params\n\t    this._setupParams();\n\t\n\t    // initial bind\n\t    if (this.bind) {\n\t      this.bind();\n\t    }\n\t    this._bound = true;\n\t\n\t    if (this.literal) {\n\t      this.update && this.update(descriptor.raw);\n\t    } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\n\t      // wrapped updater for context\n\t      var dir = this;\n\t      if (this.update) {\n\t        this._update = function (val, oldVal) {\n\t          if (!dir._locked) {\n\t            dir.update(val, oldVal);\n\t          }\n\t        };\n\t      } else {\n\t        this._update = noop;\n\t      }\n\t      var preProcess = this._preProcess ? bind$1(this._preProcess, this) : null;\n\t      var postProcess = this._postProcess ? bind$1(this._postProcess, this) : null;\n\t      var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n\t      {\n\t        filters: this.filters,\n\t        twoWay: this.twoWay,\n\t        deep: this.deep,\n\t        preProcess: preProcess,\n\t        postProcess: postProcess,\n\t        scope: this._scope\n\t      });\n\t      // v-model with inital inline value need to sync back to\n\t      // model instead of update to DOM on init. They would\n\t      // set the afterBind hook to indicate that.\n\t      if (this.afterBind) {\n\t        this.afterBind();\n\t      } else if (this.update) {\n\t        this.update(watcher.value);\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Setup all param attributes, e.g. track-by,\n\t   * transition-mode, etc...\n\t   */\n\t\n\t  Directive.prototype._setupParams = function () {\n\t    if (!this.params) {\n\t      return;\n\t    }\n\t    var params = this.params;\n\t    // swap the params array with a fresh object.\n\t    this.params = Object.create(null);\n\t    var i = params.length;\n\t    var key, val, mappedKey;\n\t    while (i--) {\n\t      key = params[i];\n\t      mappedKey = camelize(key);\n\t      val = getBindAttr(this.el, key);\n\t      if (val != null) {\n\t        // dynamic\n\t        this._setupParamWatcher(mappedKey, val);\n\t      } else {\n\t        // static\n\t        val = getAttr(this.el, key);\n\t        if (val != null) {\n\t          this.params[mappedKey] = val === '' ? true : val;\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Setup a watcher for a dynamic param.\n\t   *\n\t   * @param {String} key\n\t   * @param {String} expression\n\t   */\n\t\n\t  Directive.prototype._setupParamWatcher = function (key, expression) {\n\t    var self = this;\n\t    var called = false;\n\t    var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n\t      self.params[key] = val;\n\t      // since we are in immediate mode,\n\t      // only call the param change callbacks if this is not the first update.\n\t      if (called) {\n\t        var cb = self.paramWatchers && self.paramWatchers[key];\n\t        if (cb) {\n\t          cb.call(self, val, oldVal);\n\t        }\n\t      } else {\n\t        called = true;\n\t      }\n\t    }, {\n\t      immediate: true,\n\t      user: false\n\t    });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\n\t  };\n\t\n\t  /**\n\t   * Check if the directive is a function caller\n\t   * and if the expression is a callable one. If both true,\n\t   * we wrap up the expression and use it as the event\n\t   * handler.\n\t   *\n\t   * e.g. on-click=\"a++\"\n\t   *\n\t   * @return {Boolean}\n\t   */\n\t\n\t  Directive.prototype._checkStatement = function () {\n\t    var expression = this.expression;\n\t    if (expression && this.acceptStatement && !isSimplePath(expression)) {\n\t      var fn = parseExpression(expression).get;\n\t      var scope = this._scope || this.vm;\n\t      var handler = function handler(e) {\n\t        scope.$event = e;\n\t        fn.call(scope, scope);\n\t        scope.$event = null;\n\t      };\n\t      if (this.filters) {\n\t        handler = scope._applyFilters(handler, null, this.filters);\n\t      }\n\t      this.update(handler);\n\t      return true;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Set the corresponding value with the setter.\n\t   * This should only be used in two-way directives\n\t   * e.g. v-model.\n\t   *\n\t   * @param {*} value\n\t   * @public\n\t   */\n\t\n\t  Directive.prototype.set = function (value) {\n\t    /* istanbul ignore else */\n\t    if (this.twoWay) {\n\t      this._withLock(function () {\n\t        this._watcher.set(value);\n\t      });\n\t    } else if (true) {\n\t      warn('Directive.set() can only be used inside twoWay' + 'directives.');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Execute a function while preventing that function from\n\t   * triggering updates on this directive instance.\n\t   *\n\t   * @param {Function} fn\n\t   */\n\t\n\t  Directive.prototype._withLock = function (fn) {\n\t    var self = this;\n\t    self._locked = true;\n\t    fn.call(self);\n\t    nextTick(function () {\n\t      self._locked = false;\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Convenience method that attaches a DOM event listener\n\t   * to the directive element and autometically tears it down\n\t   * during unbind.\n\t   *\n\t   * @param {String} event\n\t   * @param {Function} handler\n\t   */\n\t\n\t  Directive.prototype.on = function (event, handler) {\n\t    on$1(this.el, event, handler);(this._listeners || (this._listeners = [])).push([event, handler]);\n\t  };\n\t\n\t  /**\n\t   * Teardown the watcher and call unbind.\n\t   */\n\t\n\t  Directive.prototype._teardown = function () {\n\t    if (this._bound) {\n\t      this._bound = false;\n\t      if (this.unbind) {\n\t        this.unbind();\n\t      }\n\t      if (this._watcher) {\n\t        this._watcher.teardown();\n\t      }\n\t      var listeners = this._listeners;\n\t      var i;\n\t      if (listeners) {\n\t        i = listeners.length;\n\t        while (i--) {\n\t          off(this.el, listeners[i][0], listeners[i][1]);\n\t        }\n\t      }\n\t      var unwatchFns = this._paramUnwatchFns;\n\t      if (unwatchFns) {\n\t        i = unwatchFns.length;\n\t        while (i--) {\n\t          unwatchFns[i]();\n\t        }\n\t      }\n\t      if ('development' !== 'production' && this.el) {\n\t        this.el._vue_directives.$remove(this);\n\t      }\n\t      this.vm = this.el = this._watcher = this._listeners = null;\n\t    }\n\t  };\n\t\n\t  function lifecycleMixin (Vue) {\n\t\n\t    /**\n\t     * Update v-ref for component.\n\t     *\n\t     * @param {Boolean} remove\n\t     */\n\t\n\t    Vue.prototype._updateRef = function (remove) {\n\t      var ref = this.$options._ref;\n\t      if (ref) {\n\t        var refs = (this._scope || this._context).$refs;\n\t        if (remove) {\n\t          if (refs[ref] === this) {\n\t            refs[ref] = null;\n\t          }\n\t        } else {\n\t          refs[ref] = this;\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Transclude, compile and link element.\n\t     *\n\t     * If a pre-compiled linker is available, that means the\n\t     * passed in element will be pre-transcluded and compiled\n\t     * as well - all we need to do is to call the linker.\n\t     *\n\t     * Otherwise we need to call transclude/compile/link here.\n\t     *\n\t     * @param {Element} el\n\t     * @return {Element}\n\t     */\n\t\n\t    Vue.prototype._compile = function (el) {\n\t      var options = this.$options;\n\t\n\t      // transclude and init element\n\t      // transclude can potentially replace original\n\t      // so we need to keep reference; this step also injects\n\t      // the template and caches the original attributes\n\t      // on the container node and replacer node.\n\t      var original = el;\n\t      el = transclude(el, options);\n\t      this._initElement(el);\n\t\n\t      // handle v-pre on root node (#2026)\n\t      if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\n\t        return;\n\t      }\n\t\n\t      // root is always compiled per-instance, because\n\t      // container attrs and props can be different every time.\n\t      var contextOptions = this._context && this._context.$options;\n\t      var rootLinker = compileRoot(el, options, contextOptions);\n\t\n\t      // compile and link the rest\n\t      var contentLinkFn;\n\t      var ctor = this.constructor;\n\t      // component compilation can be cached\n\t      // as long as it's not using inline-template\n\t      if (options._linkerCachable) {\n\t        contentLinkFn = ctor.linker;\n\t        if (!contentLinkFn) {\n\t          contentLinkFn = ctor.linker = compile(el, options);\n\t        }\n\t      }\n\t\n\t      // link phase\n\t      // make sure to link root with prop scope!\n\t      var rootUnlinkFn = rootLinker(this, el, this._scope);\n\t      var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\n\t\n\t      // register composite unlink function\n\t      // to be called during instance destruction\n\t      this._unlinkFn = function () {\n\t        rootUnlinkFn();\n\t        // passing destroying: true to avoid searching and\n\t        // splicing the directives\n\t        contentUnlinkFn(true);\n\t      };\n\t\n\t      // finally replace original\n\t      if (options.replace) {\n\t        replace(original, el);\n\t      }\n\t\n\t      this._isCompiled = true;\n\t      this._callHook('compiled');\n\t      return el;\n\t    };\n\t\n\t    /**\n\t     * Initialize instance element. Called in the public\n\t     * $mount() method.\n\t     *\n\t     * @param {Element} el\n\t     */\n\t\n\t    Vue.prototype._initElement = function (el) {\n\t      if (el instanceof DocumentFragment) {\n\t        this._isFragment = true;\n\t        this.$el = this._fragmentStart = el.firstChild;\n\t        this._fragmentEnd = el.lastChild;\n\t        // set persisted text anchors to empty\n\t        if (this._fragmentStart.nodeType === 3) {\n\t          this._fragmentStart.data = this._fragmentEnd.data = '';\n\t        }\n\t        this._fragment = el;\n\t      } else {\n\t        this.$el = el;\n\t      }\n\t      this.$el.__vue__ = this;\n\t      this._callHook('beforeCompile');\n\t    };\n\t\n\t    /**\n\t     * Create and bind a directive to an element.\n\t     *\n\t     * @param {String} name - directive name\n\t     * @param {Node} node   - target node\n\t     * @param {Object} desc - parsed directive descriptor\n\t     * @param {Object} def  - directive definition object\n\t     * @param {Vue} [host] - transclusion host component\n\t     * @param {Object} [scope] - v-for scope\n\t     * @param {Fragment} [frag] - owner fragment\n\t     */\n\t\n\t    Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\n\t      this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\n\t    };\n\t\n\t    /**\n\t     * Teardown an instance, unobserves the data, unbind all the\n\t     * directives, turn off all the event listeners, etc.\n\t     *\n\t     * @param {Boolean} remove - whether to remove the DOM node.\n\t     * @param {Boolean} deferCleanup - if true, defer cleanup to\n\t     *                                 be called later\n\t     */\n\t\n\t    Vue.prototype._destroy = function (remove, deferCleanup) {\n\t      if (this._isBeingDestroyed) {\n\t        if (!deferCleanup) {\n\t          this._cleanup();\n\t        }\n\t        return;\n\t      }\n\t\n\t      var destroyReady;\n\t      var pendingRemoval;\n\t\n\t      var self = this;\n\t      // Cleanup should be called either synchronously or asynchronoysly as\n\t      // callback of this.$remove(), or if remove and deferCleanup are false.\n\t      // In any case it should be called after all other removing, unbinding and\n\t      // turning of is done\n\t      var cleanupIfPossible = function cleanupIfPossible() {\n\t        if (destroyReady && !pendingRemoval && !deferCleanup) {\n\t          self._cleanup();\n\t        }\n\t      };\n\t\n\t      // remove DOM element\n\t      if (remove && this.$el) {\n\t        pendingRemoval = true;\n\t        this.$remove(function () {\n\t          pendingRemoval = false;\n\t          cleanupIfPossible();\n\t        });\n\t      }\n\t\n\t      this._callHook('beforeDestroy');\n\t      this._isBeingDestroyed = true;\n\t      var i;\n\t      // remove self from parent. only necessary\n\t      // if parent is not being destroyed as well.\n\t      var parent = this.$parent;\n\t      if (parent && !parent._isBeingDestroyed) {\n\t        parent.$children.$remove(this);\n\t        // unregister ref (remove: true)\n\t        this._updateRef(true);\n\t      }\n\t      // destroy all children.\n\t      i = this.$children.length;\n\t      while (i--) {\n\t        this.$children[i].$destroy();\n\t      }\n\t      // teardown props\n\t      if (this._propsUnlinkFn) {\n\t        this._propsUnlinkFn();\n\t      }\n\t      // teardown all directives. this also tearsdown all\n\t      // directive-owned watchers.\n\t      if (this._unlinkFn) {\n\t        this._unlinkFn();\n\t      }\n\t      i = this._watchers.length;\n\t      while (i--) {\n\t        this._watchers[i].teardown();\n\t      }\n\t      // remove reference to self on $el\n\t      if (this.$el) {\n\t        this.$el.__vue__ = null;\n\t      }\n\t\n\t      destroyReady = true;\n\t      cleanupIfPossible();\n\t    };\n\t\n\t    /**\n\t     * Clean up to ensure garbage collection.\n\t     * This is called after the leave transition if there\n\t     * is any.\n\t     */\n\t\n\t    Vue.prototype._cleanup = function () {\n\t      if (this._isDestroyed) {\n\t        return;\n\t      }\n\t      // remove self from owner fragment\n\t      // do it in cleanup so that we can call $destroy with\n\t      // defer right when a fragment is about to be removed.\n\t      if (this._frag) {\n\t        this._frag.children.$remove(this);\n\t      }\n\t      // remove reference from data ob\n\t      // frozen object may not have observer.\n\t      if (this._data.__ob__) {\n\t        this._data.__ob__.removeVm(this);\n\t      }\n\t      // Clean up references to private properties and other\n\t      // instances. preserve reference to _data so that proxy\n\t      // accessors still work. The only potential side effect\n\t      // here is that mutating the instance after it's destroyed\n\t      // may affect the state of other components that are still\n\t      // observing the same object, but that seems to be a\n\t      // reasonable responsibility for the user rather than\n\t      // always throwing an error on them.\n\t      this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\n\t      // call the last hook...\n\t      this._isDestroyed = true;\n\t      this._callHook('destroyed');\n\t      // turn off all instance listeners.\n\t      this.$off();\n\t    };\n\t  }\n\t\n\t  function miscMixin (Vue) {\n\t\n\t    /**\n\t     * Apply a list of filter (descriptors) to a value.\n\t     * Using plain for loops here because this will be called in\n\t     * the getter of any watcher with filters so it is very\n\t     * performance sensitive.\n\t     *\n\t     * @param {*} value\n\t     * @param {*} [oldValue]\n\t     * @param {Array} filters\n\t     * @param {Boolean} write\n\t     * @return {*}\n\t     */\n\t\n\t    Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\n\t      var filter, fn, args, arg, offset, i, l, j, k;\n\t      for (i = 0, l = filters.length; i < l; i++) {\n\t        filter = filters[i];\n\t        fn = resolveAsset(this.$options, 'filters', filter.name);\n\t        if (true) {\n\t          assertAsset(fn, 'filter', filter.name);\n\t        }\n\t        if (!fn) continue;\n\t        fn = write ? fn.write : fn.read || fn;\n\t        if (typeof fn !== 'function') continue;\n\t        args = write ? [value, oldValue] : [value];\n\t        offset = write ? 2 : 1;\n\t        if (filter.args) {\n\t          for (j = 0, k = filter.args.length; j < k; j++) {\n\t            arg = filter.args[j];\n\t            args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\n\t          }\n\t        }\n\t        value = fn.apply(this, args);\n\t      }\n\t      return value;\n\t    };\n\t\n\t    /**\n\t     * Resolve a component, depending on whether the component\n\t     * is defined normally or using an async factory function.\n\t     * Resolves synchronously if already resolved, otherwise\n\t     * resolves asynchronously and caches the resolved\n\t     * constructor on the factory.\n\t     *\n\t     * @param {String} id\n\t     * @param {Function} cb\n\t     */\n\t\n\t    Vue.prototype._resolveComponent = function (id, cb) {\n\t      var factory = resolveAsset(this.$options, 'components', id);\n\t      if (true) {\n\t        assertAsset(factory, 'component', id);\n\t      }\n\t      if (!factory) {\n\t        return;\n\t      }\n\t      // async component factory\n\t      if (!factory.options) {\n\t        if (factory.resolved) {\n\t          // cached\n\t          cb(factory.resolved);\n\t        } else if (factory.requested) {\n\t          // pool callbacks\n\t          factory.pendingCallbacks.push(cb);\n\t        } else {\n\t          factory.requested = true;\n\t          var cbs = factory.pendingCallbacks = [cb];\n\t          factory(function resolve(res) {\n\t            if (isPlainObject(res)) {\n\t              res = Vue.extend(res);\n\t            }\n\t            // cache resolved\n\t            factory.resolved = res;\n\t            // invoke callbacks\n\t            for (var i = 0, l = cbs.length; i < l; i++) {\n\t              cbs[i](res);\n\t            }\n\t          }, function reject(reason) {\n\t            'development' !== 'production' && warn('Failed to resolve async component: ' + id + '. ' + (reason ? '\\nReason: ' + reason : ''));\n\t          });\n\t        }\n\t      } else {\n\t        // normal component\n\t        cb(factory);\n\t      }\n\t    };\n\t  }\n\t\n\t  function globalAPI (Vue) {\n\t\n\t    /**\n\t     * Expose useful internals\n\t     */\n\t\n\t    Vue.util = util;\n\t    Vue.config = config;\n\t    Vue.set = set;\n\t    Vue['delete'] = del;\n\t    Vue.nextTick = nextTick;\n\t\n\t    /**\n\t     * The following are exposed for advanced usage / plugins\n\t     */\n\t\n\t    Vue.compiler = compiler;\n\t    Vue.FragmentFactory = FragmentFactory;\n\t    Vue.internalDirectives = internalDirectives;\n\t    Vue.parsers = {\n\t      path: path,\n\t      text: text$1,\n\t      template: template,\n\t      directive: directive,\n\t      expression: expression\n\t    };\n\t\n\t    /**\n\t     * Each instance constructor, including Vue, has a unique\n\t     * cid. This enables us to create wrapped \"child\n\t     * constructors\" for prototypal inheritance and cache them.\n\t     */\n\t\n\t    Vue.cid = 0;\n\t    var cid = 1;\n\t\n\t    /**\n\t     * Class inheritance\n\t     *\n\t     * @param {Object} extendOptions\n\t     */\n\t\n\t    Vue.extend = function (extendOptions) {\n\t      extendOptions = extendOptions || {};\n\t      var Super = this;\n\t      var isFirstExtend = Super.cid === 0;\n\t      if (isFirstExtend && extendOptions._Ctor) {\n\t        return extendOptions._Ctor;\n\t      }\n\t      var name = extendOptions.name || Super.options.name;\n\t      if (true) {\n\t        if (!/^[a-zA-Z][\\w-]+$/.test(name)) {\n\t          warn('Invalid component name: ' + name);\n\t          name = null;\n\t        }\n\t      }\n\t      var Sub = createClass(name || 'VueComponent');\n\t      Sub.prototype = Object.create(Super.prototype);\n\t      Sub.prototype.constructor = Sub;\n\t      Sub.cid = cid++;\n\t      Sub.options = mergeOptions(Super.options, extendOptions);\n\t      Sub['super'] = Super;\n\t      // allow further extension\n\t      Sub.extend = Super.extend;\n\t      // create asset registers, so extended classes\n\t      // can have their private assets too.\n\t      config._assetTypes.forEach(function (type) {\n\t        Sub[type] = Super[type];\n\t      });\n\t      // enable recursive self-lookup\n\t      if (name) {\n\t        Sub.options.components[name] = Sub;\n\t      }\n\t      // cache constructor\n\t      if (isFirstExtend) {\n\t        extendOptions._Ctor = Sub;\n\t      }\n\t      return Sub;\n\t    };\n\t\n\t    /**\n\t     * A function that returns a sub-class constructor with the\n\t     * given name. This gives us much nicer output when\n\t     * logging instances in the console.\n\t     *\n\t     * @param {String} name\n\t     * @return {Function}\n\t     */\n\t\n\t    function createClass(name) {\n\t      return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\n\t    }\n\t\n\t    /**\n\t     * Plugin system\n\t     *\n\t     * @param {Object} plugin\n\t     */\n\t\n\t    Vue.use = function (plugin) {\n\t      /* istanbul ignore if */\n\t      if (plugin.installed) {\n\t        return;\n\t      }\n\t      // additional parameters\n\t      var args = toArray(arguments, 1);\n\t      args.unshift(this);\n\t      if (typeof plugin.install === 'function') {\n\t        plugin.install.apply(plugin, args);\n\t      } else {\n\t        plugin.apply(null, args);\n\t      }\n\t      plugin.installed = true;\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Apply a global mixin by merging it into the default\n\t     * options.\n\t     */\n\t\n\t    Vue.mixin = function (mixin) {\n\t      Vue.options = mergeOptions(Vue.options, mixin);\n\t    };\n\t\n\t    /**\n\t     * Create asset registration methods with the following\n\t     * signature:\n\t     *\n\t     * @param {String} id\n\t     * @param {*} definition\n\t     */\n\t\n\t    config._assetTypes.forEach(function (type) {\n\t      Vue[type] = function (id, definition) {\n\t        if (!definition) {\n\t          return this.options[type + 's'][id];\n\t        } else {\n\t          /* istanbul ignore if */\n\t          if (true) {\n\t            if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\n\t              warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n\t            }\n\t          }\n\t          if (type === 'component' && isPlainObject(definition)) {\n\t            definition.name = id;\n\t            definition = Vue.extend(definition);\n\t          }\n\t          this.options[type + 's'][id] = definition;\n\t          return definition;\n\t        }\n\t      };\n\t    });\n\t  }\n\t\n\t  var filterRE = /[^|]\\|[^|]/;\n\t\n\t  function dataAPI (Vue) {\n\t\n\t    /**\n\t     * Get the value from an expression on this vm.\n\t     *\n\t     * @param {String} exp\n\t     * @param {Boolean} [asStatement]\n\t     * @return {*}\n\t     */\n\t\n\t    Vue.prototype.$get = function (exp, asStatement) {\n\t      var res = parseExpression(exp);\n\t      if (res) {\n\t        if (asStatement && !isSimplePath(exp)) {\n\t          var self = this;\n\t          return function statementHandler() {\n\t            self.$arguments = toArray(arguments);\n\t            var result = res.get.call(self, self);\n\t            self.$arguments = null;\n\t            return result;\n\t          };\n\t        } else {\n\t          try {\n\t            return res.get.call(this, this);\n\t          } catch (e) {}\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Set the value from an expression on this vm.\n\t     * The expression must be a valid left-hand\n\t     * expression in an assignment.\n\t     *\n\t     * @param {String} exp\n\t     * @param {*} val\n\t     */\n\t\n\t    Vue.prototype.$set = function (exp, val) {\n\t      var res = parseExpression(exp, true);\n\t      if (res && res.set) {\n\t        res.set.call(this, this, val);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Delete a property on the VM\n\t     *\n\t     * @param {String} key\n\t     */\n\t\n\t    Vue.prototype.$delete = function (key) {\n\t      del(this._data, key);\n\t    };\n\t\n\t    /**\n\t     * Watch an expression, trigger callback when its\n\t     * value changes.\n\t     *\n\t     * @param {String|Function} expOrFn\n\t     * @param {Function} cb\n\t     * @param {Object} [options]\n\t     *                 - {Boolean} deep\n\t     *                 - {Boolean} immediate\n\t     * @return {Function} - unwatchFn\n\t     */\n\t\n\t    Vue.prototype.$watch = function (expOrFn, cb, options) {\n\t      var vm = this;\n\t      var parsed;\n\t      if (typeof expOrFn === 'string') {\n\t        parsed = parseDirective(expOrFn);\n\t        expOrFn = parsed.expression;\n\t      }\n\t      var watcher = new Watcher(vm, expOrFn, cb, {\n\t        deep: options && options.deep,\n\t        sync: options && options.sync,\n\t        filters: parsed && parsed.filters,\n\t        user: !options || options.user !== false\n\t      });\n\t      if (options && options.immediate) {\n\t        cb.call(vm, watcher.value);\n\t      }\n\t      return function unwatchFn() {\n\t        watcher.teardown();\n\t      };\n\t    };\n\t\n\t    /**\n\t     * Evaluate a text directive, including filters.\n\t     *\n\t     * @param {String} text\n\t     * @param {Boolean} [asStatement]\n\t     * @return {String}\n\t     */\n\t\n\t    Vue.prototype.$eval = function (text, asStatement) {\n\t      // check for filters.\n\t      if (filterRE.test(text)) {\n\t        var dir = parseDirective(text);\n\t        // the filter regex check might give false positive\n\t        // for pipes inside strings, so it's possible that\n\t        // we don't get any filters here\n\t        var val = this.$get(dir.expression, asStatement);\n\t        return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\n\t      } else {\n\t        // no filter\n\t        return this.$get(text, asStatement);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Interpolate a piece of template text.\n\t     *\n\t     * @param {String} text\n\t     * @return {String}\n\t     */\n\t\n\t    Vue.prototype.$interpolate = function (text) {\n\t      var tokens = parseText(text);\n\t      var vm = this;\n\t      if (tokens) {\n\t        if (tokens.length === 1) {\n\t          return vm.$eval(tokens[0].value) + '';\n\t        } else {\n\t          return tokens.map(function (token) {\n\t            return token.tag ? vm.$eval(token.value) : token.value;\n\t          }).join('');\n\t        }\n\t      } else {\n\t        return text;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Log instance data as a plain JS object\n\t     * so that it is easier to inspect in console.\n\t     * This method assumes console is available.\n\t     *\n\t     * @param {String} [path]\n\t     */\n\t\n\t    Vue.prototype.$log = function (path) {\n\t      var data = path ? getPath(this._data, path) : this._data;\n\t      if (data) {\n\t        data = clean(data);\n\t      }\n\t      // include computed fields\n\t      if (!path) {\n\t        for (var key in this.$options.computed) {\n\t          data[key] = clean(this[key]);\n\t        }\n\t      }\n\t      console.log(data);\n\t    };\n\t\n\t    /**\n\t     * \"clean\" a getter/setter converted object into a plain\n\t     * object copy.\n\t     *\n\t     * @param {Object} - obj\n\t     * @return {Object}\n\t     */\n\t\n\t    function clean(obj) {\n\t      return JSON.parse(JSON.stringify(obj));\n\t    }\n\t  }\n\t\n\t  function domAPI (Vue) {\n\t\n\t    /**\n\t     * Convenience on-instance nextTick. The callback is\n\t     * auto-bound to the instance, and this avoids component\n\t     * modules having to rely on the global Vue.\n\t     *\n\t     * @param {Function} fn\n\t     */\n\t\n\t    Vue.prototype.$nextTick = function (fn) {\n\t      nextTick(fn, this);\n\t    };\n\t\n\t    /**\n\t     * Append instance to target\n\t     *\n\t     * @param {Node} target\n\t     * @param {Function} [cb]\n\t     * @param {Boolean} [withTransition] - defaults to true\n\t     */\n\t\n\t    Vue.prototype.$appendTo = function (target, cb, withTransition) {\n\t      return insert(this, target, cb, withTransition, append, appendWithTransition);\n\t    };\n\t\n\t    /**\n\t     * Prepend instance to target\n\t     *\n\t     * @param {Node} target\n\t     * @param {Function} [cb]\n\t     * @param {Boolean} [withTransition] - defaults to true\n\t     */\n\t\n\t    Vue.prototype.$prependTo = function (target, cb, withTransition) {\n\t      target = query(target);\n\t      if (target.hasChildNodes()) {\n\t        this.$before(target.firstChild, cb, withTransition);\n\t      } else {\n\t        this.$appendTo(target, cb, withTransition);\n\t      }\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Insert instance before target\n\t     *\n\t     * @param {Node} target\n\t     * @param {Function} [cb]\n\t     * @param {Boolean} [withTransition] - defaults to true\n\t     */\n\t\n\t    Vue.prototype.$before = function (target, cb, withTransition) {\n\t      return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\n\t    };\n\t\n\t    /**\n\t     * Insert instance after target\n\t     *\n\t     * @param {Node} target\n\t     * @param {Function} [cb]\n\t     * @param {Boolean} [withTransition] - defaults to true\n\t     */\n\t\n\t    Vue.prototype.$after = function (target, cb, withTransition) {\n\t      target = query(target);\n\t      if (target.nextSibling) {\n\t        this.$before(target.nextSibling, cb, withTransition);\n\t      } else {\n\t        this.$appendTo(target.parentNode, cb, withTransition);\n\t      }\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Remove instance from DOM\n\t     *\n\t     * @param {Function} [cb]\n\t     * @param {Boolean} [withTransition] - defaults to true\n\t     */\n\t\n\t    Vue.prototype.$remove = function (cb, withTransition) {\n\t      if (!this.$el.parentNode) {\n\t        return cb && cb();\n\t      }\n\t      var inDocument = this._isAttached && inDoc(this.$el);\n\t      // if we are not in document, no need to check\n\t      // for transitions\n\t      if (!inDocument) withTransition = false;\n\t      var self = this;\n\t      var realCb = function realCb() {\n\t        if (inDocument) self._callHook('detached');\n\t        if (cb) cb();\n\t      };\n\t      if (this._isFragment) {\n\t        removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\n\t      } else {\n\t        var op = withTransition === false ? removeWithCb : removeWithTransition;\n\t        op(this.$el, this, realCb);\n\t      }\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Shared DOM insertion function.\n\t     *\n\t     * @param {Vue} vm\n\t     * @param {Element} target\n\t     * @param {Function} [cb]\n\t     * @param {Boolean} [withTransition]\n\t     * @param {Function} op1 - op for non-transition insert\n\t     * @param {Function} op2 - op for transition insert\n\t     * @return vm\n\t     */\n\t\n\t    function insert(vm, target, cb, withTransition, op1, op2) {\n\t      target = query(target);\n\t      var targetIsDetached = !inDoc(target);\n\t      var op = withTransition === false || targetIsDetached ? op1 : op2;\n\t      var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\n\t      if (vm._isFragment) {\n\t        mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n\t          op(node, target, vm);\n\t        });\n\t        cb && cb();\n\t      } else {\n\t        op(vm.$el, target, vm, cb);\n\t      }\n\t      if (shouldCallHook) {\n\t        vm._callHook('attached');\n\t      }\n\t      return vm;\n\t    }\n\t\n\t    /**\n\t     * Check for selectors\n\t     *\n\t     * @param {String|Element} el\n\t     */\n\t\n\t    function query(el) {\n\t      return typeof el === 'string' ? document.querySelector(el) : el;\n\t    }\n\t\n\t    /**\n\t     * Append operation that takes a callback.\n\t     *\n\t     * @param {Node} el\n\t     * @param {Node} target\n\t     * @param {Vue} vm - unused\n\t     * @param {Function} [cb]\n\t     */\n\t\n\t    function append(el, target, vm, cb) {\n\t      target.appendChild(el);\n\t      if (cb) cb();\n\t    }\n\t\n\t    /**\n\t     * InsertBefore operation that takes a callback.\n\t     *\n\t     * @param {Node} el\n\t     * @param {Node} target\n\t     * @param {Vue} vm - unused\n\t     * @param {Function} [cb]\n\t     */\n\t\n\t    function beforeWithCb(el, target, vm, cb) {\n\t      before(el, target);\n\t      if (cb) cb();\n\t    }\n\t\n\t    /**\n\t     * Remove operation that takes a callback.\n\t     *\n\t     * @param {Node} el\n\t     * @param {Vue} vm - unused\n\t     * @param {Function} [cb]\n\t     */\n\t\n\t    function removeWithCb(el, vm, cb) {\n\t      remove(el);\n\t      if (cb) cb();\n\t    }\n\t  }\n\t\n\t  function eventsAPI (Vue) {\n\t\n\t    /**\n\t     * Listen on the given `event` with `fn`.\n\t     *\n\t     * @param {String} event\n\t     * @param {Function} fn\n\t     */\n\t\n\t    Vue.prototype.$on = function (event, fn) {\n\t      (this._events[event] || (this._events[event] = [])).push(fn);\n\t      modifyListenerCount(this, event, 1);\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Adds an `event` listener that will be invoked a single\n\t     * time then automatically removed.\n\t     *\n\t     * @param {String} event\n\t     * @param {Function} fn\n\t     */\n\t\n\t    Vue.prototype.$once = function (event, fn) {\n\t      var self = this;\n\t      function on() {\n\t        self.$off(event, on);\n\t        fn.apply(this, arguments);\n\t      }\n\t      on.fn = fn;\n\t      this.$on(event, on);\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Remove the given callback for `event` or all\n\t     * registered callbacks.\n\t     *\n\t     * @param {String} event\n\t     * @param {Function} fn\n\t     */\n\t\n\t    Vue.prototype.$off = function (event, fn) {\n\t      var cbs;\n\t      // all\n\t      if (!arguments.length) {\n\t        if (this.$parent) {\n\t          for (event in this._events) {\n\t            cbs = this._events[event];\n\t            if (cbs) {\n\t              modifyListenerCount(this, event, -cbs.length);\n\t            }\n\t          }\n\t        }\n\t        this._events = {};\n\t        return this;\n\t      }\n\t      // specific event\n\t      cbs = this._events[event];\n\t      if (!cbs) {\n\t        return this;\n\t      }\n\t      if (arguments.length === 1) {\n\t        modifyListenerCount(this, event, -cbs.length);\n\t        this._events[event] = null;\n\t        return this;\n\t      }\n\t      // specific handler\n\t      var cb;\n\t      var i = cbs.length;\n\t      while (i--) {\n\t        cb = cbs[i];\n\t        if (cb === fn || cb.fn === fn) {\n\t          modifyListenerCount(this, event, -1);\n\t          cbs.splice(i, 1);\n\t          break;\n\t        }\n\t      }\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Trigger an event on self.\n\t     *\n\t     * @param {String|Object} event\n\t     * @return {Boolean} shouldPropagate\n\t     */\n\t\n\t    Vue.prototype.$emit = function (event) {\n\t      var isSource = typeof event === 'string';\n\t      event = isSource ? event : event.name;\n\t      var cbs = this._events[event];\n\t      var shouldPropagate = isSource || !cbs;\n\t      if (cbs) {\n\t        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n\t        // this is a somewhat hacky solution to the question raised\n\t        // in #2102: for an inline component listener like <comp @test=\"doThis\">,\n\t        // the propagation handling is somewhat broken. Therefore we\n\t        // need to treat these inline callbacks differently.\n\t        var hasParentCbs = isSource && cbs.some(function (cb) {\n\t          return cb._fromParent;\n\t        });\n\t        if (hasParentCbs) {\n\t          shouldPropagate = false;\n\t        }\n\t        var args = toArray(arguments, 1);\n\t        for (var i = 0, l = cbs.length; i < l; i++) {\n\t          var cb = cbs[i];\n\t          var res = cb.apply(this, args);\n\t          if (res === true && (!hasParentCbs || cb._fromParent)) {\n\t            shouldPropagate = true;\n\t          }\n\t        }\n\t      }\n\t      return shouldPropagate;\n\t    };\n\t\n\t    /**\n\t     * Recursively broadcast an event to all children instances.\n\t     *\n\t     * @param {String|Object} event\n\t     * @param {...*} additional arguments\n\t     */\n\t\n\t    Vue.prototype.$broadcast = function (event) {\n\t      var isSource = typeof event === 'string';\n\t      event = isSource ? event : event.name;\n\t      // if no child has registered for this event,\n\t      // then there's no need to broadcast.\n\t      if (!this._eventsCount[event]) return;\n\t      var children = this.$children;\n\t      var args = toArray(arguments);\n\t      if (isSource) {\n\t        // use object event to indicate non-source emit\n\t        // on children\n\t        args[0] = { name: event, source: this };\n\t      }\n\t      for (var i = 0, l = children.length; i < l; i++) {\n\t        var child = children[i];\n\t        var shouldPropagate = child.$emit.apply(child, args);\n\t        if (shouldPropagate) {\n\t          child.$broadcast.apply(child, args);\n\t        }\n\t      }\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Recursively propagate an event up the parent chain.\n\t     *\n\t     * @param {String} event\n\t     * @param {...*} additional arguments\n\t     */\n\t\n\t    Vue.prototype.$dispatch = function (event) {\n\t      var shouldPropagate = this.$emit.apply(this, arguments);\n\t      if (!shouldPropagate) return;\n\t      var parent = this.$parent;\n\t      var args = toArray(arguments);\n\t      // use object event to indicate non-source emit\n\t      // on parents\n\t      args[0] = { name: event, source: this };\n\t      while (parent) {\n\t        shouldPropagate = parent.$emit.apply(parent, args);\n\t        parent = shouldPropagate ? parent.$parent : null;\n\t      }\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Modify the listener counts on all parents.\n\t     * This bookkeeping allows $broadcast to return early when\n\t     * no child has listened to a certain event.\n\t     *\n\t     * @param {Vue} vm\n\t     * @param {String} event\n\t     * @param {Number} count\n\t     */\n\t\n\t    var hookRE = /^hook:/;\n\t    function modifyListenerCount(vm, event, count) {\n\t      var parent = vm.$parent;\n\t      // hooks do not get broadcasted so no need\n\t      // to do bookkeeping for them\n\t      if (!parent || !count || hookRE.test(event)) return;\n\t      while (parent) {\n\t        parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\n\t        parent = parent.$parent;\n\t      }\n\t    }\n\t  }\n\t\n\t  function lifecycleAPI (Vue) {\n\t\n\t    /**\n\t     * Set instance target element and kick off the compilation\n\t     * process. The passed in `el` can be a selector string, an\n\t     * existing Element, or a DocumentFragment (for block\n\t     * instances).\n\t     *\n\t     * @param {Element|DocumentFragment|string} el\n\t     * @public\n\t     */\n\t\n\t    Vue.prototype.$mount = function (el) {\n\t      if (this._isCompiled) {\n\t        'development' !== 'production' && warn('$mount() should be called only once.');\n\t        return;\n\t      }\n\t      el = query(el);\n\t      if (!el) {\n\t        el = document.createElement('div');\n\t      }\n\t      this._compile(el);\n\t      this._initDOMHooks();\n\t      if (inDoc(this.$el)) {\n\t        this._callHook('attached');\n\t        ready.call(this);\n\t      } else {\n\t        this.$once('hook:attached', ready);\n\t      }\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Mark an instance as ready.\n\t     */\n\t\n\t    function ready() {\n\t      this._isAttached = true;\n\t      this._isReady = true;\n\t      this._callHook('ready');\n\t    }\n\t\n\t    /**\n\t     * Teardown the instance, simply delegate to the internal\n\t     * _destroy.\n\t     */\n\t\n\t    Vue.prototype.$destroy = function (remove, deferCleanup) {\n\t      this._destroy(remove, deferCleanup);\n\t    };\n\t\n\t    /**\n\t     * Partially compile a piece of DOM and return a\n\t     * decompile function.\n\t     *\n\t     * @param {Element|DocumentFragment} el\n\t     * @param {Vue} [host]\n\t     * @return {Function}\n\t     */\n\t\n\t    Vue.prototype.$compile = function (el, host, scope, frag) {\n\t      return compile(el, this.$options, true)(this, el, host, scope, frag);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * The exposed Vue constructor.\n\t   *\n\t   * API conventions:\n\t   * - public API methods/properties are prefixed with `$`\n\t   * - internal methods/properties are prefixed with `_`\n\t   * - non-prefixed properties are assumed to be proxied user\n\t   *   data.\n\t   *\n\t   * @constructor\n\t   * @param {Object} [options]\n\t   * @public\n\t   */\n\t\n\t  function Vue(options) {\n\t    this._init(options);\n\t  }\n\t\n\t  // install internals\n\t  initMixin(Vue);\n\t  stateMixin(Vue);\n\t  eventsMixin(Vue);\n\t  lifecycleMixin(Vue);\n\t  miscMixin(Vue);\n\t\n\t  // install APIs\n\t  globalAPI(Vue);\n\t  dataAPI(Vue);\n\t  domAPI(Vue);\n\t  eventsAPI(Vue);\n\t  lifecycleAPI(Vue);\n\t\n\t  var convertArray = vFor._postProcess;\n\t\n\t  /**\n\t   * Limit filter for arrays\n\t   *\n\t   * @param {Number} n\n\t   * @param {Number} offset (Decimal expected)\n\t   */\n\t\n\t  function limitBy(arr, n, offset) {\n\t    offset = offset ? parseInt(offset, 10) : 0;\n\t    n = toNumber(n);\n\t    return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\n\t  }\n\t\n\t  /**\n\t   * Filter filter for arrays\n\t   *\n\t   * @param {String} search\n\t   * @param {String} [delimiter]\n\t   * @param {String} ...dataKeys\n\t   */\n\t\n\t  function filterBy(arr, search, delimiter) {\n\t    arr = convertArray(arr);\n\t    if (search == null) {\n\t      return arr;\n\t    }\n\t    if (typeof search === 'function') {\n\t      return arr.filter(search);\n\t    }\n\t    // cast to lowercase string\n\t    search = ('' + search).toLowerCase();\n\t    // allow optional `in` delimiter\n\t    // because why not\n\t    var n = delimiter === 'in' ? 3 : 2;\n\t    // extract and flatten keys\n\t    var keys = toArray(arguments, n).reduce(function (prev, cur) {\n\t      return prev.concat(cur);\n\t    }, []);\n\t    var res = [];\n\t    var item, key, val, j;\n\t    for (var i = 0, l = arr.length; i < l; i++) {\n\t      item = arr[i];\n\t      val = item && item.$value || item;\n\t      j = keys.length;\n\t      if (j) {\n\t        while (j--) {\n\t          key = keys[j];\n\t          if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\n\t            res.push(item);\n\t            break;\n\t          }\n\t        }\n\t      } else if (contains(item, search)) {\n\t        res.push(item);\n\t      }\n\t    }\n\t    return res;\n\t  }\n\t\n\t  /**\n\t   * Filter filter for arrays\n\t   *\n\t   * @param {String} sortKey\n\t   * @param {String} reverse\n\t   */\n\t\n\t  function orderBy(arr, sortKey, reverse) {\n\t    arr = convertArray(arr);\n\t    if (!sortKey) {\n\t      return arr;\n\t    }\n\t    var order = reverse && reverse < 0 ? -1 : 1;\n\t    // sort on a copy to avoid mutating original array\n\t    return arr.slice().sort(function (a, b) {\n\t      if (sortKey !== '$key') {\n\t        if (isObject(a) && '$value' in a) a = a.$value;\n\t        if (isObject(b) && '$value' in b) b = b.$value;\n\t      }\n\t      a = isObject(a) ? getPath(a, sortKey) : a;\n\t      b = isObject(b) ? getPath(b, sortKey) : b;\n\t      return a === b ? 0 : a > b ? order : -order;\n\t    });\n\t  }\n\t\n\t  /**\n\t   * String contain helper\n\t   *\n\t   * @param {*} val\n\t   * @param {String} search\n\t   */\n\t\n\t  function contains(val, search) {\n\t    var i;\n\t    if (isPlainObject(val)) {\n\t      var keys = Object.keys(val);\n\t      i = keys.length;\n\t      while (i--) {\n\t        if (contains(val[keys[i]], search)) {\n\t          return true;\n\t        }\n\t      }\n\t    } else if (isArray(val)) {\n\t      i = val.length;\n\t      while (i--) {\n\t        if (contains(val[i], search)) {\n\t          return true;\n\t        }\n\t      }\n\t    } else if (val != null) {\n\t      return val.toString().toLowerCase().indexOf(search) > -1;\n\t    }\n\t  }\n\t\n\t  var digitsRE = /(\\d{3})(?=\\d)/g;\n\t\n\t  // asset collections must be a plain object.\n\t  var filters = {\n\t\n\t    orderBy: orderBy,\n\t    filterBy: filterBy,\n\t    limitBy: limitBy,\n\t\n\t    /**\n\t     * Stringify value.\n\t     *\n\t     * @param {Number} indent\n\t     */\n\t\n\t    json: {\n\t      read: function read(value, indent) {\n\t        return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);\n\t      },\n\t      write: function write(value) {\n\t        try {\n\t          return JSON.parse(value);\n\t        } catch (e) {\n\t          return value;\n\t        }\n\t      }\n\t    },\n\t\n\t    /**\n\t     * 'abc' => 'Abc'\n\t     */\n\t\n\t    capitalize: function capitalize(value) {\n\t      if (!value && value !== 0) return '';\n\t      value = value.toString();\n\t      return value.charAt(0).toUpperCase() + value.slice(1);\n\t    },\n\t\n\t    /**\n\t     * 'abc' => 'ABC'\n\t     */\n\t\n\t    uppercase: function uppercase(value) {\n\t      return value || value === 0 ? value.toString().toUpperCase() : '';\n\t    },\n\t\n\t    /**\n\t     * 'AbC' => 'abc'\n\t     */\n\t\n\t    lowercase: function lowercase(value) {\n\t      return value || value === 0 ? value.toString().toLowerCase() : '';\n\t    },\n\t\n\t    /**\n\t     * 12345 => $12,345.00\n\t     *\n\t     * @param {String} sign\n\t     */\n\t\n\t    currency: function currency(value, _currency) {\n\t      value = parseFloat(value);\n\t      if (!isFinite(value) || !value && value !== 0) return '';\n\t      _currency = _currency != null ? _currency : '$';\n\t      var stringified = Math.abs(value).toFixed(2);\n\t      var _int = stringified.slice(0, -3);\n\t      var i = _int.length % 3;\n\t      var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\n\t      var _float = stringified.slice(-3);\n\t      var sign = value < 0 ? '-' : '';\n\t      return _currency + sign + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\n\t    },\n\t\n\t    /**\n\t     * 'item' => 'items'\n\t     *\n\t     * @params\n\t     *  an array of strings corresponding to\n\t     *  the single, double, triple ... forms of the word to\n\t     *  be pluralized. When the number to be pluralized\n\t     *  exceeds the length of the args, it will use the last\n\t     *  entry in the array.\n\t     *\n\t     *  e.g. ['single', 'double', 'triple', 'multiple']\n\t     */\n\t\n\t    pluralize: function pluralize(value) {\n\t      var args = toArray(arguments, 1);\n\t      return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');\n\t    },\n\t\n\t    /**\n\t     * Debounce a handler function.\n\t     *\n\t     * @param {Function} handler\n\t     * @param {Number} delay = 300\n\t     * @return {Function}\n\t     */\n\t\n\t    debounce: function debounce(handler, delay) {\n\t      if (!handler) return;\n\t      if (!delay) {\n\t        delay = 300;\n\t      }\n\t      return _debounce(handler, delay);\n\t    }\n\t  };\n\t\n\t  var partial = {\n\t\n\t    priority: PARTIAL,\n\t\n\t    params: ['name'],\n\t\n\t    // watch changes to name for dynamic partials\n\t    paramWatchers: {\n\t      name: function name(value) {\n\t        vIf.remove.call(this);\n\t        if (value) {\n\t          this.insert(value);\n\t        }\n\t      }\n\t    },\n\t\n\t    bind: function bind() {\n\t      this.anchor = createAnchor('v-partial');\n\t      replace(this.el, this.anchor);\n\t      this.insert(this.params.name);\n\t    },\n\t\n\t    insert: function insert(id) {\n\t      var partial = resolveAsset(this.vm.$options, 'partials', id);\n\t      if (true) {\n\t        assertAsset(partial, 'partial', id);\n\t      }\n\t      if (partial) {\n\t        this.factory = new FragmentFactory(this.vm, partial);\n\t        vIf.insert.call(this);\n\t      }\n\t    },\n\t\n\t    unbind: function unbind() {\n\t      if (this.frag) {\n\t        this.frag.destroy();\n\t      }\n\t    }\n\t  };\n\t\n\t  // This is the elementDirective that handles <content>\n\t  // transclusions. It relies on the raw content of an\n\t  // instance being stored as `$options._content` during\n\t  // the transclude phase.\n\t\n\t  // We are exporting two versions, one for named and one\n\t  // for unnamed, because the unnamed slots must be compiled\n\t  // AFTER all named slots have selected their content. So\n\t  // we need to give them different priorities in the compilation\n\t  // process. (See #1965)\n\t\n\t  var slot = {\n\t\n\t    priority: SLOT,\n\t\n\t    bind: function bind() {\n\t      var host = this.vm;\n\t      var raw = host.$options._content;\n\t      if (!raw) {\n\t        this.fallback();\n\t        return;\n\t      }\n\t      var context = host._context;\n\t      var slotName = this.params && this.params.name;\n\t      if (!slotName) {\n\t        // Default slot\n\t        this.tryCompile(extractFragment(raw.childNodes, raw, true), context, host);\n\t      } else {\n\t        // Named slot\n\t        var selector = '[slot=\"' + slotName + '\"]';\n\t        var nodes = raw.querySelectorAll(selector);\n\t        if (nodes.length) {\n\t          this.tryCompile(extractFragment(nodes, raw), context, host);\n\t        } else {\n\t          this.fallback();\n\t        }\n\t      }\n\t    },\n\t\n\t    tryCompile: function tryCompile(content, context, host) {\n\t      if (content.hasChildNodes()) {\n\t        this.compile(content, context, host);\n\t      } else {\n\t        this.fallback();\n\t      }\n\t    },\n\t\n\t    compile: function compile(content, context, host) {\n\t      if (content && context) {\n\t        var scope = host ? host._scope : this._scope;\n\t        this.unlink = context.$compile(content, host, scope, this._frag);\n\t      }\n\t      if (content) {\n\t        replace(this.el, content);\n\t      } else {\n\t        remove(this.el);\n\t      }\n\t    },\n\t\n\t    fallback: function fallback() {\n\t      this.compile(extractContent(this.el, true), this.vm);\n\t    },\n\t\n\t    unbind: function unbind() {\n\t      if (this.unlink) {\n\t        this.unlink();\n\t      }\n\t    }\n\t  };\n\t\n\t  var namedSlot = extend(extend({}, slot), {\n\t    priority: slot.priority + 1,\n\t    params: ['name']\n\t  });\n\t\n\t  /**\n\t   * Extract qualified content nodes from a node list.\n\t   *\n\t   * @param {NodeList} nodes\n\t   * @param {Element} parent\n\t   * @param {Boolean} main\n\t   * @return {DocumentFragment}\n\t   */\n\t\n\t  function extractFragment(nodes, parent, main) {\n\t    var frag = document.createDocumentFragment();\n\t    for (var i = 0, l = nodes.length; i < l; i++) {\n\t      var node = nodes[i];\n\t      // if this is the main outlet, we want to skip all\n\t      // previously selected nodes;\n\t      // otherwise, we want to mark the node as selected.\n\t      // clone the node so the original raw content remains\n\t      // intact. this ensures proper re-compilation in cases\n\t      // where the outlet is inside a conditional block\n\t      if (main && !node.__v_selected) {\n\t        append(node);\n\t      } else if (!main && node.parentNode === parent) {\n\t        node.__v_selected = true;\n\t        append(node);\n\t      }\n\t    }\n\t    return frag;\n\t\n\t    function append(node) {\n\t      if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\n\t        node = parseTemplate(node);\n\t      }\n\t      node = cloneNode(node);\n\t      frag.appendChild(node);\n\t    }\n\t  }\n\t\n\t  var elementDirectives = {\n\t    slot: slot,\n\t    _namedSlot: namedSlot, // same as slot but with higher priority\n\t    partial: partial\n\t  };\n\t\n\t  Vue.version = '1.0.14';\n\t\n\t  /**\n\t   * Vue and every constructor that extends Vue has an\n\t   * associated options object, which can be accessed during\n\t   * compilation steps as `this.constructor.options`.\n\t   *\n\t   * These can be seen as the default options of every\n\t   * Vue instance.\n\t   */\n\t\n\t  Vue.options = {\n\t    directives: publicDirectives,\n\t    elementDirectives: elementDirectives,\n\t    filters: filters,\n\t    transitions: {},\n\t    components: {},\n\t    partials: {},\n\t    replace: true\n\t  };\n\t\n\t  // devtools global hook\n\t  /* istanbul ignore if */\n\t  if ('development' !== 'production' && inBrowser) {\n\t    if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {\n\t      window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('init', Vue);\n\t    } else if (/Chrome\\/\\d+/.test(navigator.userAgent)) {\n\t      console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n\t    }\n\t  }\n\t\n\t  return Vue;\n\t\n\t}));\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar _typeof2 = __webpack_require__(18);\n\t\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t;(function () {\n\t\n\t  var block = {\n\t    newline: /^\\n+/,\n\t    code: /^( {4}[^\\n]+\\n*)+/,\n\t    fences: noop,\n\t    hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\n\t    heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\n\t    nptable: noop,\n\t    lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n\t    blockquote: /^( *>[^\\n]+(\\n(?!def)[^\\n]+)*\\n*)+/,\n\t    list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n\t    html: /^ *(?:comment *(?:\\n|\\s*$)|closed *(?:\\n{2,}|\\s*$)|closing *(?:\\n{2,}|\\s*$))/,\n\t    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\n\t    table: noop,\n\t    paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\n\t    text: /^[^\\n]+/\n\t  };\n\t\n\t  block.bullet = /(?:[*+-]|\\d+\\.)/;\n\t  block.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\n\t  block.item = replace(block.item, 'gm')(/bull/g, block.bullet)();\n\t\n\t  block.list = replace(block.list)(/bull/g, block.bullet)('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')('def', '\\\\n+(?=' + block.def.source + ')')();\n\t\n\t  block.blockquote = replace(block.blockquote)('def', block.def)();\n\t\n\t  block._tag = '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code' + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo' + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\n\t\n\t  block.html = replace(block.html)('comment', /<!--[\\s\\S]*?-->/)('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)(/tag/g, block._tag)();\n\t\n\t  block.paragraph = replace(block.paragraph)('hr', block.hr)('heading', block.heading)('lheading', block.lheading)('blockquote', block.blockquote)('tag', '<' + block._tag)('def', block.def)();\n\t\n\t  block.normal = merge({}, block);\n\t\n\t  block.gfm = merge({}, block.normal, {\n\t    fences: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/,\n\t    paragraph: /^/,\n\t    heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/\n\t  });\n\t\n\t  block.gfm.paragraph = replace(block.paragraph)('(?!', '(?!' + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|' + block.list.source.replace('\\\\1', '\\\\3') + '|')();\n\t\n\t  block.tables = merge({}, block.gfm, {\n\t    nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n\t    table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\n\t  });\n\t\n\t  function Lexer(options) {\n\t    this.tokens = [];\n\t    this.tokens.links = {};\n\t    this.options = options || marked.defaults;\n\t    this.rules = block.normal;\n\t\n\t    if (this.options.gfm) {\n\t      if (this.options.tables) {\n\t        this.rules = block.tables;\n\t      } else {\n\t        this.rules = block.gfm;\n\t      }\n\t    }\n\t  }\n\t\n\t  Lexer.rules = block;\n\t\n\t  Lexer.lex = function (src, options) {\n\t    var lexer = new Lexer(options);\n\t    return lexer.lex(src);\n\t  };\n\t\n\t  Lexer.prototype.lex = function (src) {\n\t    src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ').replace(/\\u00a0/g, ' ').replace(/\\u2424/g, '\\n');\n\t\n\t    return this.token(src, true);\n\t  };\n\t\n\t  Lexer.prototype.token = function (src, top, bq) {\n\t    var src = src.replace(/^ +$/gm, ''),\n\t        next,\n\t        loose,\n\t        cap,\n\t        bull,\n\t        b,\n\t        item,\n\t        space,\n\t        i,\n\t        l;\n\t\n\t    while (src) {\n\t      if (cap = this.rules.newline.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        if (cap[0].length > 1) {\n\t          this.tokens.push({\n\t            type: 'space'\n\t          });\n\t        }\n\t      }\n\t\n\t      if (cap = this.rules.code.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        cap = cap[0].replace(/^ {4}/gm, '');\n\t        this.tokens.push({\n\t          type: 'code',\n\t          text: !this.options.pedantic ? cap.replace(/\\n+$/, '') : cap\n\t        });\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.fences.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        this.tokens.push({\n\t          type: 'code',\n\t          lang: cap[2],\n\t          text: cap[3] || ''\n\t        });\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.heading.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        this.tokens.push({\n\t          type: 'heading',\n\t          depth: cap[1].length,\n\t          text: cap[2]\n\t        });\n\t        continue;\n\t      }\n\t\n\t      if (top && (cap = this.rules.nptable.exec(src))) {\n\t        src = src.substring(cap[0].length);\n\t\n\t        item = {\n\t          type: 'table',\n\t          header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n\t          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n\t          cells: cap[3].replace(/\\n$/, '').split('\\n')\n\t        };\n\t\n\t        for (i = 0; i < item.align.length; i++) {\n\t          if (/^ *-+: *$/.test(item.align[i])) {\n\t            item.align[i] = 'right';\n\t          } else if (/^ *:-+: *$/.test(item.align[i])) {\n\t            item.align[i] = 'center';\n\t          } else if (/^ *:-+ *$/.test(item.align[i])) {\n\t            item.align[i] = 'left';\n\t          } else {\n\t            item.align[i] = null;\n\t          }\n\t        }\n\t\n\t        for (i = 0; i < item.cells.length; i++) {\n\t          item.cells[i] = item.cells[i].split(/ *\\| */);\n\t        }\n\t\n\t        this.tokens.push(item);\n\t\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.lheading.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        this.tokens.push({\n\t          type: 'heading',\n\t          depth: cap[2] === '=' ? 1 : 2,\n\t          text: cap[1]\n\t        });\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.hr.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        this.tokens.push({\n\t          type: 'hr'\n\t        });\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.blockquote.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t\n\t        this.tokens.push({\n\t          type: 'blockquote_start'\n\t        });\n\t\n\t        cap = cap[0].replace(/^ *> ?/gm, '');\n\t\n\t        this.token(cap, top, true);\n\t\n\t        this.tokens.push({\n\t          type: 'blockquote_end'\n\t        });\n\t\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.list.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        bull = cap[2];\n\t\n\t        this.tokens.push({\n\t          type: 'list_start',\n\t          ordered: bull.length > 1\n\t        });\n\t\n\t        cap = cap[0].match(this.rules.item);\n\t\n\t        next = false;\n\t        l = cap.length;\n\t        i = 0;\n\t\n\t        for (; i < l; i++) {\n\t          item = cap[i];\n\t\n\t          space = item.length;\n\t          item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\t\n\t          if (~item.indexOf('\\n ')) {\n\t            space -= item.length;\n\t            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');\n\t          }\n\t\n\t          if (this.options.smartLists && i !== l - 1) {\n\t            b = block.bullet.exec(cap[i + 1])[0];\n\t            if (bull !== b && !(bull.length > 1 && b.length > 1)) {\n\t              src = cap.slice(i + 1).join('\\n') + src;\n\t              i = l - 1;\n\t            }\n\t          }\n\t\n\t          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n\t          if (i !== l - 1) {\n\t            next = item.charAt(item.length - 1) === '\\n';\n\t            if (!loose) loose = next;\n\t          }\n\t\n\t          this.tokens.push({\n\t            type: loose ? 'loose_item_start' : 'list_item_start'\n\t          });\n\t\n\t          this.token(item, false, bq);\n\t\n\t          this.tokens.push({\n\t            type: 'list_item_end'\n\t          });\n\t        }\n\t\n\t        this.tokens.push({\n\t          type: 'list_end'\n\t        });\n\t\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.html.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        this.tokens.push({\n\t          type: this.options.sanitize ? 'paragraph' : 'html',\n\t          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n\t          text: cap[0]\n\t        });\n\t        continue;\n\t      }\n\t\n\t      if (!bq && top && (cap = this.rules.def.exec(src))) {\n\t        src = src.substring(cap[0].length);\n\t        this.tokens.links[cap[1].toLowerCase()] = {\n\t          href: cap[2],\n\t          title: cap[3]\n\t        };\n\t        continue;\n\t      }\n\t\n\t      if (top && (cap = this.rules.table.exec(src))) {\n\t        src = src.substring(cap[0].length);\n\t\n\t        item = {\n\t          type: 'table',\n\t          header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n\t          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n\t          cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\n\t        };\n\t\n\t        for (i = 0; i < item.align.length; i++) {\n\t          if (/^ *-+: *$/.test(item.align[i])) {\n\t            item.align[i] = 'right';\n\t          } else if (/^ *:-+: *$/.test(item.align[i])) {\n\t            item.align[i] = 'center';\n\t          } else if (/^ *:-+ *$/.test(item.align[i])) {\n\t            item.align[i] = 'left';\n\t          } else {\n\t            item.align[i] = null;\n\t          }\n\t        }\n\t\n\t        for (i = 0; i < item.cells.length; i++) {\n\t          item.cells[i] = item.cells[i].replace(/^ *\\| *| *\\| *$/g, '').split(/ *\\| */);\n\t        }\n\t\n\t        this.tokens.push(item);\n\t\n\t        continue;\n\t      }\n\t\n\t      if (top && (cap = this.rules.paragraph.exec(src))) {\n\t        src = src.substring(cap[0].length);\n\t        this.tokens.push({\n\t          type: 'paragraph',\n\t          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1]\n\t        });\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.text.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        this.tokens.push({\n\t          type: 'text',\n\t          text: cap[0]\n\t        });\n\t        continue;\n\t      }\n\t\n\t      if (src) {\n\t        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n\t      }\n\t    }\n\t\n\t    return this.tokens;\n\t  };\n\t\n\t  var inline = {\n\t    escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\n\t    autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\n\t    url: noop,\n\t    tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\n\t    link: /^!?\\[(inside)\\]\\(href\\)/,\n\t    reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\n\t    nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\n\t    strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\n\t    em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n\t    code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n\t    br: /^ {2,}\\n(?!\\s*$)/,\n\t    del: noop,\n\t    text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\n\t  };\n\t\n\t  inline._inside = /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/;\n\t  inline._href = /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\n\t\n\t  inline.link = replace(inline.link)('inside', inline._inside)('href', inline._href)();\n\t\n\t  inline.reflink = replace(inline.reflink)('inside', inline._inside)();\n\t\n\t  inline.normal = merge({}, inline);\n\t\n\t  inline.pedantic = merge({}, inline.normal, {\n\t    strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n\t    em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\n\t  });\n\t\n\t  inline.gfm = merge({}, inline.normal, {\n\t    escape: replace(inline.escape)('])', '~|])')(),\n\t    url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n\t    del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n\t    text: replace(inline.text)(']|', '~]|')('|', '|https?://|')()\n\t  });\n\t\n\t  inline.breaks = merge({}, inline.gfm, {\n\t    br: replace(inline.br)('{2,}', '*')(),\n\t    text: replace(inline.gfm.text)('{2,}', '*')()\n\t  });\n\t\n\t  function InlineLexer(links, options) {\n\t    this.options = options || marked.defaults;\n\t    this.links = links;\n\t    this.rules = inline.normal;\n\t    this.renderer = this.options.renderer || new Renderer();\n\t    this.renderer.options = this.options;\n\t\n\t    if (!this.links) {\n\t      throw new Error('Tokens array requires a `links` property.');\n\t    }\n\t\n\t    if (this.options.gfm) {\n\t      if (this.options.breaks) {\n\t        this.rules = inline.breaks;\n\t      } else {\n\t        this.rules = inline.gfm;\n\t      }\n\t    } else if (this.options.pedantic) {\n\t      this.rules = inline.pedantic;\n\t    }\n\t  }\n\t\n\t  InlineLexer.rules = inline;\n\t\n\t  InlineLexer.output = function (src, links, options) {\n\t    var inline = new InlineLexer(links, options);\n\t    return inline.output(src);\n\t  };\n\t\n\t  InlineLexer.prototype.output = function (src) {\n\t    var out = '',\n\t        link,\n\t        text,\n\t        href,\n\t        cap;\n\t\n\t    while (src) {\n\t      if (cap = this.rules.escape.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        out += cap[1];\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.autolink.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        if (cap[2] === '@') {\n\t          text = cap[1].charAt(6) === ':' ? this.mangle(cap[1].substring(7)) : this.mangle(cap[1]);\n\t          href = this.mangle('mailto:') + text;\n\t        } else {\n\t          text = escape(cap[1]);\n\t          href = text;\n\t        }\n\t        out += this.renderer.link(href, null, text);\n\t        continue;\n\t      }\n\t\n\t      if (!this.inLink && (cap = this.rules.url.exec(src))) {\n\t        src = src.substring(cap[0].length);\n\t        text = escape(cap[1]);\n\t        href = text;\n\t        out += this.renderer.link(href, null, text);\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.tag.exec(src)) {\n\t        if (!this.inLink && /^<a /i.test(cap[0])) {\n\t          this.inLink = true;\n\t        } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\n\t          this.inLink = false;\n\t        }\n\t        src = src.substring(cap[0].length);\n\t        out += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.link.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        this.inLink = true;\n\t        out += this.outputLink(cap, {\n\t          href: cap[2],\n\t          title: cap[3]\n\t        });\n\t        this.inLink = false;\n\t        continue;\n\t      }\n\t\n\t      if ((cap = this.rules.reflink.exec(src)) || (cap = this.rules.nolink.exec(src))) {\n\t        src = src.substring(cap[0].length);\n\t        link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n\t        link = this.links[link.toLowerCase()];\n\t        if (!link || !link.href) {\n\t          out += cap[0].charAt(0);\n\t          src = cap[0].substring(1) + src;\n\t          continue;\n\t        }\n\t        this.inLink = true;\n\t        out += this.outputLink(cap, link);\n\t        this.inLink = false;\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.strong.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        out += this.renderer.strong(this.output(cap[2] || cap[1]));\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.em.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        out += this.renderer.em(this.output(cap[2] || cap[1]));\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.code.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        out += this.renderer.codespan(escape(cap[2], true));\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.br.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        out += this.renderer.br();\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.del.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        out += this.renderer.del(this.output(cap[1]));\n\t        continue;\n\t      }\n\t\n\t      if (cap = this.rules.text.exec(src)) {\n\t        src = src.substring(cap[0].length);\n\t        out += this.renderer.text(escape(this.smartypants(cap[0])));\n\t        continue;\n\t      }\n\t\n\t      if (src) {\n\t        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n\t      }\n\t    }\n\t\n\t    return out;\n\t  };\n\t\n\t  InlineLexer.prototype.outputLink = function (cap, link) {\n\t    var href = escape(link.href),\n\t        title = link.title ? escape(link.title) : null;\n\t\n\t    return cap[0].charAt(0) !== '!' ? this.renderer.link(href, title, this.output(cap[1])) : this.renderer.image(href, title, escape(cap[1]));\n\t  };\n\t\n\t  InlineLexer.prototype.smartypants = function (text) {\n\t    if (!this.options.smartypants) return text;\n\t    return text.replace(/---/g, '—').replace(/--/g, '–').replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1‘').replace(/'/g, '’').replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1“').replace(/\"/g, '”').replace(/\\.{3}/g, '…');\n\t  };\n\t\n\t  InlineLexer.prototype.mangle = function (text) {\n\t    if (!this.options.mangle) return text;\n\t    var out = '',\n\t        l = text.length,\n\t        i = 0,\n\t        ch;\n\t\n\t    for (; i < l; i++) {\n\t      ch = text.charCodeAt(i);\n\t      if (Math.random() > 0.5) {\n\t        ch = 'x' + ch.toString(16);\n\t      }\n\t      out += '&#' + ch + ';';\n\t    }\n\t\n\t    return out;\n\t  };\n\t\n\t  function Renderer(options) {\n\t    this.options = options || {};\n\t  }\n\t\n\t  Renderer.prototype.code = function (code, lang, escaped) {\n\t    if (this.options.highlight) {\n\t      var out = this.options.highlight(code, lang);\n\t      if (out != null && out !== code) {\n\t        escaped = true;\n\t        code = out;\n\t      }\n\t    }\n\t\n\t    if (!lang) {\n\t      return '<pre><code>' + (escaped ? code : escape(code, true)) + '\\n</code></pre>';\n\t    }\n\t\n\t    return '<pre><code class=\"' + this.options.langPrefix + escape(lang, true) + '\">' + (escaped ? code : escape(code, true)) + '\\n</code></pre>\\n';\n\t  };\n\t\n\t  Renderer.prototype.blockquote = function (quote) {\n\t    return '<blockquote>\\n' + quote + '</blockquote>\\n';\n\t  };\n\t\n\t  Renderer.prototype.html = function (html) {\n\t    return html;\n\t  };\n\t\n\t  Renderer.prototype.heading = function (text, level, raw) {\n\t    return '<h' + level + ' id=\"' + this.options.headerPrefix + raw.toLowerCase().replace(/[^\\w]+/g, '-') + '\">' + text + '</h' + level + '>\\n';\n\t  };\n\t\n\t  Renderer.prototype.hr = function () {\n\t    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n\t  };\n\t\n\t  Renderer.prototype.list = function (body, ordered) {\n\t    var type = ordered ? 'ol' : 'ul';\n\t    return '<' + type + '>\\n' + body + '</' + type + '>\\n';\n\t  };\n\t\n\t  Renderer.prototype.listitem = function (text) {\n\t    return '<li>' + text + '</li>\\n';\n\t  };\n\t\n\t  Renderer.prototype.paragraph = function (text) {\n\t    return '<p>' + text + '</p>\\n';\n\t  };\n\t\n\t  Renderer.prototype.table = function (header, body) {\n\t    return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + '<tbody>\\n' + body + '</tbody>\\n' + '</table>\\n';\n\t  };\n\t\n\t  Renderer.prototype.tablerow = function (content) {\n\t    return '<tr>\\n' + content + '</tr>\\n';\n\t  };\n\t\n\t  Renderer.prototype.tablecell = function (content, flags) {\n\t    var type = flags.header ? 'th' : 'td';\n\t    var tag = flags.align ? '<' + type + ' style=\"text-align:' + flags.align + '\">' : '<' + type + '>';\n\t    return tag + content + '</' + type + '>\\n';\n\t  };\n\t\n\t  Renderer.prototype.strong = function (text) {\n\t    return '<strong>' + text + '</strong>';\n\t  };\n\t\n\t  Renderer.prototype.em = function (text) {\n\t    return '<em>' + text + '</em>';\n\t  };\n\t\n\t  Renderer.prototype.codespan = function (text) {\n\t    return '<code>' + text + '</code>';\n\t  };\n\t\n\t  Renderer.prototype.br = function () {\n\t    return this.options.xhtml ? '<br/>' : '<br>';\n\t  };\n\t\n\t  Renderer.prototype.del = function (text) {\n\t    return '<del>' + text + '</del>';\n\t  };\n\t\n\t  Renderer.prototype.link = function (href, title, text) {\n\t    if (this.options.sanitize) {\n\t      try {\n\t        var prot = decodeURIComponent(unescape(href)).replace(/[^\\w:]/g, '').toLowerCase();\n\t      } catch (e) {\n\t        return '';\n\t      }\n\t      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {\n\t        return '';\n\t      }\n\t    }\n\t    var out = '<a href=\"' + href + '\"';\n\t    if (title) {\n\t      out += ' title=\"' + title + '\"';\n\t    }\n\t    out += '>' + text + '</a>';\n\t    return out;\n\t  };\n\t\n\t  Renderer.prototype.image = function (href, title, text) {\n\t    var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\t    if (title) {\n\t      out += ' title=\"' + title + '\"';\n\t    }\n\t    out += this.options.xhtml ? '/>' : '>';\n\t    return out;\n\t  };\n\t\n\t  Renderer.prototype.text = function (text) {\n\t    return text;\n\t  };\n\t\n\t  function Parser(options) {\n\t    this.tokens = [];\n\t    this.token = null;\n\t    this.options = options || marked.defaults;\n\t    this.options.renderer = this.options.renderer || new Renderer();\n\t    this.renderer = this.options.renderer;\n\t    this.renderer.options = this.options;\n\t  }\n\t\n\t  Parser.parse = function (src, options, renderer) {\n\t    var parser = new Parser(options, renderer);\n\t    return parser.parse(src);\n\t  };\n\t\n\t  Parser.prototype.parse = function (src) {\n\t    this.inline = new InlineLexer(src.links, this.options, this.renderer);\n\t    this.tokens = src.reverse();\n\t\n\t    var out = '';\n\t    while (this.next()) {\n\t      out += this.tok();\n\t    }\n\t\n\t    return out;\n\t  };\n\t\n\t  Parser.prototype.next = function () {\n\t    return this.token = this.tokens.pop();\n\t  };\n\t\n\t  Parser.prototype.peek = function () {\n\t    return this.tokens[this.tokens.length - 1] || 0;\n\t  };\n\t\n\t  Parser.prototype.parseText = function () {\n\t    var body = this.token.text;\n\t\n\t    while (this.peek().type === 'text') {\n\t      body += '\\n' + this.next().text;\n\t    }\n\t\n\t    return this.inline.output(body);\n\t  };\n\t\n\t  Parser.prototype.tok = function () {\n\t    switch (this.token.type) {\n\t      case 'space':\n\t        {\n\t          return '';\n\t        }\n\t      case 'hr':\n\t        {\n\t          return this.renderer.hr();\n\t        }\n\t      case 'heading':\n\t        {\n\t          return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, this.token.text);\n\t        }\n\t      case 'code':\n\t        {\n\t          return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);\n\t        }\n\t      case 'table':\n\t        {\n\t          var header = '',\n\t              body = '',\n\t              i,\n\t              row,\n\t              cell,\n\t              flags,\n\t              j;\n\t\n\t          cell = '';\n\t          for (i = 0; i < this.token.header.length; i++) {\n\t            flags = { header: true, align: this.token.align[i] };\n\t            cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), { header: true, align: this.token.align[i] });\n\t          }\n\t          header += this.renderer.tablerow(cell);\n\t\n\t          for (i = 0; i < this.token.cells.length; i++) {\n\t            row = this.token.cells[i];\n\t\n\t            cell = '';\n\t            for (j = 0; j < row.length; j++) {\n\t              cell += this.renderer.tablecell(this.inline.output(row[j]), { header: false, align: this.token.align[j] });\n\t            }\n\t\n\t            body += this.renderer.tablerow(cell);\n\t          }\n\t          return this.renderer.table(header, body);\n\t        }\n\t      case 'blockquote_start':\n\t        {\n\t          var body = '';\n\t\n\t          while (this.next().type !== 'blockquote_end') {\n\t            body += this.tok();\n\t          }\n\t\n\t          return this.renderer.blockquote(body);\n\t        }\n\t      case 'list_start':\n\t        {\n\t          var body = '',\n\t              ordered = this.token.ordered;\n\t\n\t          while (this.next().type !== 'list_end') {\n\t            body += this.tok();\n\t          }\n\t\n\t          return this.renderer.list(body, ordered);\n\t        }\n\t      case 'list_item_start':\n\t        {\n\t          var body = '';\n\t\n\t          while (this.next().type !== 'list_item_end') {\n\t            body += this.token.type === 'text' ? this.parseText() : this.tok();\n\t          }\n\t\n\t          return this.renderer.listitem(body);\n\t        }\n\t      case 'loose_item_start':\n\t        {\n\t          var body = '';\n\t\n\t          while (this.next().type !== 'list_item_end') {\n\t            body += this.tok();\n\t          }\n\t\n\t          return this.renderer.listitem(body);\n\t        }\n\t      case 'html':\n\t        {\n\t          var html = !this.token.pre && !this.options.pedantic ? this.inline.output(this.token.text) : this.token.text;\n\t          return this.renderer.html(html);\n\t        }\n\t      case 'paragraph':\n\t        {\n\t          return this.renderer.paragraph(this.inline.output(this.token.text));\n\t        }\n\t      case 'text':\n\t        {\n\t          return this.renderer.paragraph(this.parseText());\n\t        }\n\t    }\n\t  };\n\t\n\t  function escape(html, encode) {\n\t    return html.replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n\t  }\n\t\n\t  function unescape(html) {\n\t    return html.replace(/&([#\\w]+);/g, function (_, n) {\n\t      n = n.toLowerCase();\n\t      if (n === 'colon') return ':';\n\t      if (n.charAt(0) === '#') {\n\t        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n\t      }\n\t      return '';\n\t    });\n\t  }\n\t\n\t  function replace(regex, opt) {\n\t    regex = regex.source;\n\t    opt = opt || '';\n\t    return function self(name, val) {\n\t      if (!name) return new RegExp(regex, opt);\n\t      val = val.source || val;\n\t      val = val.replace(/(^|[^\\[])\\^/g, '$1');\n\t      regex = regex.replace(name, val);\n\t      return self;\n\t    };\n\t  }\n\t\n\t  function noop() {}\n\t  noop.exec = noop;\n\t\n\t  function merge(obj) {\n\t    var i = 1,\n\t        target,\n\t        key;\n\t\n\t    for (; i < arguments.length; i++) {\n\t      target = arguments[i];\n\t      for (key in target) {\n\t        if (Object.prototype.hasOwnProperty.call(target, key)) {\n\t          obj[key] = target[key];\n\t        }\n\t      }\n\t    }\n\t\n\t    return obj;\n\t  }\n\t\n\t  function marked(src, opt, callback) {\n\t    if (callback || typeof opt === 'function') {\n\t      if (!callback) {\n\t        callback = opt;\n\t        opt = null;\n\t      }\n\t\n\t      opt = merge({}, marked.defaults, opt || {});\n\t\n\t      var highlight = opt.highlight,\n\t          tokens,\n\t          pending,\n\t          i = 0;\n\t\n\t      try {\n\t        tokens = Lexer.lex(src, opt);\n\t      } catch (e) {\n\t        return callback(e);\n\t      }\n\t\n\t      pending = tokens.length;\n\t\n\t      var done = function done(err) {\n\t        if (err) {\n\t          opt.highlight = highlight;\n\t          return callback(err);\n\t        }\n\t\n\t        var out;\n\t\n\t        try {\n\t          out = Parser.parse(tokens, opt);\n\t        } catch (e) {\n\t          err = e;\n\t        }\n\t\n\t        opt.highlight = highlight;\n\t\n\t        return err ? callback(err) : callback(null, out);\n\t      };\n\t\n\t      if (!highlight || highlight.length < 3) {\n\t        return done();\n\t      }\n\t\n\t      delete opt.highlight;\n\t\n\t      if (!pending) return done();\n\t\n\t      for (; i < tokens.length; i++) {\n\t        (function (token) {\n\t          if (token.type !== 'code') {\n\t            return --pending || done();\n\t          }\n\t          return highlight(token.text, token.lang, function (err, code) {\n\t            if (err) return done(err);\n\t            if (code == null || code === token.text) {\n\t              return --pending || done();\n\t            }\n\t            token.text = code;\n\t            token.escaped = true;\n\t            --pending || done();\n\t          });\n\t        })(tokens[i]);\n\t      }\n\t\n\t      return;\n\t    }\n\t    try {\n\t      if (opt) opt = merge({}, marked.defaults, opt);\n\t      return Parser.parse(Lexer.lex(src, opt), opt);\n\t    } catch (e) {\n\t      e.message += '\\nPlease report this to https://github.com/chjj/marked.';\n\t      if ((opt || marked.defaults).silent) {\n\t        return '<p>An error occured:</p><pre>' + escape(e.message + '', true) + '</pre>';\n\t      }\n\t      throw e;\n\t    }\n\t  }\n\t\n\t  marked.options = marked.setOptions = function (opt) {\n\t    merge(marked.defaults, opt);\n\t    return marked;\n\t  };\n\t\n\t  marked.defaults = {\n\t    gfm: true,\n\t    tables: true,\n\t    breaks: false,\n\t    pedantic: false,\n\t    sanitize: false,\n\t    sanitizer: null,\n\t    mangle: true,\n\t    smartLists: false,\n\t    silent: false,\n\t    highlight: null,\n\t    langPrefix: 'lang-',\n\t    smartypants: false,\n\t    headerPrefix: '',\n\t    renderer: new Renderer(),\n\t    xhtml: false\n\t  };\n\t\n\t  marked.Parser = Parser;\n\t  marked.parser = Parser.parse;\n\t\n\t  marked.Renderer = Renderer;\n\t\n\t  marked.Lexer = Lexer;\n\t  marked.lexer = Lexer.lex;\n\t\n\t  marked.InlineLexer = InlineLexer;\n\t  marked.inlineLexer = InlineLexer.output;\n\t\n\t  marked.parse = marked;\n\t\n\t  if (typeof module !== 'undefined' && ( false ? 'undefined' : (0, _typeof3.default)(exports)) === 'object') {\n\t    module.exports = marked;\n\t  } else if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t      return marked;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else {\n\t    this.marked = marked;\n\t  }\n\t}).call(function () {\n\t  return this || (typeof window !== 'undefined' ? window : global);\n\t}());\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _vue = __webpack_require__(13);\n\t\n\tvar _vue2 = _interopRequireDefault(_vue);\n\t\n\tvar _marked = __webpack_require__(14);\n\t\n\tvar _marked2 = _interopRequireDefault(_marked);\n\t\n\tvar _toolbox = __webpack_require__(41);\n\t\n\tvar _toolbox2 = _interopRequireDefault(_toolbox);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_vue2.default.filter('markify', function (val) {\n\t  return (0, _marked2.default)(val);\n\t});\n\t\n\texports.default = {\n\t  data: function data() {\n\t    return {\n\t      article: '',\n\t      htmlDataUrl: '',\n\t      mdDataUrl: ''\n\t    };\n\t  },\n\t  ready: function ready() {\n\t    var self = this;\n\t    (function () {\n\t      var dropbox;\n\t      dropbox = document.getElementById(\"inputter\");\n\t      dropbox.addEventListener(\"dragenter\", dragenter, false);\n\t      dropbox.addEventListener(\"dragover\", dragover, false);\n\t      dropbox.addEventListener(\"drop\", drop, false);\n\t      function dragenter(e) {\n\t        e.stopPropagation();\n\t        e.preventDefault();\n\t      }\n\t\n\t      function dragover(e) {\n\t        e.stopPropagation();\n\t        e.preventDefault();\n\t      }\n\t\n\t      function drop(e) {\n\t        e.stopPropagation();\n\t        e.preventDefault();\n\t\n\t        var dt = e.dataTransfer;\n\t        var files = dt.files;\n\t\n\t        var fileReader = new FileReader();\n\t        fileReader.readAsText(files[0], 'UTF-8');\n\t        fileReader.onloadend = function (e) {\n\t          self.article = e.target.result;\n\t        };\n\t      }\n\t    })();\n\t  },\n\t  computed: {\n\t    outputHtml: function outputHtml() {\n\t      return (0, _marked2.default)(this.article);\n\t    }\n\t  },\n\t  components: {\n\t    toolbox: _toolbox2.default\n\t  },\n\t  methods: {\n\t    save: function save() {\n\t      localStorage.article = this.article;\n\t      swal('本地缓存成功', '请勿清空浏览器信息', 'success');\n\t    },\n\t    read: function read() {\n\t      this.article = localStorage.article;\n\t    },\n\t    createUrl: function createUrl(mode) {\n\t      var self = this;\n\t      var val = '';\n\t      if (mode == 0) {\n\t        val = self.article;\n\t        var blobObj = new Blob([val]);\n\t        var objectURL = URL.createObjectURL(blobObj);\n\t        self.mdDataUrl = objectURL;\n\t      } else {\n\t        val = self.outputHtml;\n\t        var blobObj = new Blob([val]);\n\t        var objectURL = URL.createObjectURL(blobObj);\n\t        self.htmlDataUrl = objectURL;\n\t      }\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  methods: {\n\t    insert: function insert(myValue) {\n\t      var myField = document.getElementById('inputter');\n\t      if (document.selection) {\n\t        myField.focus();\n\t        sel = document.selection.createRange();\n\t        sel.text = myValue;\n\t        sel.select();\n\t      } else if (myField.selectionStart || myField.selectionStart == '0') {\n\t          var startPos = myField.selectionStart;\n\t          var endPos = myField.selectionEnd;\n\t\n\t          var restoreTop = myField.scrollTop;\n\t          myField.value = myField.value.substring(0, startPos) + myValue + myField.value.substring(endPos, myField.value.length);\n\t          if (restoreTop > 0) {\n\t            myField.scrollTop = restoreTop;\n\t          }\n\t          myField.focus();\n\t          myField.selectionStart = startPos + myValue.length;\n\t          myField.selectionEnd = startPos + myValue.length;\n\t        } else {\n\t          myField.value += myValue;\n\t          myField.focus();\n\t        }\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(19), __esModule: true };\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _Symbol = __webpack_require__(17)[\"default\"];\n\t\n\texports[\"default\"] = function (obj) {\n\t  return obj && obj.constructor === _Symbol ? \"symbol\" : typeof obj;\n\t};\n\t\n\texports.__esModule = true;\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(36);\n\t__webpack_require__(35);\n\tmodule.exports = __webpack_require__(5).Symbol;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(30);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(20);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// all enumerable object keys, includes symbols\n\tvar $ = __webpack_require__(1);\n\tmodule.exports = function(it){\n\t  var keys       = $.getKeys(it)\n\t    , getSymbols = $.getSymbols;\n\t  if(getSymbols){\n\t    var symbols = getSymbols(it)\n\t      , isEnum  = $.isEnum\n\t      , i       = 0\n\t      , key;\n\t    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);\n\t  }\n\t  return keys;\n\t};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(2)\n\t  , core      = __webpack_require__(5)\n\t  , ctx       = __webpack_require__(22)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && key in target;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(param){\n\t        return this instanceof C ? new C(param) : C(param);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;  // forced\n\t$export.G = 2;  // global\n\t$export.S = 4;  // static\n\t$export.P = 8;  // proto\n\t$export.B = 16; // bind\n\t$export.W = 32; // wrap\n\tmodule.exports = $export;\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar toIObject = __webpack_require__(3)\n\t  , getNames  = __webpack_require__(1).getNames\n\t  , toString  = {}.toString;\n\t\n\tvar windowNames = typeof window == 'object' && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\t\n\tvar getWindowNames = function(it){\n\t  try {\n\t    return getNames(it);\n\t  } catch(e){\n\t    return windowNames.slice();\n\t  }\n\t};\n\t\n\tmodule.exports.get = function getOwnPropertyNames(it){\n\t  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);\n\t  return getNames(toIObject(it));\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $          = __webpack_require__(1)\n\t  , createDesc = __webpack_require__(9);\n\tmodule.exports = __webpack_require__(6) ? function(object, key, value){\n\t  return $.setDesc(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(4);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.2.2 IsArray(argument)\n\tvar cof = __webpack_require__(4);\n\tmodule.exports = Array.isArray || function(arg){\n\t  return cof(arg) == 'Array';\n\t};\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $         = __webpack_require__(1)\n\t  , toIObject = __webpack_require__(3);\n\tmodule.exports = function(object, el){\n\t  var O      = toIObject(object)\n\t    , keys   = $.getKeys(O)\n\t    , length = keys.length\n\t    , index  = 0\n\t    , key;\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(27);\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(1).setDesc\n\t  , has = __webpack_require__(8)\n\t  , TAG = __webpack_require__(12)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// ECMAScript 6 symbols shim\n\tvar $              = __webpack_require__(1)\n\t  , global         = __webpack_require__(2)\n\t  , has            = __webpack_require__(8)\n\t  , DESCRIPTORS    = __webpack_require__(6)\n\t  , $export        = __webpack_require__(25)\n\t  , redefine       = __webpack_require__(33)\n\t  , $fails         = __webpack_require__(7)\n\t  , shared         = __webpack_require__(10)\n\t  , setToStringTag = __webpack_require__(34)\n\t  , uid            = __webpack_require__(11)\n\t  , wks            = __webpack_require__(12)\n\t  , keyOf          = __webpack_require__(31)\n\t  , $names         = __webpack_require__(26)\n\t  , enumKeys       = __webpack_require__(24)\n\t  , isArray        = __webpack_require__(29)\n\t  , anObject       = __webpack_require__(21)\n\t  , toIObject      = __webpack_require__(3)\n\t  , createDesc     = __webpack_require__(9)\n\t  , getDesc        = $.getDesc\n\t  , setDesc        = $.setDesc\n\t  , _create        = $.create\n\t  , getNames       = $names.get\n\t  , $Symbol        = global.Symbol\n\t  , $JSON          = global.JSON\n\t  , _stringify     = $JSON && $JSON.stringify\n\t  , setter         = false\n\t  , HIDDEN         = wks('_hidden')\n\t  , isEnum         = $.isEnum\n\t  , SymbolRegistry = shared('symbol-registry')\n\t  , AllSymbols     = shared('symbols')\n\t  , useNative      = typeof $Symbol == 'function'\n\t  , ObjectProto    = Object.prototype;\n\t\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n\t  return _create(setDesc({}, 'a', {\n\t    get: function(){ return setDesc(this, 'a', {value: 7}).a; }\n\t  })).a != 7;\n\t}) ? function(it, key, D){\n\t  var protoDesc = getDesc(ObjectProto, key);\n\t  if(protoDesc)delete ObjectProto[key];\n\t  setDesc(it, key, D);\n\t  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);\n\t} : setDesc;\n\t\n\tvar wrap = function(tag){\n\t  var sym = AllSymbols[tag] = _create($Symbol.prototype);\n\t  sym._k = tag;\n\t  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {\n\t    configurable: true,\n\t    set: function(value){\n\t      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n\t      setSymbolDesc(this, tag, createDesc(1, value));\n\t    }\n\t  });\n\t  return sym;\n\t};\n\t\n\tvar isSymbol = function(it){\n\t  return typeof it == 'symbol';\n\t};\n\t\n\tvar $defineProperty = function defineProperty(it, key, D){\n\t  if(D && has(AllSymbols, key)){\n\t    if(!D.enumerable){\n\t      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));\n\t      it[HIDDEN][key] = true;\n\t    } else {\n\t      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n\t      D = _create(D, {enumerable: createDesc(0, false)});\n\t    } return setSymbolDesc(it, key, D);\n\t  } return setDesc(it, key, D);\n\t};\n\tvar $defineProperties = function defineProperties(it, P){\n\t  anObject(it);\n\t  var keys = enumKeys(P = toIObject(P))\n\t    , i    = 0\n\t    , l = keys.length\n\t    , key;\n\t  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n\t  return it;\n\t};\n\tvar $create = function create(it, P){\n\t  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n\t};\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n\t  var E = isEnum.call(this, key);\n\t  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]\n\t    ? E : true;\n\t};\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n\t  var D = getDesc(it = toIObject(it), key);\n\t  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n\t  return D;\n\t};\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n\t  var names  = getNames(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);\n\t  return result;\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n\t  var names  = getNames(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);\n\t  return result;\n\t};\n\tvar $stringify = function stringify(it){\n\t  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n\t  var args = [it]\n\t    , i    = 1\n\t    , $$   = arguments\n\t    , replacer, $replacer;\n\t  while($$.length > i)args.push($$[i++]);\n\t  replacer = args[1];\n\t  if(typeof replacer == 'function')$replacer = replacer;\n\t  if($replacer || !isArray(replacer))replacer = function(key, value){\n\t    if($replacer)value = $replacer.call(this, key, value);\n\t    if(!isSymbol(value))return value;\n\t  };\n\t  args[1] = replacer;\n\t  return _stringify.apply($JSON, args);\n\t};\n\tvar buggyJSON = $fails(function(){\n\t  var S = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  // WebKit converts symbol values to JSON as null\n\t  // V8 throws on boxed symbols\n\t  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n\t});\n\t\n\t// 19.4.1.1 Symbol([description])\n\tif(!useNative){\n\t  $Symbol = function Symbol(){\n\t    if(isSymbol(this))throw TypeError('Symbol is not a constructor');\n\t    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));\n\t  };\n\t  redefine($Symbol.prototype, 'toString', function toString(){\n\t    return this._k;\n\t  });\n\t\n\t  isSymbol = function(it){\n\t    return it instanceof $Symbol;\n\t  };\n\t\n\t  $.create     = $create;\n\t  $.isEnum     = $propertyIsEnumerable;\n\t  $.getDesc    = $getOwnPropertyDescriptor;\n\t  $.setDesc    = $defineProperty;\n\t  $.setDescs   = $defineProperties;\n\t  $.getNames   = $names.get = $getOwnPropertyNames;\n\t  $.getSymbols = $getOwnPropertySymbols;\n\t\n\t  if(DESCRIPTORS && !__webpack_require__(32)){\n\t    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n\t  }\n\t}\n\t\n\tvar symbolStatics = {\n\t  // 19.4.2.1 Symbol.for(key)\n\t  'for': function(key){\n\t    return has(SymbolRegistry, key += '')\n\t      ? SymbolRegistry[key]\n\t      : SymbolRegistry[key] = $Symbol(key);\n\t  },\n\t  // 19.4.2.5 Symbol.keyFor(sym)\n\t  keyFor: function keyFor(key){\n\t    return keyOf(SymbolRegistry, key);\n\t  },\n\t  useSetter: function(){ setter = true; },\n\t  useSimple: function(){ setter = false; }\n\t};\n\t// 19.4.2.2 Symbol.hasInstance\n\t// 19.4.2.3 Symbol.isConcatSpreadable\n\t// 19.4.2.4 Symbol.iterator\n\t// 19.4.2.6 Symbol.match\n\t// 19.4.2.8 Symbol.replace\n\t// 19.4.2.9 Symbol.search\n\t// 19.4.2.10 Symbol.species\n\t// 19.4.2.11 Symbol.split\n\t// 19.4.2.12 Symbol.toPrimitive\n\t// 19.4.2.13 Symbol.toStringTag\n\t// 19.4.2.14 Symbol.unscopables\n\t$.each.call((\n\t  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +\n\t  'species,split,toPrimitive,toStringTag,unscopables'\n\t).split(','), function(it){\n\t  var sym = wks(it);\n\t  symbolStatics[it] = useNative ? sym : wrap(sym);\n\t});\n\t\n\tsetter = true;\n\t\n\t$export($export.G + $export.W, {Symbol: $Symbol});\n\t\n\t$export($export.S, 'Symbol', symbolStatics);\n\t\n\t$export($export.S + $export.F * !useNative, 'Object', {\n\t  // 19.1.2.2 Object.create(O [, Properties])\n\t  create: $create,\n\t  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n\t  defineProperty: $defineProperty,\n\t  // 19.1.2.3 Object.defineProperties(O, Properties)\n\t  defineProperties: $defineProperties,\n\t  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n\t  // 19.1.2.7 Object.getOwnPropertyNames(O)\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\t\n\t// 24.3.2 JSON.stringify(value [, replacer [, space]])\n\t$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});\n\t\n\t// 19.4.3.5 Symbol.prototype[@@toStringTag]\n\tsetToStringTag($Symbol, 'Symbol');\n\t// 20.2.1.9 Math[@@toStringTag]\n\tsetToStringTag(Math, 'Math', true);\n\t// 24.3.3 JSON[@@toStringTag]\n\tsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div id=app><div class=container-fluid><div class=row><div class=col-xs-12><toolbox></toolbox><div class=pull-right><button class=\\\"btn btn-sm btn-success btn-raised\\\" @click=save>本地缓存</button> <button class=\\\"btn btn-sm btn-info btn-raised\\\" @click=read>加载上次</button> <a :href=mdDataUrl download=index.md class=\\\"btn btn-sm btn-info btn-raised\\\" @mouseenter=createUrl(0)>保存为.md格式</a> <a :href=htmlDataUrl download=index.html class=\\\"btn btn-sm btn-info btn-raised\\\" @mouseenter=createUrl(1)>保存为.html格式</a></div></div></div><div class=\\\"work-space row\\\"><div class=col-xs-6><div class=well><hr><textarea autofocus id=inputter v-model=article></textarea></div></div><div class=col-xs-6><div class=well><hr><output id=outputter v-html=\\\"article | markify\\\"></output></div></div></div></div></div>\";\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"btn-group btn-group-xs\\\" role=group aria-label=...><button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;#&quot;)>标题</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=\\\"insert(&quot;>&quot;)\\\">引用</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=\\\"insert(&quot;\\\\n- &quot;)\\\">列表</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=\\\"insert(&quot;\\\\n    &quot;)\\\">代码快</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;\\\\n***\\\\n&quot;)>分割线</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;[描述](http://example.com/)&quot;)>链接</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;*content*&quot;)>斜体</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;**content**&quot;)>强调</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=\\\"insert(&quot;`code`&quot;)\\\">代码</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;![替代文字](example.img)&quot;)>图片</button></div>\";\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(37)\n\t__vue_script__ = __webpack_require__(15)\n\t__vue_template__ = __webpack_require__(38)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) { (typeof module.exports === \"function\" ? module.exports.options : module.exports).template = __vue_template__ }\n\tif (false) {(function () {  module.hot.accept()\n\t  var hotAPI = require(\"vue-hot-reload-api\")\n\t  hotAPI.install(require(\"vue\"), true)\n\t  if (!hotAPI.compatible) return\n\t  var id = \"E:\\\\Vue-projects\\\\src\\\\App.vue\"\n\t  if (!module.hot.data) {\n\t    hotAPI.createRecord(id, module.exports)\n\t  } else {\n\t    hotAPI.update(id, module.exports, __vue_template__)\n\t  }\n\t})()}\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__vue_script__ = __webpack_require__(16)\n\t__vue_template__ = __webpack_require__(39)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) { (typeof module.exports === \"function\" ? module.exports.options : module.exports).template = __vue_template__ }\n\tif (false) {(function () {  module.hot.accept()\n\t  var hotAPI = require(\"vue-hot-reload-api\")\n\t  hotAPI.install(require(\"vue\"), true)\n\t  if (!hotAPI.compatible) return\n\t  var id = \"E:\\\\Vue-projects\\\\src\\\\components\\\\toolbox.vue\"\n\t  if (!module.hot.data) {\n\t    hotAPI.createRecord(id, module.exports)\n\t  } else {\n\t    hotAPI.update(id, module.exports, __vue_template__)\n\t  }\n\t})()}\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** app.9b5e1580122971279aa2.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./static/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c64c6309429951ecb8db\n **/","import Vue from 'vue'\nimport App from './App'\n/* eslint-disable no-new */\n\nnew Vue({\n  el: 'body',\n  components: { App }\n})\n\n\n\n\n/** WEBPACK FOOTER **\n ** ../Vue-projects/src/main.js\n **/","var $Object = Object;\nmodule.exports = {\n  create:     $Object.create,\n  getProto:   $Object.getPrototypeOf,\n  isEnum:     {}.propertyIsEnumerable,\n  getDesc:    $Object.getOwnPropertyDescriptor,\n  setDesc:    $Object.defineProperty,\n  setDescs:   $Object.defineProperties,\n  getKeys:    $Object.keys,\n  getNames:   $Object.getOwnPropertyNames,\n  getSymbols: $Object.getOwnPropertySymbols,\n  each:       [].forEach\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.js\n ** module id = 1\n ** module chunks = 0\n **/","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.global.js\n ** module id = 2\n ** module chunks = 0\n **/","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./$.iobject')\n  , defined = require('./$.defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.to-iobject.js\n ** module id = 3\n ** module chunks = 0\n **/","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.cof.js\n ** module id = 4\n ** module chunks = 0\n **/","var core = module.exports = {version: '1.2.6'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.core.js\n ** module id = 5\n ** module chunks = 0\n **/","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./$.fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.descriptors.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.fails.js\n ** module id = 7\n ** module chunks = 0\n **/","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.has.js\n ** module id = 8\n ** module chunks = 0\n **/","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.property-desc.js\n ** module id = 9\n ** module chunks = 0\n **/","var global = require('./$.global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.shared.js\n ** module id = 10\n ** module chunks = 0\n **/","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.uid.js\n ** module id = 11\n ** module chunks = 0\n **/","var store  = require('./$.shared')('wks')\n  , uid    = require('./$.uid')\n  , Symbol = require('./$.global').Symbol;\nmodule.exports = function(name){\n  return store[name] || (store[name] =\n    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.wks.js\n ** module id = 12\n ** module chunks = 0\n **/","/*!\n * Vue.js v1.0.14\n * (c) 2016 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Vue = factory();\n}(this, function () { 'use strict';\n\n  function set(obj, key, val) {\n    if (hasOwn(obj, key)) {\n      obj[key] = val;\n      return;\n    }\n    if (obj._isVue) {\n      set(obj._data, key, val);\n      return;\n    }\n    var ob = obj.__ob__;\n    if (!ob) {\n      obj[key] = val;\n      return;\n    }\n    ob.convert(key, val);\n    ob.dep.notify();\n    if (ob.vms) {\n      var i = ob.vms.length;\n      while (i--) {\n        var vm = ob.vms[i];\n        vm._proxy(key);\n        vm._digest();\n      }\n    }\n    return val;\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   *\n   * @param {Object} obj\n   * @param {String} key\n   */\n\n  function del(obj, key) {\n    if (!hasOwn(obj, key)) {\n      return;\n    }\n    delete obj[key];\n    var ob = obj.__ob__;\n    if (!ob) {\n      return;\n    }\n    ob.dep.notify();\n    if (ob.vms) {\n      var i = ob.vms.length;\n      while (i--) {\n        var vm = ob.vms[i];\n        vm._unproxy(key);\n        vm._digest();\n      }\n    }\n  }\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  /**\n   * Check whether the object has the property.\n   *\n   * @param {Object} obj\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n\n  /**\n   * Check if an expression is a literal value.\n   *\n   * @param {String} exp\n   * @return {Boolean}\n   */\n\n  var literalValueRE = /^\\s?(true|false|[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\n  function isLiteral(exp) {\n    return literalValueRE.test(exp);\n  }\n\n  /**\n   * Check if a string starts with $ or _\n   *\n   * @param {String} str\n   * @return {Boolean}\n   */\n\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n\n  /**\n   * Guard text output, make sure undefined outputs\n   * empty string\n   *\n   * @param {*} value\n   * @return {String}\n   */\n\n  function _toString(value) {\n    return value == null ? '' : value.toString();\n  }\n\n  /**\n   * Check and convert possible numeric strings to numbers\n   * before setting back to data\n   *\n   * @param {*} value\n   * @return {*|Number}\n   */\n\n  function toNumber(value) {\n    if (typeof value !== 'string') {\n      return value;\n    } else {\n      var parsed = Number(value);\n      return isNaN(parsed) ? value : parsed;\n    }\n  }\n\n  /**\n   * Convert string boolean literals into real booleans.\n   *\n   * @param {*} value\n   * @return {*|Boolean}\n   */\n\n  function toBoolean(value) {\n    return value === 'true' ? true : value === 'false' ? false : value;\n  }\n\n  /**\n   * Strip quotes from a string\n   *\n   * @param {String} str\n   * @return {String | false}\n   */\n\n  function stripQuotes(str) {\n    var a = str.charCodeAt(0);\n    var b = str.charCodeAt(str.length - 1);\n    return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n  }\n\n  /**\n   * Camelize a hyphen-delmited string.\n   *\n   * @param {String} str\n   * @return {String}\n   */\n\n  var camelizeRE = /-(\\w)/g;\n\n  function camelize(str) {\n    return str.replace(camelizeRE, toUpper);\n  }\n\n  function toUpper(_, c) {\n    return c ? c.toUpperCase() : '';\n  }\n\n  /**\n   * Hyphenate a camelCase string.\n   *\n   * @param {String} str\n   * @return {String}\n   */\n\n  var hyphenateRE = /([a-z\\d])([A-Z])/g;\n\n  function hyphenate(str) {\n    return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n  }\n\n  /**\n   * Converts hyphen/underscore/slash delimitered names into\n   * camelized classNames.\n   *\n   * e.g. my-component => MyComponent\n   *      some_else    => SomeElse\n   *      some/comp    => SomeComp\n   *\n   * @param {String} str\n   * @return {String}\n   */\n\n  var classifyRE = /(?:^|[-_\\/])(\\w)/g;\n\n  function classify(str) {\n    return str.replace(classifyRE, toUpper);\n  }\n\n  /**\n   * Simple bind, faster than native\n   *\n   * @param {Function} fn\n   * @param {Object} ctx\n   * @return {Function}\n   */\n\n  function bind$1(fn, ctx) {\n    return function (a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    };\n  }\n\n  /**\n   * Convert an Array-like object to a real Array.\n   *\n   * @param {Array-like} list\n   * @param {Number} [start] - start index\n   * @return {Array}\n   */\n\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret;\n  }\n\n  /**\n   * Mix properties into target object.\n   *\n   * @param {Object} to\n   * @param {Object} from\n   */\n\n  function extend(to, from) {\n    var keys = Object.keys(from);\n    var i = keys.length;\n    while (i--) {\n      to[keys[i]] = from[keys[i]];\n    }\n    return to;\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   *\n   * @param {*} obj\n   * @return {Boolean}\n   */\n\n  function isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n  }\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   *\n   * @param {*} obj\n   * @return {Boolean}\n   */\n\n  var toString = Object.prototype.toString;\n  var OBJECT_STRING = '[object Object]';\n\n  function isPlainObject(obj) {\n    return toString.call(obj) === OBJECT_STRING;\n  }\n\n  /**\n   * Array type check.\n   *\n   * @param {*} obj\n   * @return {Boolean}\n   */\n\n  var isArray = Array.isArray;\n\n  /**\n   * Define a non-enumerable property\n   *\n   * @param {Object} obj\n   * @param {String} key\n   * @param {*} val\n   * @param {Boolean} [enumerable]\n   */\n\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Debounce a function so it only gets called after the\n   * input stops arriving after the given wait period.\n   *\n   * @param {Function} func\n   * @param {Number} wait\n   * @return {Function} - the debounced function\n   */\n\n  function _debounce(func, wait) {\n    var timeout, args, context, timestamp, result;\n    var later = function later() {\n      var last = Date.now() - timestamp;\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    };\n    return function () {\n      context = this;\n      args = arguments;\n      timestamp = Date.now();\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n      return result;\n    };\n  }\n\n  /**\n   * Manual indexOf because it's slightly faster than\n   * native.\n   *\n   * @param {Array} arr\n   * @param {*} obj\n   */\n\n  function indexOf(arr, obj) {\n    var i = arr.length;\n    while (i--) {\n      if (arr[i] === obj) return i;\n    }\n    return -1;\n  }\n\n  /**\n   * Make a cancellable version of an async callback.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   */\n\n  function cancellable(fn) {\n    var cb = function cb() {\n      if (!cb.cancelled) {\n        return fn.apply(this, arguments);\n      }\n    };\n    cb.cancel = function () {\n      cb.cancelled = true;\n    };\n    return cb;\n  }\n\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   *\n   * @param {*} a\n   * @param {*} b\n   * @return {Boolean}\n   */\n\n  function looseEqual(a, b) {\n    /* eslint-disable eqeqeq */\n    return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\n    /* eslint-enable eqeqeq */\n  }\n\n  var hasProto = ('__proto__' in {});\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\n  var isIE9 = inBrowser && navigator.userAgent.toLowerCase().indexOf('msie 9.0') > 0;\n\n  var isAndroid = inBrowser && navigator.userAgent.toLowerCase().indexOf('android') > 0;\n\n  var transitionProp = undefined;\n  var transitionEndEvent = undefined;\n  var animationProp = undefined;\n  var animationEndEvent = undefined;\n\n  // Transition property/event sniffing\n  if (inBrowser && !isIE9) {\n    var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\n    var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\n    transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\n    transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\n    animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\n    animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\n  }\n\n  /**\n   * Defer a task to execute it asynchronously. Ideally this\n   * should be executed as a microtask, so we leverage\n   * MutationObserver if it's available, and fallback to\n   * setTimeout(0).\n   *\n   * @param {Function} cb\n   * @param {Object} ctx\n   */\n\n  var nextTick = (function () {\n    var callbacks = [];\n    var pending = false;\n    var timerFunc;\n    function nextTickHandler() {\n      pending = false;\n      var copies = callbacks.slice(0);\n      callbacks = [];\n      for (var i = 0; i < copies.length; i++) {\n        copies[i]();\n      }\n    }\n    /* istanbul ignore if */\n    if (typeof MutationObserver !== 'undefined') {\n      var counter = 1;\n      var observer = new MutationObserver(nextTickHandler);\n      var textNode = document.createTextNode(counter);\n      observer.observe(textNode, {\n        characterData: true\n      });\n      timerFunc = function () {\n        counter = (counter + 1) % 2;\n        textNode.data = counter;\n      };\n    } else {\n      timerFunc = setTimeout;\n    }\n    return function (cb, ctx) {\n      var func = ctx ? function () {\n        cb.call(ctx);\n      } : cb;\n      callbacks.push(func);\n      if (pending) return;\n      pending = true;\n      timerFunc(nextTickHandler, 0);\n    };\n  })();\n\n  function Cache(limit) {\n    this.size = 0;\n    this.limit = limit;\n    this.head = this.tail = undefined;\n    this._keymap = Object.create(null);\n  }\n\n  var p = Cache.prototype;\n\n  /**\n   * Put <value> into the cache associated with <key>.\n   * Returns the entry which was removed to make room for\n   * the new entry. Otherwise undefined is returned.\n   * (i.e. if there was enough room already).\n   *\n   * @param {String} key\n   * @param {*} value\n   * @return {Entry|undefined}\n   */\n\n  p.put = function (key, value) {\n    var entry = {\n      key: key,\n      value: value\n    };\n    this._keymap[key] = entry;\n    if (this.tail) {\n      this.tail.newer = entry;\n      entry.older = this.tail;\n    } else {\n      this.head = entry;\n    }\n    this.tail = entry;\n    if (this.size === this.limit) {\n      return this.shift();\n    } else {\n      this.size++;\n    }\n  };\n\n  /**\n   * Purge the least recently used (oldest) entry from the\n   * cache. Returns the removed entry or undefined if the\n   * cache was empty.\n   */\n\n  p.shift = function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = this.head.newer;\n      this.head.older = undefined;\n      entry.newer = entry.older = undefined;\n      this._keymap[entry.key] = undefined;\n    }\n    return entry;\n  };\n\n  /**\n   * Get and register recent use of <key>. Returns the value\n   * associated with <key> or undefined if not in cache.\n   *\n   * @param {String} key\n   * @param {Boolean} returnEntry\n   * @return {Entry|*}\n   */\n\n  p.get = function (key, returnEntry) {\n    var entry = this._keymap[key];\n    if (entry === undefined) return;\n    if (entry === this.tail) {\n      return returnEntry ? entry : entry.value;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry.newer) {\n      if (entry === this.head) {\n        this.head = entry.newer;\n      }\n      entry.newer.older = entry.older; // C <-- E.\n    }\n    if (entry.older) {\n      entry.older.newer = entry.newer; // C. --> E\n    }\n    entry.newer = undefined; // D --x\n    entry.older = this.tail; // D. --> E\n    if (this.tail) {\n      this.tail.newer = entry; // E. <-- D\n    }\n    this.tail = entry;\n    return returnEntry ? entry : entry.value;\n  };\n\n  var cache$1 = new Cache(1000);\n  var filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\n  var reservedArgRE = /^in$|^-?\\d+/;\n\n  /**\n   * Parser state\n   */\n\n  var str;\n  var dir;\n  var c;\n  var prev;\n  var i;\n  var l;\n  var lastFilterIndex;\n  var inSingle;\n  var inDouble;\n  var curly;\n  var square;\n  var paren;\n  /**\n   * Push a filter to the current directive object\n   */\n\n  function pushFilter() {\n    var exp = str.slice(lastFilterIndex, i).trim();\n    var filter;\n    if (exp) {\n      filter = {};\n      var tokens = exp.match(filterTokenRE);\n      filter.name = tokens[0];\n      if (tokens.length > 1) {\n        filter.args = tokens.slice(1).map(processFilterArg);\n      }\n    }\n    if (filter) {\n      (dir.filters = dir.filters || []).push(filter);\n    }\n    lastFilterIndex = i + 1;\n  }\n\n  /**\n   * Check if an argument is dynamic and strip quotes.\n   *\n   * @param {String} arg\n   * @return {Object}\n   */\n\n  function processFilterArg(arg) {\n    if (reservedArgRE.test(arg)) {\n      return {\n        value: toNumber(arg),\n        dynamic: false\n      };\n    } else {\n      var stripped = stripQuotes(arg);\n      var dynamic = stripped === arg;\n      return {\n        value: dynamic ? arg : stripped,\n        dynamic: dynamic\n      };\n    }\n  }\n\n  /**\n   * Parse a directive value and extract the expression\n   * and its filters into a descriptor.\n   *\n   * Example:\n   *\n   * \"a + 1 | uppercase\" will yield:\n   * {\n   *   expression: 'a + 1',\n   *   filters: [\n   *     { name: 'uppercase', args: null }\n   *   ]\n   * }\n   *\n   * @param {String} str\n   * @return {Object}\n   */\n\n  function parseDirective(s) {\n\n    var hit = cache$1.get(s);\n    if (hit) {\n      return hit;\n    }\n\n    // reset parser state\n    str = s;\n    inSingle = inDouble = false;\n    curly = square = paren = 0;\n    lastFilterIndex = 0;\n    dir = {};\n\n    for (i = 0, l = str.length; i < l; i++) {\n      prev = c;\n      c = str.charCodeAt(i);\n      if (inSingle) {\n        // check single quote\n        if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\n      } else if (inDouble) {\n        // check double quote\n        if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\n      } else if (c === 0x7C && // pipe\n      str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\n        if (dir.expression == null) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          dir.expression = str.slice(0, i).trim();\n        } else {\n          // already has filter\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;break; // \"\n          case 0x27:\n            inSingle = true;break; // '\n          case 0x28:\n            paren++;break; // (\n          case 0x29:\n            paren--;break; // )\n          case 0x5B:\n            square++;break; // [\n          case 0x5D:\n            square--;break; // ]\n          case 0x7B:\n            curly++;break; // {\n          case 0x7D:\n            curly--;break; // }\n        }\n      }\n    }\n\n    if (dir.expression == null) {\n      dir.expression = str.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    cache$1.put(s, dir);\n    return dir;\n  }\n\n  var directive = Object.freeze({\n    parseDirective: parseDirective\n  });\n\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  var cache = undefined;\n  var tagRE = undefined;\n  var htmlRE = undefined;\n  /**\n   * Escape a string so it can be used in a RegExp\n   * constructor.\n   *\n   * @param {String} str\n   */\n\n  function escapeRegex(str) {\n    return str.replace(regexEscapeRE, '\\\\$&');\n  }\n\n  function compileRegex() {\n    var open = escapeRegex(config.delimiters[0]);\n    var close = escapeRegex(config.delimiters[1]);\n    var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\n    var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\n    tagRE = new RegExp(unsafeOpen + '(.+?)' + unsafeClose + '|' + open + '(.+?)' + close, 'g');\n    htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');\n    // reset cache\n    cache = new Cache(1000);\n  }\n\n  /**\n   * Parse a template text string into an array of tokens.\n   *\n   * @param {String} text\n   * @return {Array<Object> | null}\n   *               - {String} type\n   *               - {String} value\n   *               - {Boolean} [html]\n   *               - {Boolean} [oneTime]\n   */\n\n  function parseText(text) {\n    if (!cache) {\n      compileRegex();\n    }\n    var hit = cache.get(text);\n    if (hit) {\n      return hit;\n    }\n    text = text.replace(/\\n/g, '');\n    if (!tagRE.test(text)) {\n      return null;\n    }\n    var tokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, html, value, first, oneTime;\n    /* eslint-disable no-cond-assign */\n    while (match = tagRE.exec(text)) {\n      /* eslint-enable no-cond-assign */\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        tokens.push({\n          value: text.slice(lastIndex, index)\n        });\n      }\n      // tag token\n      html = htmlRE.test(match[0]);\n      value = html ? match[1] : match[2];\n      first = value.charCodeAt(0);\n      oneTime = first === 42; // *\n      value = oneTime ? value.slice(1) : value;\n      tokens.push({\n        tag: true,\n        value: value.trim(),\n        html: html,\n        oneTime: oneTime\n      });\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      tokens.push({\n        value: text.slice(lastIndex)\n      });\n    }\n    cache.put(text, tokens);\n    return tokens;\n  }\n\n  /**\n   * Format a list of tokens into an expression.\n   * e.g. tokens parsed from 'a {{b}} c' can be serialized\n   * into one single expression as '\"a \" + b + \" c\"'.\n   *\n   * @param {Array} tokens\n   * @param {Vue} [vm]\n   * @return {String}\n   */\n\n  function tokensToExp(tokens, vm) {\n    if (tokens.length > 1) {\n      return tokens.map(function (token) {\n        return formatToken(token, vm);\n      }).join('+');\n    } else {\n      return formatToken(tokens[0], vm, true);\n    }\n  }\n\n  /**\n   * Format a single token.\n   *\n   * @param {Object} token\n   * @param {Vue} [vm]\n   * @param {Boolean} [single]\n   * @return {String}\n   */\n\n  function formatToken(token, vm, single) {\n    return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\n  }\n\n  /**\n   * For an attribute with multiple interpolation tags,\n   * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n   * the whole thing into a single watchable expression, we\n   * have to inline those filters. This function does exactly\n   * that. This is a bit hacky but it avoids heavy changes\n   * to directive parser and watcher mechanism.\n   *\n   * @param {String} exp\n   * @param {Boolean} single\n   * @return {String}\n   */\n\n  var filterRE$1 = /[^|]\\|[^|]/;\n  function inlineFilters(exp, single) {\n    if (!filterRE$1.test(exp)) {\n      return single ? exp : '(' + exp + ')';\n    } else {\n      var dir = parseDirective(exp);\n      if (!dir.filters) {\n        return '(' + exp + ')';\n      } else {\n        return 'this._applyFilters(' + dir.expression + // value\n        ',null,' + // oldValue (null for read)\n        JSON.stringify(dir.filters) + // filter descriptors\n        ',false)'; // write?\n      }\n    }\n  }\n\n  var text$1 = Object.freeze({\n    compileRegex: compileRegex,\n    parseText: parseText,\n    tokensToExp: tokensToExp\n  });\n\n  var delimiters = ['{{', '}}'];\n  var unsafeDelimiters = ['{{{', '}}}'];\n\n  var config = Object.defineProperties({\n\n    /**\n     * Whether to print debug messages.\n     * Also enables stack trace for warnings.\n     *\n     * @type {Boolean}\n     */\n\n    debug: false,\n\n    /**\n     * Whether to suppress warnings.\n     *\n     * @type {Boolean}\n     */\n\n    silent: false,\n\n    /**\n     * Whether to use async rendering.\n     */\n\n    async: true,\n\n    /**\n     * Whether to warn against errors caught when evaluating\n     * expressions.\n     */\n\n    warnExpressionErrors: true,\n\n    /**\n     * Whether or not to handle fully object properties which\n     * are already backed by getters and seters. Depending on\n     * use case and environment, this might introduce non-neglible\n     * performance penalties.\n     */\n    convertAllProperties: false,\n\n    /**\n     * Internal flag to indicate the delimiters have been\n     * changed.\n     *\n     * @type {Boolean}\n     */\n\n    _delimitersChanged: true,\n\n    /**\n     * List of asset types that a component can own.\n     *\n     * @type {Array}\n     */\n\n    _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\n\n    /**\n     * prop binding modes\n     */\n\n    _propBindingModes: {\n      ONE_WAY: 0,\n      TWO_WAY: 1,\n      ONE_TIME: 2\n    },\n\n    /**\n     * Max circular updates allowed in a batcher flush cycle.\n     */\n\n    _maxUpdateCount: 100\n\n  }, {\n    delimiters: { /**\n                   * Interpolation delimiters. Changing these would trigger\n                   * the text parser to re-compile the regular expressions.\n                   *\n                   * @type {Array<String>}\n                   */\n\n      get: function get() {\n        return delimiters;\n      },\n      set: function set(val) {\n        delimiters = val;\n        compileRegex();\n      },\n      configurable: true,\n      enumerable: true\n    },\n    unsafeDelimiters: {\n      get: function get() {\n        return unsafeDelimiters;\n      },\n      set: function set(val) {\n        unsafeDelimiters = val;\n        compileRegex();\n      },\n      configurable: true,\n      enumerable: true\n    }\n  });\n\n  var warn = undefined;\n\n  if ('development' !== 'production') {\n    (function () {\n      var hasConsole = typeof console !== 'undefined';\n      warn = function (msg, e) {\n        if (hasConsole && (!config.silent || config.debug)) {\n          console.warn('[Vue warn]: ' + msg);\n          /* istanbul ignore if */\n          if (config.debug) {\n            if (e) {\n              throw e;\n            } else {\n              console.warn(new Error('Warning Stack Trace').stack);\n            }\n          }\n        }\n      };\n    })();\n  }\n\n  /**\n   * Append with transition.\n   *\n   * @param {Element} el\n   * @param {Element} target\n   * @param {Vue} vm\n   * @param {Function} [cb]\n   */\n\n  function appendWithTransition(el, target, vm, cb) {\n    applyTransition(el, 1, function () {\n      target.appendChild(el);\n    }, vm, cb);\n  }\n\n  /**\n   * InsertBefore with transition.\n   *\n   * @param {Element} el\n   * @param {Element} target\n   * @param {Vue} vm\n   * @param {Function} [cb]\n   */\n\n  function beforeWithTransition(el, target, vm, cb) {\n    applyTransition(el, 1, function () {\n      before(el, target);\n    }, vm, cb);\n  }\n\n  /**\n   * Remove with transition.\n   *\n   * @param {Element} el\n   * @param {Vue} vm\n   * @param {Function} [cb]\n   */\n\n  function removeWithTransition(el, vm, cb) {\n    applyTransition(el, -1, function () {\n      remove(el);\n    }, vm, cb);\n  }\n\n  /**\n   * Apply transitions with an operation callback.\n   *\n   * @param {Element} el\n   * @param {Number} direction\n   *                  1: enter\n   *                 -1: leave\n   * @param {Function} op - the actual DOM operation\n   * @param {Vue} vm\n   * @param {Function} [cb]\n   */\n\n  function applyTransition(el, direction, op, vm, cb) {\n    var transition = el.__v_trans;\n    if (!transition ||\n    // skip if there are no js hooks and CSS transition is\n    // not supported\n    !transition.hooks && !transitionEndEvent ||\n    // skip transitions for initial compile\n    !vm._isCompiled ||\n    // if the vm is being manipulated by a parent directive\n    // during the parent's compilation phase, skip the\n    // animation.\n    vm.$parent && !vm.$parent._isCompiled) {\n      op();\n      if (cb) cb();\n      return;\n    }\n    var action = direction > 0 ? 'enter' : 'leave';\n    transition[action](op, cb);\n  }\n\n  /**\n   * Query an element selector if it's not an element already.\n   *\n   * @param {String|Element} el\n   * @return {Element}\n   */\n\n  function query(el) {\n    if (typeof el === 'string') {\n      var selector = el;\n      el = document.querySelector(el);\n      if (!el) {\n        'development' !== 'production' && warn('Cannot find element: ' + selector);\n      }\n    }\n    return el;\n  }\n\n  /**\n   * Check if a node is in the document.\n   * Note: document.documentElement.contains should work here\n   * but always returns false for comment nodes in phantomjs,\n   * making unit tests difficult. This is fixed by doing the\n   * contains() check on the node's parentNode instead of\n   * the node itself.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  function inDoc(node) {\n    var doc = document.documentElement;\n    var parent = node && node.parentNode;\n    return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n  }\n\n  /**\n   * Get and remove an attribute from a node.\n   *\n   * @param {Node} node\n   * @param {String} _attr\n   */\n\n  function getAttr(node, _attr) {\n    var val = node.getAttribute(_attr);\n    if (val !== null) {\n      node.removeAttribute(_attr);\n    }\n    return val;\n  }\n\n  /**\n   * Get an attribute with colon or v-bind: prefix.\n   *\n   * @param {Node} node\n   * @param {String} name\n   * @return {String|null}\n   */\n\n  function getBindAttr(node, name) {\n    var val = getAttr(node, ':' + name);\n    if (val === null) {\n      val = getAttr(node, 'v-bind:' + name);\n    }\n    return val;\n  }\n\n  /**\n   * Check the presence of a bind attribute.\n   *\n   * @param {Node} node\n   * @param {String} name\n   * @return {Boolean}\n   */\n\n  function hasBindAttr(node, name) {\n    return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\n  }\n\n  /**\n   * Insert el before target\n   *\n   * @param {Element} el\n   * @param {Element} target\n   */\n\n  function before(el, target) {\n    target.parentNode.insertBefore(el, target);\n  }\n\n  /**\n   * Insert el after target\n   *\n   * @param {Element} el\n   * @param {Element} target\n   */\n\n  function after(el, target) {\n    if (target.nextSibling) {\n      before(el, target.nextSibling);\n    } else {\n      target.parentNode.appendChild(el);\n    }\n  }\n\n  /**\n   * Remove el from DOM\n   *\n   * @param {Element} el\n   */\n\n  function remove(el) {\n    el.parentNode.removeChild(el);\n  }\n\n  /**\n   * Prepend el to target\n   *\n   * @param {Element} el\n   * @param {Element} target\n   */\n\n  function prepend(el, target) {\n    if (target.firstChild) {\n      before(el, target.firstChild);\n    } else {\n      target.appendChild(el);\n    }\n  }\n\n  /**\n   * Replace target with el\n   *\n   * @param {Element} target\n   * @param {Element} el\n   */\n\n  function replace(target, el) {\n    var parent = target.parentNode;\n    if (parent) {\n      parent.replaceChild(el, target);\n    }\n  }\n\n  /**\n   * Add event listener shorthand.\n   *\n   * @param {Element} el\n   * @param {String} event\n   * @param {Function} cb\n   */\n\n  function on$1(el, event, cb) {\n    el.addEventListener(event, cb);\n  }\n\n  /**\n   * Remove event listener shorthand.\n   *\n   * @param {Element} el\n   * @param {String} event\n   * @param {Function} cb\n   */\n\n  function off(el, event, cb) {\n    el.removeEventListener(event, cb);\n  }\n\n  /**\n   * In IE9, setAttribute('class') will result in empty class\n   * if the element also has the :class attribute; However in\n   * PhantomJS, setting `className` does not work on SVG elements...\n   * So we have to do a conditional check here.\n   *\n   * @param {Element} el\n   * @param {String} cls\n   */\n\n  function setClass(el, cls) {\n    /* istanbul ignore if */\n    if (isIE9 && !(el instanceof SVGElement)) {\n      el.className = cls;\n    } else {\n      el.setAttribute('class', cls);\n    }\n  }\n\n  /**\n   * Add class with compatibility for IE & SVG\n   *\n   * @param {Element} el\n   * @param {String} cls\n   */\n\n  function addClass(el, cls) {\n    if (el.classList) {\n      el.classList.add(cls);\n    } else {\n      var cur = ' ' + (el.getAttribute('class') || '') + ' ';\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        setClass(el, (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for IE & SVG\n   *\n   * @param {Element} el\n   * @param {String} cls\n   */\n\n  function removeClass(el, cls) {\n    if (el.classList) {\n      el.classList.remove(cls);\n    } else {\n      var cur = ' ' + (el.getAttribute('class') || '') + ' ';\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      setClass(el, cur.trim());\n    }\n    if (!el.className) {\n      el.removeAttribute('class');\n    }\n  }\n\n  /**\n   * Extract raw content inside an element into a temporary\n   * container div\n   *\n   * @param {Element} el\n   * @param {Boolean} asFragment\n   * @return {Element}\n   */\n\n  function extractContent(el, asFragment) {\n    var child;\n    var rawContent;\n    /* istanbul ignore if */\n    if (isTemplate(el) && el.content instanceof DocumentFragment) {\n      el = el.content;\n    }\n    if (el.hasChildNodes()) {\n      trimNode(el);\n      rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\n      /* eslint-disable no-cond-assign */\n      while (child = el.firstChild) {\n        /* eslint-enable no-cond-assign */\n        rawContent.appendChild(child);\n      }\n    }\n    return rawContent;\n  }\n\n  /**\n   * Trim possible empty head/tail textNodes inside a parent.\n   *\n   * @param {Node} node\n   */\n\n  function trimNode(node) {\n    trim(node, node.firstChild);\n    trim(node, node.lastChild);\n  }\n\n  function trim(parent, node) {\n    if (node && node.nodeType === 3 && !node.data.trim()) {\n      parent.removeChild(node);\n    }\n  }\n\n  /**\n   * Check if an element is a template tag.\n   * Note if the template appears inside an SVG its tagName\n   * will be in lowercase.\n   *\n   * @param {Element} el\n   */\n\n  function isTemplate(el) {\n    return el.tagName && el.tagName.toLowerCase() === 'template';\n  }\n\n  /**\n   * Create an \"anchor\" for performing dom insertion/removals.\n   * This is used in a number of scenarios:\n   * - fragment instance\n   * - v-html\n   * - v-if\n   * - v-for\n   * - component\n   *\n   * @param {String} content\n   * @param {Boolean} persist - IE trashes empty textNodes on\n   *                            cloneNode(true), so in certain\n   *                            cases the anchor needs to be\n   *                            non-empty to be persisted in\n   *                            templates.\n   * @return {Comment|Text}\n   */\n\n  function createAnchor(content, persist) {\n    var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\n    anchor.__vue_anchor = true;\n    return anchor;\n  }\n\n  /**\n   * Find a component ref attribute that starts with $.\n   *\n   * @param {Element} node\n   * @return {String|undefined}\n   */\n\n  var refRE = /^v-ref:/;\n\n  function findRef(node) {\n    if (node.hasAttributes()) {\n      var attrs = node.attributes;\n      for (var i = 0, l = attrs.length; i < l; i++) {\n        var name = attrs[i].name;\n        if (refRE.test(name)) {\n          return camelize(name.replace(refRE, ''));\n        }\n      }\n    }\n  }\n\n  /**\n   * Map a function to a range of nodes .\n   *\n   * @param {Node} node\n   * @param {Node} end\n   * @param {Function} op\n   */\n\n  function mapNodeRange(node, end, op) {\n    var next;\n    while (node !== end) {\n      next = node.nextSibling;\n      op(node);\n      node = next;\n    }\n    op(end);\n  }\n\n  /**\n   * Remove a range of nodes with transition, store\n   * the nodes in a fragment with correct ordering,\n   * and call callback when done.\n   *\n   * @param {Node} start\n   * @param {Node} end\n   * @param {Vue} vm\n   * @param {DocumentFragment} frag\n   * @param {Function} cb\n   */\n\n  function removeNodeRange(start, end, vm, frag, cb) {\n    var done = false;\n    var removed = 0;\n    var nodes = [];\n    mapNodeRange(start, end, function (node) {\n      if (node === end) done = true;\n      nodes.push(node);\n      removeWithTransition(node, vm, onRemoved);\n    });\n    function onRemoved() {\n      removed++;\n      if (done && removed >= nodes.length) {\n        for (var i = 0; i < nodes.length; i++) {\n          frag.appendChild(nodes[i]);\n        }\n        cb && cb();\n      }\n    }\n  }\n\n  var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/;\n  var reservedTagRE = /^(slot|partial|component)$/;\n\n  /**\n   * Check if an element is a component, if yes return its\n   * component id.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Object|undefined}\n   */\n\n  function checkComponentAttr(el, options) {\n    var tag = el.tagName.toLowerCase();\n    var hasAttrs = el.hasAttributes();\n    if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\n      if (resolveAsset(options, 'components', tag)) {\n        return { id: tag };\n      } else {\n        var is = hasAttrs && getIsBinding(el);\n        if (is) {\n          return is;\n        } else if ('development' !== 'production') {\n          if (tag.indexOf('-') > -1 || /HTMLUnknownElement/.test(el.toString()) &&\n          // Chrome returns unknown for several HTML5 elements.\n          // https://code.google.com/p/chromium/issues/detail?id=540526\n          !/^(data|time|rtc|rb)$/.test(tag)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly?');\n          }\n        }\n      }\n    } else if (hasAttrs) {\n      return getIsBinding(el);\n    }\n  }\n\n  /**\n   * Get \"is\" binding from an element.\n   *\n   * @param {Element} el\n   * @return {Object|undefined}\n   */\n\n  function getIsBinding(el) {\n    // dynamic syntax\n    var exp = getAttr(el, 'is');\n    if (exp != null) {\n      return { id: exp };\n    } else {\n      exp = getBindAttr(el, 'is');\n      if (exp != null) {\n        return { id: exp, dynamic: true };\n      }\n    }\n  }\n\n  /**\n   * Set a prop's initial value on a vm and its data object.\n   *\n   * @param {Vue} vm\n   * @param {Object} prop\n   * @param {*} value\n   */\n\n  function initProp(vm, prop, value) {\n    var key = prop.path;\n    value = coerceProp(prop, value);\n    vm[key] = vm._data[key] = assertProp(prop, value) ? value : undefined;\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   *\n   * @param {Object} prop\n   * @param {*} value\n   */\n\n  function assertProp(prop, value) {\n    // if a prop is not provided and is not required,\n    // skip the check.\n    if (prop.raw === null && !prop.required) {\n      return true;\n    }\n    var options = prop.options;\n    var type = options.type;\n    var valid = true;\n    var expectedType;\n    if (type) {\n      if (type === String) {\n        expectedType = 'string';\n        valid = typeof value === expectedType;\n      } else if (type === Number) {\n        expectedType = 'number';\n        valid = typeof value === 'number';\n      } else if (type === Boolean) {\n        expectedType = 'boolean';\n        valid = typeof value === 'boolean';\n      } else if (type === Function) {\n        expectedType = 'function';\n        valid = typeof value === 'function';\n      } else if (type === Object) {\n        expectedType = 'object';\n        valid = isPlainObject(value);\n      } else if (type === Array) {\n        expectedType = 'array';\n        valid = isArray(value);\n      } else {\n        valid = value instanceof type;\n      }\n    }\n    if (!valid) {\n      'development' !== 'production' && warn('Invalid prop: type check failed for ' + prop.path + '=\"' + prop.raw + '\".' + ' Expected ' + formatType(expectedType) + ', got ' + formatValue(value) + '.');\n      return false;\n    }\n    var validator = options.validator;\n    if (validator) {\n      if (!validator.call(null, value)) {\n        'development' !== 'production' && warn('Invalid prop: custom validator check failed for ' + prop.path + '=\"' + prop.raw + '\"');\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Force parsing value with coerce option.\n   *\n   * @param {*} value\n   * @param {Object} options\n   * @return {*}\n   */\n\n  function coerceProp(prop, value) {\n    var coerce = prop.options.coerce;\n    if (!coerce) {\n      return value;\n    }\n    // coerce is a function\n    return coerce(value);\n  }\n\n  function formatType(val) {\n    return val ? val.charAt(0).toUpperCase() + val.slice(1) : 'custom type';\n  }\n\n  function formatValue(val) {\n    return Object.prototype.toString.call(val).slice(8, -1);\n  }\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   *\n   * All strategy functions follow the same signature:\n   *\n   * @param {*} parentVal\n   * @param {*} childVal\n   * @param {Vue} [vm]\n   */\n\n  var strats = config.optionMergeStrategies = Object.create(null);\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n\n  function mergeData(to, from) {\n    var key, toVal, fromVal;\n    for (key in from) {\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (isObject(toVal) && isObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to;\n  }\n\n  /**\n   * Data\n   */\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n      if (typeof childVal !== 'function') {\n        'development' !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');\n        return parentVal;\n      }\n      if (!parentVal) {\n        return childVal;\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn() {\n        return mergeData(childVal.call(this), parentVal.call(this));\n      };\n    } else if (parentVal || childVal) {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  };\n\n  /**\n   * El\n   */\n\n  strats.el = function (parentVal, childVal, vm) {\n    if (!vm && childVal && typeof childVal !== 'function') {\n      'development' !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');\n      return;\n    }\n    var ret = childVal || parentVal;\n    // invoke the element factory if this is instance merge\n    return vm && typeof ret === 'function' ? ret.call(vm) : ret;\n  };\n\n  /**\n   * Hooks and param attributes are merged as arrays.\n   */\n\n  strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = function (parentVal, childVal) {\n    return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\n  };\n\n  /**\n   * 0.11 deprecation warning\n   */\n\n  strats.paramAttributes = function () {\n    /* istanbul ignore next */\n    'development' !== 'production' && warn('\"paramAttributes\" option has been deprecated in 0.12. ' + 'Use \"props\" instead.');\n  };\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n\n  function mergeAssets(parentVal, childVal) {\n    var res = Object.create(parentVal);\n    return childVal ? extend(res, guardArrayAssets(childVal)) : res;\n  }\n\n  config._assetTypes.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Events & Watchers.\n   *\n   * Events & watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n\n  strats.watch = strats.events = function (parentVal, childVal) {\n    if (!childVal) return parentVal;\n    if (!parentVal) return childVal;\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key in childVal) {\n      var parent = ret[key];\n      var child = childVal[key];\n      if (parent && !isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key] = parent ? parent.concat(child) : [child];\n    }\n    return ret;\n  };\n\n  /**\n   * Other object hashes.\n   */\n\n  strats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n    if (!childVal) return parentVal;\n    if (!parentVal) return childVal;\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    extend(ret, childVal);\n    return ret;\n  };\n\n  /**\n   * Default strategy.\n   */\n\n  var defaultStrat = function defaultStrat(parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n\n  /**\n   * Make sure component options get converted to actual\n   * constructors.\n   *\n   * @param {Object} options\n   */\n\n  function guardComponents(options) {\n    if (options.components) {\n      var components = options.components = guardArrayAssets(options.components);\n      var def;\n      var ids = Object.keys(components);\n      for (var i = 0, l = ids.length; i < l; i++) {\n        var key = ids[i];\n        if (commonTagRE.test(key) || reservedTagRE.test(key)) {\n          'development' !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n          continue;\n        }\n        def = components[key];\n        if (isPlainObject(def)) {\n          components[key] = Vue.extend(def);\n        }\n      }\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   *\n   * @param {Object} options\n   */\n\n  function guardProps(options) {\n    var props = options.props;\n    var i, val;\n    if (isArray(props)) {\n      options.props = {};\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          options.props[val] = null;\n        } else if (val.name) {\n          options.props[val.name] = val;\n        }\n      }\n    } else if (isPlainObject(props)) {\n      var keys = Object.keys(props);\n      i = keys.length;\n      while (i--) {\n        val = props[keys[i]];\n        if (typeof val === 'function') {\n          props[keys[i]] = { type: val };\n        }\n      }\n    }\n  }\n\n  /**\n   * Guard an Array-format assets option and converted it\n   * into the key-value Object format.\n   *\n   * @param {Object|Array} assets\n   * @return {Object}\n   */\n\n  function guardArrayAssets(assets) {\n    if (isArray(assets)) {\n      var res = {};\n      var i = assets.length;\n      var asset;\n      while (i--) {\n        asset = assets[i];\n        var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\n        if (!id) {\n          'development' !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\n        } else {\n          res[id] = asset;\n        }\n      }\n      return res;\n    }\n    return assets;\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   *\n   * @param {Object} parent\n   * @param {Object} child\n   * @param {Vue} [vm] - if vm is present, indicates this is\n   *                     an instantiation merge.\n   */\n\n  function mergeOptions(parent, child, vm) {\n    guardComponents(child);\n    guardProps(child);\n    var options = {};\n    var key;\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options;\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   *\n   * @param {Object} options\n   * @param {String} type\n   * @param {String} id\n   * @return {Object|Function}\n   */\n\n  function resolveAsset(options, type, id) {\n    var assets = options[type];\n    var camelizedId;\n    return assets[id] ||\n    // camelCase ID\n    assets[camelizedId = camelize(id)] ||\n    // Pascal Case ID\n    assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\n  }\n\n  /**\n   * Assert asset exists\n   */\n\n  function assertAsset(val, type, id) {\n    if (!val) {\n      'development' !== 'production' && warn('Failed to resolve ' + type + ': ' + id);\n    }\n  }\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto)\n\n  /**\n   * Intercept mutating methods and emit events\n   */\n\n  ;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      // avoid leaking arguments:\n      // http://jsperf.com/closure-with-arguments\n      var i = arguments.length;\n      var args = new Array(i);\n      while (i--) {\n        args[i] = arguments[i];\n      }\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case 'push':\n          inserted = args;\n          break;\n        case 'unshift':\n          inserted = args;\n          break;\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n      if (inserted) ob.observeArray(inserted);\n      // notify change\n      ob.dep.notify();\n      return result;\n    });\n  });\n\n  /**\n   * Swap the element at the given index with a new value\n   * and emits corresponding event.\n   *\n   * @param {Number} index\n   * @param {*} val\n   * @return {*} - replaced element\n   */\n\n  def(arrayProto, '$set', function $set(index, val) {\n    if (index >= this.length) {\n      this.length = Number(index) + 1;\n    }\n    return this.splice(index, 1, val)[0];\n  });\n\n  /**\n   * Convenience method to remove the element at given index.\n   *\n   * @param {Number} index\n   * @param {*} val\n   */\n\n  def(arrayProto, '$remove', function $remove(item) {\n    /* istanbul ignore if */\n    if (!this.length) return;\n    var index = indexOf(this, item);\n    if (index > -1) {\n      return this.splice(index, 1);\n    }\n  });\n\n  var uid$3 = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   *\n   * @constructor\n   */\n  function Dep() {\n    this.id = uid$3++;\n    this.subs = [];\n  }\n\n  // the current target watcher being evaluated.\n  // this is globally unique because there could be only one\n  // watcher being evaluated at any time.\n  Dep.target = null;\n\n  /**\n   * Add a directive subscriber.\n   *\n   * @param {Directive} sub\n   */\n\n  Dep.prototype.addSub = function (sub) {\n    this.subs.push(sub);\n  };\n\n  /**\n   * Remove a directive subscriber.\n   *\n   * @param {Directive} sub\n   */\n\n  Dep.prototype.removeSub = function (sub) {\n    this.subs.$remove(sub);\n  };\n\n  /**\n   * Add self as a dependency to the target watcher.\n   */\n\n  Dep.prototype.depend = function () {\n    Dep.target.addDep(this);\n  };\n\n  /**\n   * Notify all subscribers of a new value.\n   */\n\n  Dep.prototype.notify = function () {\n    // stablize the subscriber list first\n    var subs = toArray(this.subs);\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  };\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * Observer class that are attached to each observed\n   * object. Once attached, the observer converts target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatches updates.\n   *\n   * @param {Array|Object} value\n   * @constructor\n   */\n\n  function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    def(value, '__ob__', this);\n    if (isArray(value)) {\n      var augment = hasProto ? protoAugment : copyAugment;\n      augment(value, arrayMethods, arrayKeys);\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  }\n\n  // Instance methods\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   *\n   * @param {Object} obj\n   */\n\n  Observer.prototype.walk = function (obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0, l = keys.length; i < l; i++) {\n      this.convert(keys[i], obj[keys[i]]);\n    }\n  };\n\n  /**\n   * Observe a list of Array items.\n   *\n   * @param {Array} items\n   */\n\n  Observer.prototype.observeArray = function (items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n\n  /**\n   * Convert a property into getter/setter so we can emit\n   * the events when the property is accessed/changed.\n   *\n   * @param {String} key\n   * @param {*} val\n   */\n\n  Observer.prototype.convert = function (key, val) {\n    defineReactive(this.value, key, val);\n  };\n\n  /**\n   * Add an owner vm, so that when $set/$delete mutations\n   * happen we can notify owner vms to proxy the keys and\n   * digest the watchers. This is only called when the object\n   * is observed as an instance's root $data.\n   *\n   * @param {Vue} vm\n   */\n\n  Observer.prototype.addVm = function (vm) {\n    (this.vms || (this.vms = [])).push(vm);\n  };\n\n  /**\n   * Remove an owner vm. This is called when the object is\n   * swapped out as an instance's $data object.\n   *\n   * @param {Vue} vm\n   */\n\n  Observer.prototype.removeVm = function (vm) {\n    this.vms.$remove(vm);\n  };\n\n  // helpers\n\n  /**\n   * Augment an target Object or Array by intercepting\n   * the prototype chain using __proto__\n   *\n   * @param {Object|Array} target\n   * @param {Object} proto\n   */\n\n  function protoAugment(target, src) {\n    target.__proto__ = src;\n  }\n\n  /**\n   * Augment an target Object or Array by defining\n   * hidden properties.\n   *\n   * @param {Object|Array} target\n   * @param {Object} proto\n   */\n\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   *\n   * @param {*} value\n   * @param {Vue} [vm]\n   * @return {Observer|undefined}\n   * @static\n   */\n\n  function observe(value, vm) {\n    if (!value || typeof value !== 'object') {\n      return;\n    }\n    var ob;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if ((isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n    if (ob && vm) {\n      ob.addVm(vm);\n    }\n    return ob;\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   *\n   * @param {Object} obj\n   * @param {String} key\n   * @param {*} val\n   */\n\n  function defineReactive(obj, key, val) {\n    var dep = new Dep();\n\n    // cater for pre-defined getter/setters\n    var getter, setter;\n    if (config.convertAllProperties) {\n      var property = Object.getOwnPropertyDescriptor(obj, key);\n      if (property && property.configurable === false) {\n        return;\n      }\n      getter = property && property.get;\n      setter = property && property.set;\n    }\n\n    var childOb = observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n          }\n          if (isArray(value)) {\n            for (var e, i = 0, l = value.length; i < l; i++) {\n              e = value[i];\n              e && e.__ob__ && e.__ob__.dep.depend();\n            }\n          }\n        }\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        if (newVal === value) {\n          return;\n        }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n  var util = Object.freeze({\n  \tdefineReactive: defineReactive,\n  \tset: set,\n  \tdel: del,\n  \thasOwn: hasOwn,\n  \tisLiteral: isLiteral,\n  \tisReserved: isReserved,\n  \t_toString: _toString,\n  \ttoNumber: toNumber,\n  \ttoBoolean: toBoolean,\n  \tstripQuotes: stripQuotes,\n  \tcamelize: camelize,\n  \thyphenate: hyphenate,\n  \tclassify: classify,\n  \tbind: bind$1,\n  \ttoArray: toArray,\n  \textend: extend,\n  \tisObject: isObject,\n  \tisPlainObject: isPlainObject,\n  \tdef: def,\n  \tdebounce: _debounce,\n  \tindexOf: indexOf,\n  \tcancellable: cancellable,\n  \tlooseEqual: looseEqual,\n  \tisArray: isArray,\n  \thasProto: hasProto,\n  \tinBrowser: inBrowser,\n  \tisIE9: isIE9,\n  \tisAndroid: isAndroid,\n  \tget transitionProp () { return transitionProp; },\n  \tget transitionEndEvent () { return transitionEndEvent; },\n  \tget animationProp () { return animationProp; },\n  \tget animationEndEvent () { return animationEndEvent; },\n  \tnextTick: nextTick,\n  \tquery: query,\n  \tinDoc: inDoc,\n  \tgetAttr: getAttr,\n  \tgetBindAttr: getBindAttr,\n  \thasBindAttr: hasBindAttr,\n  \tbefore: before,\n  \tafter: after,\n  \tremove: remove,\n  \tprepend: prepend,\n  \treplace: replace,\n  \ton: on$1,\n  \toff: off,\n  \tsetClass: setClass,\n  \taddClass: addClass,\n  \tremoveClass: removeClass,\n  \textractContent: extractContent,\n  \ttrimNode: trimNode,\n  \tisTemplate: isTemplate,\n  \tcreateAnchor: createAnchor,\n  \tfindRef: findRef,\n  \tmapNodeRange: mapNodeRange,\n  \tremoveNodeRange: removeNodeRange,\n  \tmergeOptions: mergeOptions,\n  \tresolveAsset: resolveAsset,\n  \tassertAsset: assertAsset,\n  \tcheckComponentAttr: checkComponentAttr,\n  \tinitProp: initProp,\n  \tassertProp: assertProp,\n  \tcoerceProp: coerceProp,\n  \tcommonTagRE: commonTagRE,\n  \treservedTagRE: reservedTagRE,\n  \tget warn () { return warn; }\n  });\n\n  var uid = 0;\n\n  function initMixin (Vue) {\n\n    /**\n     * The main init sequence. This is called for every\n     * instance, including ones that are created from extended\n     * constructors.\n     *\n     * @param {Object} options - this options object should be\n     *                           the result of merging class\n     *                           options and the options passed\n     *                           in to the constructor.\n     */\n\n    Vue.prototype._init = function (options) {\n\n      options = options || {};\n\n      this.$el = null;\n      this.$parent = options.parent;\n      this.$root = this.$parent ? this.$parent.$root : this;\n      this.$children = [];\n      this.$refs = {}; // child vm references\n      this.$els = {}; // element references\n      this._watchers = []; // all watchers as an array\n      this._directives = []; // all directives\n\n      // a uid\n      this._uid = uid++;\n\n      // a flag to avoid this being observed\n      this._isVue = true;\n\n      // events bookkeeping\n      this._events = {}; // registered callbacks\n      this._eventsCount = {}; // for $broadcast optimization\n\n      // fragment instance properties\n      this._isFragment = false;\n      this._fragment = // @type {DocumentFragment}\n      this._fragmentStart = // @type {Text|Comment}\n      this._fragmentEnd = null; // @type {Text|Comment}\n\n      // lifecycle state\n      this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = false;\n      this._unlinkFn = null;\n\n      // context:\n      // if this is a transcluded component, context\n      // will be the common parent vm of this instance\n      // and its host.\n      this._context = options._context || this.$parent;\n\n      // scope:\n      // if this is inside an inline v-for, the scope\n      // will be the intermediate scope created for this\n      // repeat fragment. this is used for linking props\n      // and container directives.\n      this._scope = options._scope;\n\n      // fragment:\n      // if this instance is compiled inside a Fragment, it\n      // needs to reigster itself as a child of that fragment\n      // for attach/detach to work properly.\n      this._frag = options._frag;\n      if (this._frag) {\n        this._frag.children.push(this);\n      }\n\n      // push self into parent / transclusion host\n      if (this.$parent) {\n        this.$parent.$children.push(this);\n      }\n\n      // merge options.\n      options = this.$options = mergeOptions(this.constructor.options, options, this);\n\n      // set ref\n      this._updateRef();\n\n      // initialize data as empty object.\n      // it will be filled up in _initScope().\n      this._data = {};\n\n      // call init hook\n      this._callHook('init');\n\n      // initialize data observation and scope inheritance.\n      this._initState();\n\n      // setup event system and option events.\n      this._initEvents();\n\n      // call created hook\n      this._callHook('created');\n\n      // if `el` option is passed, start compilation.\n      if (options.el) {\n        this.$mount(options.el);\n      }\n    };\n  }\n\n  var pathCache = new Cache(1000);\n\n  // actions\n  var APPEND = 0;\n  var PUSH = 1;\n  var INC_SUB_PATH_DEPTH = 2;\n  var PUSH_SUB_PATH = 3;\n\n  // states\n  var BEFORE_PATH = 0;\n  var IN_PATH = 1;\n  var BEFORE_IDENT = 2;\n  var IN_IDENT = 3;\n  var IN_SUB_PATH = 4;\n  var IN_SINGLE_QUOTE = 5;\n  var IN_DOUBLE_QUOTE = 6;\n  var AFTER_PATH = 7;\n  var ERROR = 8;\n\n  var pathStateMachine = [];\n\n  pathStateMachine[BEFORE_PATH] = {\n    'ws': [BEFORE_PATH],\n    'ident': [IN_IDENT, APPEND],\n    '[': [IN_SUB_PATH],\n    'eof': [AFTER_PATH]\n  };\n\n  pathStateMachine[IN_PATH] = {\n    'ws': [IN_PATH],\n    '.': [BEFORE_IDENT],\n    '[': [IN_SUB_PATH],\n    'eof': [AFTER_PATH]\n  };\n\n  pathStateMachine[BEFORE_IDENT] = {\n    'ws': [BEFORE_IDENT],\n    'ident': [IN_IDENT, APPEND]\n  };\n\n  pathStateMachine[IN_IDENT] = {\n    'ident': [IN_IDENT, APPEND],\n    '0': [IN_IDENT, APPEND],\n    'number': [IN_IDENT, APPEND],\n    'ws': [IN_PATH, PUSH],\n    '.': [BEFORE_IDENT, PUSH],\n    '[': [IN_SUB_PATH, PUSH],\n    'eof': [AFTER_PATH, PUSH]\n  };\n\n  pathStateMachine[IN_SUB_PATH] = {\n    \"'\": [IN_SINGLE_QUOTE, APPEND],\n    '\"': [IN_DOUBLE_QUOTE, APPEND],\n    '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n    ']': [IN_PATH, PUSH_SUB_PATH],\n    'eof': ERROR,\n    'else': [IN_SUB_PATH, APPEND]\n  };\n\n  pathStateMachine[IN_SINGLE_QUOTE] = {\n    \"'\": [IN_SUB_PATH, APPEND],\n    'eof': ERROR,\n    'else': [IN_SINGLE_QUOTE, APPEND]\n  };\n\n  pathStateMachine[IN_DOUBLE_QUOTE] = {\n    '\"': [IN_SUB_PATH, APPEND],\n    'eof': ERROR,\n    'else': [IN_DOUBLE_QUOTE, APPEND]\n  };\n\n  /**\n   * Determine the type of a character in a keypath.\n   *\n   * @param {Char} ch\n   * @return {String} type\n   */\n\n  function getPathCharType(ch) {\n    if (ch === undefined) {\n      return 'eof';\n    }\n\n    var code = ch.charCodeAt(0);\n\n    switch (code) {\n      case 0x5B: // [\n      case 0x5D: // ]\n      case 0x2E: // .\n      case 0x22: // \"\n      case 0x27: // '\n      case 0x30:\n        // 0\n        return ch;\n\n      case 0x5F: // _\n      case 0x24:\n        // $\n        return 'ident';\n\n      case 0x20: // Space\n      case 0x09: // Tab\n      case 0x0A: // Newline\n      case 0x0D: // Return\n      case 0xA0: // No-break space\n      case 0xFEFF: // Byte Order Mark\n      case 0x2028: // Line Separator\n      case 0x2029:\n        // Paragraph Separator\n        return 'ws';\n    }\n\n    // a-z, A-Z\n    if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\n      return 'ident';\n    }\n\n    // 1-9\n    if (code >= 0x31 && code <= 0x39) {\n      return 'number';\n    }\n\n    return 'else';\n  }\n\n  /**\n   * Format a subPath, return its plain form if it is\n   * a literal string or number. Otherwise prepend the\n   * dynamic indicator (*).\n   *\n   * @param {String} path\n   * @return {String}\n   */\n\n  function formatSubPath(path) {\n    var trimmed = path.trim();\n    // invalid leading 0\n    if (path.charAt(0) === '0' && isNaN(path)) {\n      return false;\n    }\n    return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\n  }\n\n  /**\n   * Parse a string path into an array of segments\n   *\n   * @param {String} path\n   * @return {Array|undefined}\n   */\n\n  function parse(path) {\n    var keys = [];\n    var index = -1;\n    var mode = BEFORE_PATH;\n    var subPathDepth = 0;\n    var c, newChar, key, type, transition, action, typeMap;\n\n    var actions = [];\n\n    actions[PUSH] = function () {\n      if (key !== undefined) {\n        keys.push(key);\n        key = undefined;\n      }\n    };\n\n    actions[APPEND] = function () {\n      if (key === undefined) {\n        key = newChar;\n      } else {\n        key += newChar;\n      }\n    };\n\n    actions[INC_SUB_PATH_DEPTH] = function () {\n      actions[APPEND]();\n      subPathDepth++;\n    };\n\n    actions[PUSH_SUB_PATH] = function () {\n      if (subPathDepth > 0) {\n        subPathDepth--;\n        mode = IN_SUB_PATH;\n        actions[APPEND]();\n      } else {\n        subPathDepth = 0;\n        key = formatSubPath(key);\n        if (key === false) {\n          return false;\n        } else {\n          actions[PUSH]();\n        }\n      }\n    };\n\n    function maybeUnescapeQuote() {\n      var nextChar = path[index + 1];\n      if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\n        index++;\n        newChar = '\\\\' + nextChar;\n        actions[APPEND]();\n        return true;\n      }\n    }\n\n    while (mode != null) {\n      index++;\n      c = path[index];\n\n      if (c === '\\\\' && maybeUnescapeQuote()) {\n        continue;\n      }\n\n      type = getPathCharType(c);\n      typeMap = pathStateMachine[mode];\n      transition = typeMap[type] || typeMap['else'] || ERROR;\n\n      if (transition === ERROR) {\n        return; // parse error\n      }\n\n      mode = transition[0];\n      action = actions[transition[1]];\n      if (action) {\n        newChar = transition[2];\n        newChar = newChar === undefined ? c : newChar;\n        if (action() === false) {\n          return;\n        }\n      }\n\n      if (mode === AFTER_PATH) {\n        keys.raw = path;\n        return keys;\n      }\n    }\n  }\n\n  /**\n   * External parse that check for a cache hit first\n   *\n   * @param {String} path\n   * @return {Array|undefined}\n   */\n\n  function parsePath(path) {\n    var hit = pathCache.get(path);\n    if (!hit) {\n      hit = parse(path);\n      if (hit) {\n        pathCache.put(path, hit);\n      }\n    }\n    return hit;\n  }\n\n  /**\n   * Get from an object from a path string\n   *\n   * @param {Object} obj\n   * @param {String} path\n   */\n\n  function getPath(obj, path) {\n    return parseExpression(path).get(obj);\n  }\n\n  /**\n   * Warn against setting non-existent root path on a vm.\n   */\n\n  var warnNonExistent;\n  if ('development' !== 'production') {\n    warnNonExistent = function (path) {\n      warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.');\n    };\n  }\n\n  /**\n   * Set on an object from a path\n   *\n   * @param {Object} obj\n   * @param {String | Array} path\n   * @param {*} val\n   */\n\n  function setPath(obj, path, val) {\n    var original = obj;\n    if (typeof path === 'string') {\n      path = parse(path);\n    }\n    if (!path || !isObject(obj)) {\n      return false;\n    }\n    var last, key;\n    for (var i = 0, l = path.length; i < l; i++) {\n      last = obj;\n      key = path[i];\n      if (key.charAt(0) === '*') {\n        key = parseExpression(key.slice(1)).get.call(original, original);\n      }\n      if (i < l - 1) {\n        obj = obj[key];\n        if (!isObject(obj)) {\n          obj = {};\n          if ('development' !== 'production' && last._isVue) {\n            warnNonExistent(path);\n          }\n          set(last, key, obj);\n        }\n      } else {\n        if (isArray(obj)) {\n          obj.$set(key, val);\n        } else if (key in obj) {\n          obj[key] = val;\n        } else {\n          if ('development' !== 'production' && obj._isVue) {\n            warnNonExistent(path);\n          }\n          set(obj, key, val);\n        }\n      }\n    }\n    return true;\n  }\n\n  var path = Object.freeze({\n    parsePath: parsePath,\n    getPath: getPath,\n    setPath: setPath\n  });\n\n  var expressionCache = new Cache(1000);\n\n  var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\n  var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\n  // keywords that don't make sense inside expressions\n  var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'proctected,static,interface,private,public';\n  var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\n  var wsRE = /\\s/g;\n  var newlineRE = /\\n/g;\n  var saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\")|new |typeof |void /g;\n  var restoreRE = /\"(\\d+)\"/g;\n  var pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\n  var identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\n  var booleanLiteralRE = /^(?:true|false)$/;\n\n  /**\n   * Save / Rewrite / Restore\n   *\n   * When rewriting paths found in an expression, it is\n   * possible for the same letter sequences to be found in\n   * strings and Object literal property keys. Therefore we\n   * remove and store these parts in a temporary array, and\n   * restore them after the path rewrite.\n   */\n\n  var saved = [];\n\n  /**\n   * Save replacer\n   *\n   * The save regex can match two possible cases:\n   * 1. An opening object literal\n   * 2. A string\n   * If matched as a plain string, we need to escape its\n   * newlines, since the string needs to be preserved when\n   * generating the function body.\n   *\n   * @param {String} str\n   * @param {String} isString - str if matched as a string\n   * @return {String} - placeholder with index\n   */\n\n  function save(str, isString) {\n    var i = saved.length;\n    saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\n    return '\"' + i + '\"';\n  }\n\n  /**\n   * Path rewrite replacer\n   *\n   * @param {String} raw\n   * @return {String}\n   */\n\n  function rewrite(raw) {\n    var c = raw.charAt(0);\n    var path = raw.slice(1);\n    if (allowedKeywordsRE.test(path)) {\n      return raw;\n    } else {\n      path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\n      return c + 'scope.' + path;\n    }\n  }\n\n  /**\n   * Restore replacer\n   *\n   * @param {String} str\n   * @param {String} i - matched save index\n   * @return {String}\n   */\n\n  function restore(str, i) {\n    return saved[i];\n  }\n\n  /**\n   * Rewrite an expression, prefixing all path accessors with\n   * `scope.` and generate getter/setter functions.\n   *\n   * @param {String} exp\n   * @return {Function}\n   */\n\n  function compileGetter(exp) {\n    if (improperKeywordsRE.test(exp)) {\n      'development' !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\n    }\n    // reset state\n    saved.length = 0;\n    // save strings and object literal keys\n    var body = exp.replace(saveRE, save).replace(wsRE, '');\n    // rewrite all paths\n    // pad 1 space here becaue the regex matches 1 extra char\n    body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\n    return makeGetterFn(body);\n  }\n\n  /**\n   * Build a getter function. Requires eval.\n   *\n   * We isolate the try/catch so it doesn't affect the\n   * optimization of the parse function when it is not called.\n   *\n   * @param {String} body\n   * @return {Function|undefined}\n   */\n\n  function makeGetterFn(body) {\n    try {\n      return new Function('scope', 'return ' + body + ';');\n    } catch (e) {\n      'development' !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);\n    }\n  }\n\n  /**\n   * Compile a setter function for the expression.\n   *\n   * @param {String} exp\n   * @return {Function|undefined}\n   */\n\n  function compileSetter(exp) {\n    var path = parsePath(exp);\n    if (path) {\n      return function (scope, val) {\n        setPath(scope, path, val);\n      };\n    } else {\n      'development' !== 'production' && warn('Invalid setter expression: ' + exp);\n    }\n  }\n\n  /**\n   * Parse an expression into re-written getter/setters.\n   *\n   * @param {String} exp\n   * @param {Boolean} needSet\n   * @return {Function}\n   */\n\n  function parseExpression(exp, needSet) {\n    exp = exp.trim();\n    // try cache\n    var hit = expressionCache.get(exp);\n    if (hit) {\n      if (needSet && !hit.set) {\n        hit.set = compileSetter(hit.exp);\n      }\n      return hit;\n    }\n    var res = { exp: exp };\n    res.get = isSimplePath(exp) && exp.indexOf('[') < 0\n    // optimized super simple getter\n    ? makeGetterFn('scope.' + exp)\n    // dynamic getter\n    : compileGetter(exp);\n    if (needSet) {\n      res.set = compileSetter(exp);\n    }\n    expressionCache.put(exp, res);\n    return res;\n  }\n\n  /**\n   * Check if an expression is a simple path.\n   *\n   * @param {String} exp\n   * @return {Boolean}\n   */\n\n  function isSimplePath(exp) {\n    return pathTestRE.test(exp) &&\n    // don't treat true/false as paths\n    !booleanLiteralRE.test(exp) &&\n    // Math constants e.g. Math.PI, Math.E etc.\n    exp.slice(0, 5) !== 'Math.';\n  }\n\n  var expression = Object.freeze({\n    parseExpression: parseExpression,\n    isSimplePath: isSimplePath\n  });\n\n  // we have two separate queues: one for directive updates\n  // and one for user watcher registered via $watch().\n  // we want to guarantee directive updates to be called\n  // before user watchers so that when user watchers are\n  // triggered, the DOM would have already been in updated\n  // state.\n  var queue = [];\n  var userQueue = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var internalQueueDepleted = false;\n\n  /**\n   * Reset the batcher's state.\n   */\n\n  function resetBatcherState() {\n    queue = [];\n    userQueue = [];\n    has = {};\n    circular = {};\n    waiting = internalQueueDepleted = false;\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n\n  function flushBatcherQueue() {\n    runBatcherQueue(queue);\n    internalQueueDepleted = true;\n    runBatcherQueue(userQueue);\n    // dev tool hook\n    /* istanbul ignore if */\n    if ('development' !== 'production') {\n      if (inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {\n        window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush');\n      }\n    }\n    resetBatcherState();\n  }\n\n  /**\n   * Run the watchers in a single queue.\n   *\n   * @param {Array} queue\n   */\n\n  function runBatcherQueue(queue) {\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (var i = 0; i < queue.length; i++) {\n      var watcher = queue[i];\n      var id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if ('development' !== 'production' && has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > config._maxUpdateCount) {\n          queue.splice(has[id], 1);\n          warn('You may have an infinite update loop for watcher ' + 'with expression: ' + watcher.expression);\n        }\n      }\n    }\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   *\n   * @param {Watcher} watcher\n   *   properties:\n   *   - {Number} id\n   *   - {Function} run\n   */\n\n  function pushWatcher(watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      // if an internal watcher is pushed, but the internal\n      // queue is already depleted, we run it immediately.\n      if (internalQueueDepleted && !watcher.user) {\n        watcher.run();\n        return;\n      }\n      // push watcher into appropriate queue\n      var q = watcher.user ? userQueue : queue;\n      has[id] = q.length;\n      q.push(watcher);\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n        nextTick(flushBatcherQueue);\n      }\n    }\n  }\n\n  var uid$2 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   *\n   * @param {Vue} vm\n   * @param {String} expression\n   * @param {Function} cb\n   * @param {Object} options\n   *                 - {Array} filters\n   *                 - {Boolean} twoWay\n   *                 - {Boolean} deep\n   *                 - {Boolean} user\n   *                 - {Boolean} sync\n   *                 - {Boolean} lazy\n   *                 - {Function} [preProcess]\n   *                 - {Function} [postProcess]\n   * @constructor\n   */\n  function Watcher(vm, expOrFn, cb, options) {\n    // mix in options\n    if (options) {\n      extend(this, options);\n    }\n    var isFn = typeof expOrFn === 'function';\n    this.vm = vm;\n    vm._watchers.push(this);\n    this.expression = isFn ? expOrFn.toString() : expOrFn;\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n    this.deps = Object.create(null);\n    this.newDeps = null;\n    this.prevError = null; // for async error stacks\n    // parse expression for getter/setter\n    if (isFn) {\n      this.getter = expOrFn;\n      this.setter = undefined;\n    } else {\n      var res = parseExpression(expOrFn, this.twoWay);\n      this.getter = res.get;\n      this.setter = res.set;\n    }\n    this.value = this.lazy ? undefined : this.get();\n    // state for avoiding false triggers for deep and Array\n    // watchers during vm._digest()\n    this.queued = this.shallow = false;\n  }\n\n  /**\n   * Add a dependency to this directive.\n   *\n   * @param {Dep} dep\n   */\n\n  Watcher.prototype.addDep = function (dep) {\n    var id = dep.id;\n    if (!this.newDeps[id]) {\n      this.newDeps[id] = dep;\n      if (!this.deps[id]) {\n        this.deps[id] = dep;\n        dep.addSub(this);\n      }\n    }\n  };\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n\n  Watcher.prototype.get = function () {\n    this.beforeGet();\n    var scope = this.scope || this.vm;\n    var value;\n    try {\n      value = this.getter.call(scope, scope);\n    } catch (e) {\n      if ('development' !== 'production' && config.warnExpressionErrors) {\n        warn('Error when evaluating expression \"' + this.expression + '\". ' + (config.debug ? '' : 'Turn on debug mode to see stack trace.'), e);\n      }\n    }\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    if (this.preProcess) {\n      value = this.preProcess(value);\n    }\n    if (this.filters) {\n      value = scope._applyFilters(value, null, this.filters, false);\n    }\n    if (this.postProcess) {\n      value = this.postProcess(value);\n    }\n    this.afterGet();\n    return value;\n  };\n\n  /**\n   * Set the corresponding value with the setter.\n   *\n   * @param {*} value\n   */\n\n  Watcher.prototype.set = function (value) {\n    var scope = this.scope || this.vm;\n    if (this.filters) {\n      value = scope._applyFilters(value, this.value, this.filters, true);\n    }\n    try {\n      this.setter.call(scope, scope, value);\n    } catch (e) {\n      if ('development' !== 'production' && config.warnExpressionErrors) {\n        warn('Error when evaluating setter \"' + this.expression + '\"', e);\n      }\n    }\n    // two-way sync for v-for alias\n    var forContext = scope.$forContext;\n    if (forContext && forContext.alias === this.expression) {\n      if (forContext.filters) {\n        'development' !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.');\n        return;\n      }\n      forContext._withLock(function () {\n        if (scope.$key) {\n          // original is an object\n          forContext.rawValue[scope.$key] = value;\n        } else {\n          forContext.rawValue.$set(scope.$index, value);\n        }\n      });\n    }\n  };\n\n  /**\n   * Prepare for dependency collection.\n   */\n\n  Watcher.prototype.beforeGet = function () {\n    Dep.target = this;\n    this.newDeps = Object.create(null);\n  };\n\n  /**\n   * Clean up for dependency collection.\n   */\n\n  Watcher.prototype.afterGet = function () {\n    Dep.target = null;\n    var ids = Object.keys(this.deps);\n    var i = ids.length;\n    while (i--) {\n      var id = ids[i];\n      if (!this.newDeps[id]) {\n        this.deps[id].removeSub(this);\n      }\n    }\n    this.deps = this.newDeps;\n  };\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   *\n   * @param {Boolean} shallow\n   */\n\n  Watcher.prototype.update = function (shallow) {\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync || !config.async) {\n      this.run();\n    } else {\n      // if queued, only overwrite shallow with non-shallow,\n      // but not the other way around.\n      this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\n      this.queued = true;\n      // record before-push error stack in debug mode\n      /* istanbul ignore if */\n      if ('development' !== 'production' && config.debug) {\n        this.prevError = new Error('[vue] async stack trace');\n      }\n      pushWatcher(this);\n    }\n  };\n\n  /**\n   * Batcher job interface.\n   * Will be called by the batcher.\n   */\n\n  Watcher.prototype.run = function () {\n    if (this.active) {\n      var value = this.get();\n      if (value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated; but only do so if this is a\n      // non-shallow update (caused by a vm digest).\n      (isObject(value) || this.deep) && !this.shallow) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n        // in debug + async mode, when a watcher callbacks\n        // throws, we also throw the saved before-push error\n        // so the full cross-tick stack trace is available.\n        var prevError = this.prevError;\n        /* istanbul ignore if */\n        if ('development' !== 'production' && config.debug && prevError) {\n          this.prevError = null;\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            nextTick(function () {\n              throw prevError;\n            }, 0);\n            throw e;\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n      this.queued = this.shallow = false;\n    }\n  };\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n\n  Watcher.prototype.evaluate = function () {\n    // avoid overwriting another watcher that is being\n    // collected.\n    var current = Dep.target;\n    this.value = this.get();\n    this.dirty = false;\n    Dep.target = current;\n  };\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n\n  Watcher.prototype.depend = function () {\n    var depIds = Object.keys(this.deps);\n    var i = depIds.length;\n    while (i--) {\n      this.deps[depIds[i]].depend();\n    }\n  };\n\n  /**\n   * Remove self from all dependencies' subcriber list.\n   */\n\n  Watcher.prototype.teardown = function () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // we can skip this if the vm if being destroyed\n      // which can improve teardown performance.\n      if (!this.vm._isBeingDestroyed) {\n        this.vm._watchers.$remove(this);\n      }\n      var depIds = Object.keys(this.deps);\n      var i = depIds.length;\n      while (i--) {\n        this.deps[depIds[i]].removeSub(this);\n      }\n      this.active = false;\n      this.vm = this.cb = this.value = null;\n    }\n  };\n\n  /**\n   * Recrusively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   *\n   * @param {*} val\n   */\n\n  function traverse(val) {\n    var i, keys;\n    if (isArray(val)) {\n      i = val.length;\n      while (i--) traverse(val[i]);\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) traverse(val[keys[i]]);\n    }\n  }\n\n  var cloak = {\n    bind: function bind() {\n      var el = this.el;\n      this.vm.$once('pre-hook:compiled', function () {\n        el.removeAttribute('v-cloak');\n      });\n    }\n  };\n\n  var ref = {\n    bind: function bind() {\n      'development' !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.');\n    }\n  };\n\n  var ON = 700;\n  var MODEL = 800;\n  var BIND = 850;\n  var TRANSITION = 1100;\n  var EL = 1500;\n  var COMPONENT = 1500;\n  var PARTIAL = 1750;\n  var SLOT = 1750;\n  var FOR = 2000;\n  var IF = 2000;\n\n  var el = {\n\n    priority: EL,\n\n    bind: function bind() {\n      /* istanbul ignore if */\n      if (!this.arg) {\n        return;\n      }\n      var id = this.id = camelize(this.arg);\n      var refs = (this._scope || this.vm).$els;\n      if (hasOwn(refs, id)) {\n        refs[id] = this.el;\n      } else {\n        defineReactive(refs, id, this.el);\n      }\n    },\n\n    unbind: function unbind() {\n      var refs = (this._scope || this.vm).$els;\n      if (refs[this.id] === this.el) {\n        refs[this.id] = null;\n      }\n    }\n  };\n\n  var prefixes = ['-webkit-', '-moz-', '-ms-'];\n  var camelPrefixes = ['Webkit', 'Moz', 'ms'];\n  var importantRE = /!important;?$/;\n  var propCache = Object.create(null);\n\n  var testEl = null;\n\n  var style = {\n\n    deep: true,\n\n    update: function update(value) {\n      if (typeof value === 'string') {\n        this.el.style.cssText = value;\n      } else if (isArray(value)) {\n        this.handleObject(value.reduce(extend, {}));\n      } else {\n        this.handleObject(value || {});\n      }\n    },\n\n    handleObject: function handleObject(value) {\n      // cache object styles so that only changed props\n      // are actually updated.\n      var cache = this.cache || (this.cache = {});\n      var name, val;\n      for (name in cache) {\n        if (!(name in value)) {\n          this.handleSingle(name, null);\n          delete cache[name];\n        }\n      }\n      for (name in value) {\n        val = value[name];\n        if (val !== cache[name]) {\n          cache[name] = val;\n          this.handleSingle(name, val);\n        }\n      }\n    },\n\n    handleSingle: function handleSingle(prop, value) {\n      prop = normalize(prop);\n      if (!prop) return; // unsupported prop\n      // cast possible numbers/booleans into strings\n      if (value != null) value += '';\n      if (value) {\n        var isImportant = importantRE.test(value) ? 'important' : '';\n        if (isImportant) {\n          value = value.replace(importantRE, '').trim();\n        }\n        this.el.style.setProperty(prop, value, isImportant);\n      } else {\n        this.el.style.removeProperty(prop);\n      }\n    }\n\n  };\n\n  /**\n   * Normalize a CSS property name.\n   * - cache result\n   * - auto prefix\n   * - camelCase -> dash-case\n   *\n   * @param {String} prop\n   * @return {String}\n   */\n\n  function normalize(prop) {\n    if (propCache[prop]) {\n      return propCache[prop];\n    }\n    var res = prefix(prop);\n    propCache[prop] = propCache[res] = res;\n    return res;\n  }\n\n  /**\n   * Auto detect the appropriate prefix for a CSS property.\n   * https://gist.github.com/paulirish/523692\n   *\n   * @param {String} prop\n   * @return {String}\n   */\n\n  function prefix(prop) {\n    prop = hyphenate(prop);\n    var camel = camelize(prop);\n    var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\n    if (!testEl) {\n      testEl = document.createElement('div');\n    }\n    if (camel in testEl.style) {\n      return prop;\n    }\n    var i = prefixes.length;\n    var prefixed;\n    while (i--) {\n      prefixed = camelPrefixes[i] + upper;\n      if (prefixed in testEl.style) {\n        return prefixes[i] + prop;\n      }\n    }\n  }\n\n  // xlink\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n  var xlinkRE = /^xlink:/;\n\n  // check for attributes that prohibit interpolations\n  var disallowedInterpAttrRE = /^v-|^:|^@|^(is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\n\n  // these attributes should also set their corresponding properties\n  // because they only affect the initial state of the element\n  var attrWithPropsRE = /^(value|checked|selected|muted)$/;\n\n  // these attributes should set a hidden property for\n  // binding v-model to object values\n  var modelProps = {\n    value: '_value',\n    'true-value': '_trueValue',\n    'false-value': '_falseValue'\n  };\n\n  var bind = {\n\n    priority: BIND,\n\n    bind: function bind() {\n      var attr = this.arg;\n      var tag = this.el.tagName;\n      // should be deep watch on object mode\n      if (!attr) {\n        this.deep = true;\n      }\n      // handle interpolation bindings\n      var descriptor = this.descriptor;\n      var tokens = descriptor.interp;\n      if (tokens) {\n        // handle interpolations with one-time tokens\n        if (descriptor.hasOneTime) {\n          this.expression = tokensToExp(tokens, this._scope || this.vm);\n        }\n\n        // only allow binding on native attributes\n        if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\n          'development' !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.');\n          this.el.removeAttribute(attr);\n          this.invalid = true;\n        }\n\n        /* istanbul ignore if */\n        if ('development' !== 'production') {\n          var raw = attr + '=\"' + descriptor.raw + '\": ';\n          // warn src\n          if (attr === 'src') {\n            warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.');\n          }\n\n          // warn style\n          if (attr === 'style') {\n            warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.');\n          }\n        }\n      }\n    },\n\n    update: function update(value) {\n      if (this.invalid) {\n        return;\n      }\n      var attr = this.arg;\n      if (this.arg) {\n        this.handleSingle(attr, value);\n      } else {\n        this.handleObject(value || {});\n      }\n    },\n\n    // share object handler with v-bind:class\n    handleObject: style.handleObject,\n\n    handleSingle: function handleSingle(attr, value) {\n      var el = this.el;\n      var interp = this.descriptor.interp;\n      if (!interp && attrWithPropsRE.test(attr) && attr in el) {\n        el[attr] = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\n        ? '' : value : value;\n      }\n      // set model props\n      var modelProp = modelProps[attr];\n      if (!interp && modelProp) {\n        el[modelProp] = value;\n        // update v-model if present\n        var model = el.__v_model;\n        if (model) {\n          model.listener();\n        }\n      }\n      // do not set value attribute for textarea\n      if (attr === 'value' && el.tagName === 'TEXTAREA') {\n        el.removeAttribute(attr);\n        return;\n      }\n      // update attribute\n      if (value != null && value !== false) {\n        if (attr === 'class') {\n          // handle edge case #1960:\n          // class interpolation should not overwrite Vue transition class\n          if (el.__v_trans) {\n            value += ' ' + el.__v_trans.id + '-transition';\n          }\n          setClass(el, value);\n        } else if (xlinkRE.test(attr)) {\n          el.setAttributeNS(xlinkNS, attr, value);\n        } else {\n          el.setAttribute(attr, value);\n        }\n      } else {\n        el.removeAttribute(attr);\n      }\n    }\n  };\n\n  // keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    'delete': 46,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40\n  };\n\n  function keyFilter(handler, keys) {\n    var codes = keys.map(function (key) {\n      var charCode = key.charCodeAt(0);\n      if (charCode > 47 && charCode < 58) {\n        return parseInt(key, 10);\n      }\n      if (key.length === 1) {\n        charCode = key.toUpperCase().charCodeAt(0);\n        if (charCode > 64 && charCode < 91) {\n          return charCode;\n        }\n      }\n      return keyCodes[key];\n    });\n    return function keyHandler(e) {\n      if (codes.indexOf(e.keyCode) > -1) {\n        return handler.call(this, e);\n      }\n    };\n  }\n\n  function stopFilter(handler) {\n    return function stopHandler(e) {\n      e.stopPropagation();\n      return handler.call(this, e);\n    };\n  }\n\n  function preventFilter(handler) {\n    return function preventHandler(e) {\n      e.preventDefault();\n      return handler.call(this, e);\n    };\n  }\n\n  var on = {\n\n    acceptStatement: true,\n    priority: ON,\n\n    bind: function bind() {\n      // deal with iframes\n      if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\n        var self = this;\n        this.iframeBind = function () {\n          on$1(self.el.contentWindow, self.arg, self.handler);\n        };\n        this.on('load', this.iframeBind);\n      }\n    },\n\n    update: function update(handler) {\n      // stub a noop for v-on with no value,\n      // e.g. @mousedown.prevent\n      if (!this.descriptor.raw) {\n        handler = function () {};\n      }\n\n      if (typeof handler !== 'function') {\n        'development' !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler);\n        return;\n      }\n\n      // apply modifiers\n      if (this.modifiers.stop) {\n        handler = stopFilter(handler);\n      }\n      if (this.modifiers.prevent) {\n        handler = preventFilter(handler);\n      }\n      // key filter\n      var keys = Object.keys(this.modifiers).filter(function (key) {\n        return key !== 'stop' && key !== 'prevent';\n      });\n      if (keys.length) {\n        handler = keyFilter(handler, keys);\n      }\n\n      this.reset();\n      this.handler = handler;\n\n      if (this.iframeBind) {\n        this.iframeBind();\n      } else {\n        on$1(this.el, this.arg, this.handler);\n      }\n    },\n\n    reset: function reset() {\n      var el = this.iframeBind ? this.el.contentWindow : this.el;\n      if (this.handler) {\n        off(el, this.arg, this.handler);\n      }\n    },\n\n    unbind: function unbind() {\n      this.reset();\n    }\n  };\n\n  var checkbox = {\n\n    bind: function bind() {\n      var self = this;\n      var el = this.el;\n\n      this.getValue = function () {\n        return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\n      };\n\n      function getBooleanValue() {\n        var val = el.checked;\n        if (val && el.hasOwnProperty('_trueValue')) {\n          return el._trueValue;\n        }\n        if (!val && el.hasOwnProperty('_falseValue')) {\n          return el._falseValue;\n        }\n        return val;\n      }\n\n      this.listener = function () {\n        var model = self._watcher.value;\n        if (isArray(model)) {\n          var val = self.getValue();\n          if (el.checked) {\n            if (indexOf(model, val) < 0) {\n              model.push(val);\n            }\n          } else {\n            model.$remove(val);\n          }\n        } else {\n          self.set(getBooleanValue());\n        }\n      };\n\n      this.on('change', this.listener);\n      if (el.hasAttribute('checked')) {\n        this.afterBind = this.listener;\n      }\n    },\n\n    update: function update(value) {\n      var el = this.el;\n      if (isArray(value)) {\n        el.checked = indexOf(value, this.getValue()) > -1;\n      } else {\n        if (el.hasOwnProperty('_trueValue')) {\n          el.checked = looseEqual(value, el._trueValue);\n        } else {\n          el.checked = !!value;\n        }\n      }\n    }\n  };\n\n  var select = {\n\n    bind: function bind() {\n      var self = this;\n      var el = this.el;\n\n      // method to force update DOM using latest value.\n      this.forceUpdate = function () {\n        if (self._watcher) {\n          self.update(self._watcher.get());\n        }\n      };\n\n      // check if this is a multiple select\n      var multiple = this.multiple = el.hasAttribute('multiple');\n\n      // attach listener\n      this.listener = function () {\n        var value = getValue(el, multiple);\n        value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\n        self.set(value);\n      };\n      this.on('change', this.listener);\n\n      // if has initial value, set afterBind\n      var initValue = getValue(el, multiple, true);\n      if (multiple && initValue.length || !multiple && initValue !== null) {\n        this.afterBind = this.listener;\n      }\n\n      // All major browsers except Firefox resets\n      // selectedIndex with value -1 to 0 when the element\n      // is appended to a new parent, therefore we have to\n      // force a DOM update whenever that happens...\n      this.vm.$on('hook:attached', this.forceUpdate);\n    },\n\n    update: function update(value) {\n      var el = this.el;\n      el.selectedIndex = -1;\n      var multi = this.multiple && isArray(value);\n      var options = el.options;\n      var i = options.length;\n      var op, val;\n      while (i--) {\n        op = options[i];\n        val = op.hasOwnProperty('_value') ? op._value : op.value;\n        /* eslint-disable eqeqeq */\n        op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\n        /* eslint-enable eqeqeq */\n      }\n    },\n\n    unbind: function unbind() {\n      /* istanbul ignore next */\n      this.vm.$off('hook:attached', this.forceUpdate);\n    }\n  };\n\n  /**\n   * Get select value\n   *\n   * @param {SelectElement} el\n   * @param {Boolean} multi\n   * @param {Boolean} init\n   * @return {Array|*}\n   */\n\n  function getValue(el, multi, init) {\n    var res = multi ? [] : null;\n    var op, val, selected;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      op = el.options[i];\n      selected = init ? op.hasAttribute('selected') : op.selected;\n      if (selected) {\n        val = op.hasOwnProperty('_value') ? op._value : op.value;\n        if (multi) {\n          res.push(val);\n        } else {\n          return val;\n        }\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Native Array.indexOf uses strict equal, but in this\n   * case we need to match string/numbers with custom equal.\n   *\n   * @param {Array} arr\n   * @param {*} val\n   */\n\n  function indexOf$1(arr, val) {\n    var i = arr.length;\n    while (i--) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  var radio = {\n\n    bind: function bind() {\n      var self = this;\n      var el = this.el;\n\n      this.getValue = function () {\n        // value overwrite via v-bind:value\n        if (el.hasOwnProperty('_value')) {\n          return el._value;\n        }\n        var val = el.value;\n        if (self.params.number) {\n          val = toNumber(val);\n        }\n        return val;\n      };\n\n      this.listener = function () {\n        self.set(self.getValue());\n      };\n      this.on('change', this.listener);\n\n      if (el.hasAttribute('checked')) {\n        this.afterBind = this.listener;\n      }\n    },\n\n    update: function update(value) {\n      this.el.checked = looseEqual(value, this.getValue());\n    }\n  };\n\n  var text$2 = {\n\n    bind: function bind() {\n      var self = this;\n      var el = this.el;\n      var isRange = el.type === 'range';\n      var lazy = this.params.lazy;\n      var number = this.params.number;\n      var debounce = this.params.debounce;\n\n      // handle composition events.\n      //   http://blog.evanyou.me/2014/01/03/composition-event/\n      // skip this for Android because it handles composition\n      // events quite differently. Android doesn't trigger\n      // composition events for language input methods e.g.\n      // Chinese, but instead triggers them for spelling\n      // suggestions... (see Discussion/#162)\n      var composing = false;\n      if (!isAndroid && !isRange) {\n        this.on('compositionstart', function () {\n          composing = true;\n        });\n        this.on('compositionend', function () {\n          composing = false;\n          // in IE11 the \"compositionend\" event fires AFTER\n          // the \"input\" event, so the input handler is blocked\n          // at the end... have to call it here.\n          //\n          // #1327: in lazy mode this is unecessary.\n          if (!lazy) {\n            self.listener();\n          }\n        });\n      }\n\n      // prevent messing with the input when user is typing,\n      // and force update on blur.\n      this.focused = false;\n      if (!isRange && !lazy) {\n        this.on('focus', function () {\n          self.focused = true;\n        });\n        this.on('blur', function () {\n          self.focused = false;\n          // do not sync value after fragment removal (#2017)\n          if (!self._frag || self._frag.inserted) {\n            self.rawListener();\n          }\n        });\n      }\n\n      // Now attach the main listener\n      this.listener = this.rawListener = function () {\n        if (composing || !self._bound) {\n          return;\n        }\n        var val = number || isRange ? toNumber(el.value) : el.value;\n        self.set(val);\n        // force update on next tick to avoid lock & same value\n        // also only update when user is not typing\n        nextTick(function () {\n          if (self._bound && !self.focused) {\n            self.update(self._watcher.value);\n          }\n        });\n      };\n\n      // apply debounce\n      if (debounce) {\n        this.listener = _debounce(this.listener, debounce);\n      }\n\n      // Support jQuery events, since jQuery.trigger() doesn't\n      // trigger native events in some cases and some plugins\n      // rely on $.trigger()\n      //\n      // We want to make sure if a listener is attached using\n      // jQuery, it is also removed with jQuery, that's why\n      // we do the check for each directive instance and\n      // store that check result on itself. This also allows\n      // easier test coverage control by unsetting the global\n      // jQuery variable in tests.\n      this.hasjQuery = typeof jQuery === 'function';\n      if (this.hasjQuery) {\n        jQuery(el).on('change', this.listener);\n        if (!lazy) {\n          jQuery(el).on('input', this.listener);\n        }\n      } else {\n        this.on('change', this.listener);\n        if (!lazy) {\n          this.on('input', this.listener);\n        }\n      }\n\n      // IE9 doesn't fire input event on backspace/del/cut\n      if (!lazy && isIE9) {\n        this.on('cut', function () {\n          nextTick(self.listener);\n        });\n        this.on('keyup', function (e) {\n          if (e.keyCode === 46 || e.keyCode === 8) {\n            self.listener();\n          }\n        });\n      }\n\n      // set initial value if present\n      if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\n        this.afterBind = this.listener;\n      }\n    },\n\n    update: function update(value) {\n      this.el.value = _toString(value);\n    },\n\n    unbind: function unbind() {\n      var el = this.el;\n      if (this.hasjQuery) {\n        jQuery(el).off('change', this.listener);\n        jQuery(el).off('input', this.listener);\n      }\n    }\n  };\n\n  var handlers = {\n    text: text$2,\n    radio: radio,\n    select: select,\n    checkbox: checkbox\n  };\n\n  var model = {\n\n    priority: MODEL,\n    twoWay: true,\n    handlers: handlers,\n    params: ['lazy', 'number', 'debounce'],\n\n    /**\n     * Possible elements:\n     *   <select>\n     *   <textarea>\n     *   <input type=\"*\">\n     *     - text\n     *     - checkbox\n     *     - radio\n     *     - number\n     */\n\n    bind: function bind() {\n      // friendly warning...\n      this.checkFilters();\n      if (this.hasRead && !this.hasWrite) {\n        'development' !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model. You might want to use a two-way filter ' + 'to ensure correct behavior.');\n      }\n      var el = this.el;\n      var tag = el.tagName;\n      var handler;\n      if (tag === 'INPUT') {\n        handler = handlers[el.type] || handlers.text;\n      } else if (tag === 'SELECT') {\n        handler = handlers.select;\n      } else if (tag === 'TEXTAREA') {\n        handler = handlers.text;\n      } else {\n        'development' !== 'production' && warn('v-model does not support element type: ' + tag);\n        return;\n      }\n      el.__v_model = this;\n      handler.bind.call(this);\n      this.update = handler.update;\n      this._unbind = handler.unbind;\n    },\n\n    /**\n     * Check read/write filter stats.\n     */\n\n    checkFilters: function checkFilters() {\n      var filters = this.filters;\n      if (!filters) return;\n      var i = filters.length;\n      while (i--) {\n        var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\n        if (typeof filter === 'function' || filter.read) {\n          this.hasRead = true;\n        }\n        if (filter.write) {\n          this.hasWrite = true;\n        }\n      }\n    },\n\n    unbind: function unbind() {\n      this.el.__v_model = null;\n      this._unbind && this._unbind();\n    }\n  };\n\n  var show = {\n\n    bind: function bind() {\n      // check else block\n      var next = this.el.nextElementSibling;\n      if (next && getAttr(next, 'v-else') !== null) {\n        this.elseEl = next;\n      }\n    },\n\n    update: function update(value) {\n      this.apply(this.el, value);\n      if (this.elseEl) {\n        this.apply(this.elseEl, !value);\n      }\n    },\n\n    apply: function apply(el, value) {\n      if (inDoc(el)) {\n        applyTransition(el, value ? 1 : -1, toggle, this.vm);\n      } else {\n        toggle();\n      }\n      function toggle() {\n        el.style.display = value ? '' : 'none';\n      }\n    }\n  };\n\n  var templateCache = new Cache(1000);\n  var idSelectorCache = new Cache(1000);\n\n  var map = {\n    efault: [0, '', ''],\n    legend: [1, '<fieldset>', '</fieldset>'],\n    tr: [2, '<table><tbody>', '</tbody></table>'],\n    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\n  };\n\n  map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\n  map.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\n  map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\n\n  map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\n\n  /**\n   * Check if a node is a supported template node with a\n   * DocumentFragment content.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  function isRealTemplate(node) {\n    return isTemplate(node) && node.content instanceof DocumentFragment;\n  }\n\n  var tagRE$1 = /<([\\w:]+)/;\n  var entityRE = /&#?\\w+?;/;\n\n  /**\n   * Convert a string template to a DocumentFragment.\n   * Determines correct wrapping by tag types. Wrapping\n   * strategy found in jQuery & component/domify.\n   *\n   * @param {String} templateString\n   * @param {Boolean} raw\n   * @return {DocumentFragment}\n   */\n\n  function stringToFragment(templateString, raw) {\n    // try a cache hit first\n    var hit = templateCache.get(templateString);\n    if (hit) {\n      return hit;\n    }\n\n    var frag = document.createDocumentFragment();\n    var tagMatch = templateString.match(tagRE$1);\n    var entityMatch = entityRE.test(templateString);\n\n    if (!tagMatch && !entityMatch) {\n      // text only, return a single text node.\n      frag.appendChild(document.createTextNode(templateString));\n    } else {\n\n      var tag = tagMatch && tagMatch[1];\n      var wrap = map[tag] || map.efault;\n      var depth = wrap[0];\n      var prefix = wrap[1];\n      var suffix = wrap[2];\n      var node = document.createElement('div');\n\n      if (!raw) {\n        templateString = templateString.trim();\n      }\n      node.innerHTML = prefix + templateString + suffix;\n      while (depth--) {\n        node = node.lastChild;\n      }\n\n      var child;\n      /* eslint-disable no-cond-assign */\n      while (child = node.firstChild) {\n        /* eslint-enable no-cond-assign */\n        frag.appendChild(child);\n      }\n    }\n\n    templateCache.put(templateString, frag);\n    return frag;\n  }\n\n  /**\n   * Convert a template node to a DocumentFragment.\n   *\n   * @param {Node} node\n   * @return {DocumentFragment}\n   */\n\n  function nodeToFragment(node) {\n    // if its a template tag and the browser supports it,\n    // its content is already a document fragment.\n    if (isRealTemplate(node)) {\n      trimNode(node.content);\n      return node.content;\n    }\n    // script template\n    if (node.tagName === 'SCRIPT') {\n      return stringToFragment(node.textContent);\n    }\n    // normal node, clone it to avoid mutating the original\n    var clonedNode = cloneNode(node);\n    var frag = document.createDocumentFragment();\n    var child;\n    /* eslint-disable no-cond-assign */\n    while (child = clonedNode.firstChild) {\n      /* eslint-enable no-cond-assign */\n      frag.appendChild(child);\n    }\n    trimNode(frag);\n    return frag;\n  }\n\n  // Test for the presence of the Safari template cloning bug\n  // https://bugs.webkit.org/showug.cgi?id=137755\n  var hasBrokenTemplate = (function () {\n    /* istanbul ignore else */\n    if (inBrowser) {\n      var a = document.createElement('div');\n      a.innerHTML = '<template>1</template>';\n      return !a.cloneNode(true).firstChild.innerHTML;\n    } else {\n      return false;\n    }\n  })();\n\n  // Test for IE10/11 textarea placeholder clone bug\n  var hasTextareaCloneBug = (function () {\n    /* istanbul ignore else */\n    if (inBrowser) {\n      var t = document.createElement('textarea');\n      t.placeholder = 't';\n      return t.cloneNode(true).value === 't';\n    } else {\n      return false;\n    }\n  })();\n\n  /**\n   * 1. Deal with Safari cloning nested <template> bug by\n   *    manually cloning all template instances.\n   * 2. Deal with IE10/11 textarea placeholder bug by setting\n   *    the correct value after cloning.\n   *\n   * @param {Element|DocumentFragment} node\n   * @return {Element|DocumentFragment}\n   */\n\n  function cloneNode(node) {\n    if (!node.querySelectorAll) {\n      return node.cloneNode();\n    }\n    var res = node.cloneNode(true);\n    var i, original, cloned;\n    /* istanbul ignore if */\n    if (hasBrokenTemplate) {\n      var tempClone = res;\n      if (isRealTemplate(node)) {\n        node = node.content;\n        tempClone = res.content;\n      }\n      original = node.querySelectorAll('template');\n      if (original.length) {\n        cloned = tempClone.querySelectorAll('template');\n        i = cloned.length;\n        while (i--) {\n          cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\n        }\n      }\n    }\n    /* istanbul ignore if */\n    if (hasTextareaCloneBug) {\n      if (node.tagName === 'TEXTAREA') {\n        res.value = node.value;\n      } else {\n        original = node.querySelectorAll('textarea');\n        if (original.length) {\n          cloned = res.querySelectorAll('textarea');\n          i = cloned.length;\n          while (i--) {\n            cloned[i].value = original[i].value;\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Process the template option and normalizes it into a\n   * a DocumentFragment that can be used as a partial or a\n   * instance template.\n   *\n   * @param {*} template\n   *        Possible values include:\n   *        - DocumentFragment object\n   *        - Node object of type Template\n   *        - id selector: '#some-template-id'\n   *        - template string: '<div><span>{{msg}}</span></div>'\n   * @param {Boolean} shouldClone\n   * @param {Boolean} raw\n   *        inline HTML interpolation. Do not check for id\n   *        selector and keep whitespace in the string.\n   * @return {DocumentFragment|undefined}\n   */\n\n  function parseTemplate(template, shouldClone, raw) {\n    var node, frag;\n\n    // if the template is already a document fragment,\n    // do nothing\n    if (template instanceof DocumentFragment) {\n      trimNode(template);\n      return shouldClone ? cloneNode(template) : template;\n    }\n\n    if (typeof template === 'string') {\n      // id selector\n      if (!raw && template.charAt(0) === '#') {\n        // id selector can be cached too\n        frag = idSelectorCache.get(template);\n        if (!frag) {\n          node = document.getElementById(template.slice(1));\n          if (node) {\n            frag = nodeToFragment(node);\n            // save selector to cache\n            idSelectorCache.put(template, frag);\n          }\n        }\n      } else {\n        // normal string template\n        frag = stringToFragment(template, raw);\n      }\n    } else if (template.nodeType) {\n      // a direct node\n      frag = nodeToFragment(template);\n    }\n\n    return frag && shouldClone ? cloneNode(frag) : frag;\n  }\n\n  var template = Object.freeze({\n    cloneNode: cloneNode,\n    parseTemplate: parseTemplate\n  });\n\n  /**\n   * Abstraction for a partially-compiled fragment.\n   * Can optionally compile content with a child scope.\n   *\n   * @param {Function} linker\n   * @param {Vue} vm\n   * @param {DocumentFragment} frag\n   * @param {Vue} [host]\n   * @param {Object} [scope]\n   */\n  function Fragment(linker, vm, frag, host, scope, parentFrag) {\n    this.children = [];\n    this.childFrags = [];\n    this.vm = vm;\n    this.scope = scope;\n    this.inserted = false;\n    this.parentFrag = parentFrag;\n    if (parentFrag) {\n      parentFrag.childFrags.push(this);\n    }\n    this.unlink = linker(vm, frag, host, scope, this);\n    var single = this.single = frag.childNodes.length === 1 &&\n    // do not go single mode if the only node is an anchor\n    !frag.childNodes[0].__vue_anchor;\n    if (single) {\n      this.node = frag.childNodes[0];\n      this.before = singleBefore;\n      this.remove = singleRemove;\n    } else {\n      this.node = createAnchor('fragment-start');\n      this.end = createAnchor('fragment-end');\n      this.frag = frag;\n      prepend(this.node, frag);\n      frag.appendChild(this.end);\n      this.before = multiBefore;\n      this.remove = multiRemove;\n    }\n    this.node.__vfrag__ = this;\n  }\n\n  /**\n   * Call attach/detach for all components contained within\n   * this fragment. Also do so recursively for all child\n   * fragments.\n   *\n   * @param {Function} hook\n   */\n\n  Fragment.prototype.callHook = function (hook) {\n    var i, l;\n    for (i = 0, l = this.childFrags.length; i < l; i++) {\n      this.childFrags[i].callHook(hook);\n    }\n    for (i = 0, l = this.children.length; i < l; i++) {\n      hook(this.children[i]);\n    }\n  };\n\n  /**\n   * Insert fragment before target, single node version\n   *\n   * @param {Node} target\n   * @param {Boolean} withTransition\n   */\n\n  function singleBefore(target, withTransition) {\n    this.inserted = true;\n    var method = withTransition !== false ? beforeWithTransition : before;\n    method(this.node, target, this.vm);\n    if (inDoc(this.node)) {\n      this.callHook(attach);\n    }\n  }\n\n  /**\n   * Remove fragment, single node version\n   */\n\n  function singleRemove() {\n    this.inserted = false;\n    var shouldCallRemove = inDoc(this.node);\n    var self = this;\n    this.beforeRemove();\n    removeWithTransition(this.node, this.vm, function () {\n      if (shouldCallRemove) {\n        self.callHook(detach);\n      }\n      self.destroy();\n    });\n  }\n\n  /**\n   * Insert fragment before target, multi-nodes version\n   *\n   * @param {Node} target\n   * @param {Boolean} withTransition\n   */\n\n  function multiBefore(target, withTransition) {\n    this.inserted = true;\n    var vm = this.vm;\n    var method = withTransition !== false ? beforeWithTransition : before;\n    mapNodeRange(this.node, this.end, function (node) {\n      method(node, target, vm);\n    });\n    if (inDoc(this.node)) {\n      this.callHook(attach);\n    }\n  }\n\n  /**\n   * Remove fragment, multi-nodes version\n   */\n\n  function multiRemove() {\n    this.inserted = false;\n    var self = this;\n    var shouldCallRemove = inDoc(this.node);\n    this.beforeRemove();\n    removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n      if (shouldCallRemove) {\n        self.callHook(detach);\n      }\n      self.destroy();\n    });\n  }\n\n  /**\n   * Prepare the fragment for removal.\n   */\n\n  Fragment.prototype.beforeRemove = function () {\n    var i, l;\n    for (i = 0, l = this.childFrags.length; i < l; i++) {\n      // call the same method recursively on child\n      // fragments, depth-first\n      this.childFrags[i].beforeRemove(false);\n    }\n    for (i = 0, l = this.children.length; i < l; i++) {\n      // Call destroy for all contained instances,\n      // with remove:false and defer:true.\n      // Defer is necessary because we need to\n      // keep the children to call detach hooks\n      // on them.\n      this.children[i].$destroy(false, true);\n    }\n    var dirs = this.unlink.dirs;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      // disable the watchers on all the directives\n      // so that the rendered content stays the same\n      // during removal.\n      dirs[i]._watcher && dirs[i]._watcher.teardown();\n    }\n  };\n\n  /**\n   * Destroy the fragment.\n   */\n\n  Fragment.prototype.destroy = function () {\n    if (this.parentFrag) {\n      this.parentFrag.childFrags.$remove(this);\n    }\n    this.unlink();\n  };\n\n  /**\n   * Call attach hook for a Vue instance.\n   *\n   * @param {Vue} child\n   */\n\n  function attach(child) {\n    if (!child._isAttached) {\n      child._callHook('attached');\n    }\n  }\n\n  /**\n   * Call detach hook for a Vue instance.\n   *\n   * @param {Vue} child\n   */\n\n  function detach(child) {\n    if (child._isAttached) {\n      child._callHook('detached');\n    }\n  }\n\n  var linkerCache = new Cache(5000);\n\n  /**\n   * A factory that can be used to create instances of a\n   * fragment. Caches the compiled linker if possible.\n   *\n   * @param {Vue} vm\n   * @param {Element|String} el\n   */\n  function FragmentFactory(vm, el) {\n    this.vm = vm;\n    var template;\n    var isString = typeof el === 'string';\n    if (isString || isTemplate(el)) {\n      template = parseTemplate(el, true);\n    } else {\n      template = document.createDocumentFragment();\n      template.appendChild(el);\n    }\n    this.template = template;\n    // linker can be cached, but only for components\n    var linker;\n    var cid = vm.constructor.cid;\n    if (cid > 0) {\n      var cacheId = cid + (isString ? el : el.outerHTML);\n      linker = linkerCache.get(cacheId);\n      if (!linker) {\n        linker = compile(template, vm.$options, true);\n        linkerCache.put(cacheId, linker);\n      }\n    } else {\n      linker = compile(template, vm.$options, true);\n    }\n    this.linker = linker;\n  }\n\n  /**\n   * Create a fragment instance with given host and scope.\n   *\n   * @param {Vue} host\n   * @param {Object} scope\n   * @param {Fragment} parentFrag\n   */\n\n  FragmentFactory.prototype.create = function (host, scope, parentFrag) {\n    var frag = cloneNode(this.template);\n    return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\n  };\n\n  var vIf = {\n\n    priority: IF,\n\n    bind: function bind() {\n      var el = this.el;\n      if (!el.__vue__) {\n        // check else block\n        var next = el.nextElementSibling;\n        if (next && getAttr(next, 'v-else') !== null) {\n          remove(next);\n          this.elseFactory = new FragmentFactory(this.vm, next);\n        }\n        // check main block\n        this.anchor = createAnchor('v-if');\n        replace(el, this.anchor);\n        this.factory = new FragmentFactory(this.vm, el);\n      } else {\n        'development' !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.');\n        this.invalid = true;\n      }\n    },\n\n    update: function update(value) {\n      if (this.invalid) return;\n      if (value) {\n        if (!this.frag) {\n          this.insert();\n        }\n      } else {\n        this.remove();\n      }\n    },\n\n    insert: function insert() {\n      if (this.elseFrag) {\n        this.elseFrag.remove();\n        this.elseFrag = null;\n      }\n      this.frag = this.factory.create(this._host, this._scope, this._frag);\n      this.frag.before(this.anchor);\n    },\n\n    remove: function remove() {\n      if (this.frag) {\n        this.frag.remove();\n        this.frag = null;\n      }\n      if (this.elseFactory && !this.elseFrag) {\n        this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\n        this.elseFrag.before(this.anchor);\n      }\n    },\n\n    unbind: function unbind() {\n      if (this.frag) {\n        this.frag.destroy();\n      }\n    }\n  };\n\n  var uid$1 = 0;\n\n  var vFor = {\n\n    priority: FOR,\n\n    params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\n\n    bind: function bind() {\n      // support \"item in items\" syntax\n      var inMatch = this.expression.match(/(.*) in (.*)/);\n      if (inMatch) {\n        var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n        if (itMatch) {\n          this.iterator = itMatch[1].trim();\n          this.alias = itMatch[2].trim();\n        } else {\n          this.alias = inMatch[1].trim();\n        }\n        this.expression = inMatch[2];\n      }\n\n      if (!this.alias) {\n        'development' !== 'production' && warn('Alias is required in v-for.');\n        return;\n      }\n\n      // uid as a cache identifier\n      this.id = '__v-for__' + ++uid$1;\n\n      // check if this is an option list,\n      // so that we know if we need to update the <select>'s\n      // v-model when the option list has changed.\n      // because v-model has a lower priority than v-for,\n      // the v-model is not bound here yet, so we have to\n      // retrive it in the actual updateModel() function.\n      var tag = this.el.tagName;\n      this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\n\n      // setup anchor nodes\n      this.start = createAnchor('v-for-start');\n      this.end = createAnchor('v-for-end');\n      replace(this.el, this.end);\n      before(this.start, this.end);\n\n      // cache\n      this.cache = Object.create(null);\n\n      // fragment factory\n      this.factory = new FragmentFactory(this.vm, this.el);\n    },\n\n    update: function update(data) {\n      this.diff(data);\n      this.updateRef();\n      this.updateModel();\n    },\n\n    /**\n     * Diff, based on new data and old data, determine the\n     * minimum amount of DOM manipulations needed to make the\n     * DOM reflect the new data Array.\n     *\n     * The algorithm diffs the new data Array by storing a\n     * hidden reference to an owner vm instance on previously\n     * seen data. This allows us to achieve O(n) which is\n     * better than a levenshtein distance based algorithm,\n     * which is O(m * n).\n     *\n     * @param {Array} data\n     */\n\n    diff: function diff(data) {\n      // check if the Array was converted from an Object\n      var item = data[0];\n      var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\n\n      var trackByKey = this.params.trackBy;\n      var oldFrags = this.frags;\n      var frags = this.frags = new Array(data.length);\n      var alias = this.alias;\n      var iterator = this.iterator;\n      var start = this.start;\n      var end = this.end;\n      var inDocument = inDoc(start);\n      var init = !oldFrags;\n      var i, l, frag, key, value, primitive;\n\n      // First pass, go through the new Array and fill up\n      // the new frags array. If a piece of data has a cached\n      // instance for it, we reuse it. Otherwise build a new\n      // instance.\n      for (i = 0, l = data.length; i < l; i++) {\n        item = data[i];\n        key = convertedFromObject ? item.$key : null;\n        value = convertedFromObject ? item.$value : item;\n        primitive = !isObject(value);\n        frag = !init && this.getCachedFrag(value, i, key);\n        if (frag) {\n          // reusable fragment\n          frag.reused = true;\n          // update $index\n          frag.scope.$index = i;\n          // update $key\n          if (key) {\n            frag.scope.$key = key;\n          }\n          // update iterator\n          if (iterator) {\n            frag.scope[iterator] = key !== null ? key : i;\n          }\n          // update data for track-by, object repeat &\n          // primitive values.\n          if (trackByKey || convertedFromObject || primitive) {\n            frag.scope[alias] = value;\n          }\n        } else {\n          // new isntance\n          frag = this.create(value, alias, i, key);\n          frag.fresh = !init;\n        }\n        frags[i] = frag;\n        if (init) {\n          frag.before(end);\n        }\n      }\n\n      // we're done for the initial render.\n      if (init) {\n        return;\n      }\n\n      // Second pass, go through the old fragments and\n      // destroy those who are not reused (and remove them\n      // from cache)\n      var removalIndex = 0;\n      var totalRemoved = oldFrags.length - frags.length;\n      for (i = 0, l = oldFrags.length; i < l; i++) {\n        frag = oldFrags[i];\n        if (!frag.reused) {\n          this.deleteCachedFrag(frag);\n          this.remove(frag, removalIndex++, totalRemoved, inDocument);\n        }\n      }\n\n      // Final pass, move/insert new fragments into the\n      // right place.\n      var targetPrev, prevEl, currentPrev;\n      var insertionIndex = 0;\n      for (i = 0, l = frags.length; i < l; i++) {\n        frag = frags[i];\n        // this is the frag that we should be after\n        targetPrev = frags[i - 1];\n        prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n        if (frag.reused && !frag.staggerCb) {\n          currentPrev = findPrevFrag(frag, start, this.id);\n          if (currentPrev !== targetPrev && (!currentPrev ||\n          // optimization for moving a single item.\n          // thanks to suggestions by @livoras in #1807\n          findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\n            this.move(frag, prevEl);\n          }\n        } else {\n          // new instance, or still in stagger.\n          // insert with updated stagger index.\n          this.insert(frag, insertionIndex++, prevEl, inDocument);\n        }\n        frag.reused = frag.fresh = false;\n      }\n    },\n\n    /**\n     * Create a new fragment instance.\n     *\n     * @param {*} value\n     * @param {String} alias\n     * @param {Number} index\n     * @param {String} [key]\n     * @return {Fragment}\n     */\n\n    create: function create(value, alias, index, key) {\n      var host = this._host;\n      // create iteration scope\n      var parentScope = this._scope || this.vm;\n      var scope = Object.create(parentScope);\n      // ref holder for the scope\n      scope.$refs = Object.create(parentScope.$refs);\n      scope.$els = Object.create(parentScope.$els);\n      // make sure point $parent to parent scope\n      scope.$parent = parentScope;\n      // for two-way binding on alias\n      scope.$forContext = this;\n      // define scope properties\n      defineReactive(scope, alias, value);\n      defineReactive(scope, '$index', index);\n      if (key) {\n        defineReactive(scope, '$key', key);\n      } else if (scope.$key) {\n        // avoid accidental fallback\n        def(scope, '$key', null);\n      }\n      if (this.iterator) {\n        defineReactive(scope, this.iterator, key !== null ? key : index);\n      }\n      var frag = this.factory.create(host, scope, this._frag);\n      frag.forId = this.id;\n      this.cacheFrag(value, frag, index, key);\n      return frag;\n    },\n\n    /**\n     * Update the v-ref on owner vm.\n     */\n\n    updateRef: function updateRef() {\n      var ref = this.descriptor.ref;\n      if (!ref) return;\n      var hash = (this._scope || this.vm).$refs;\n      var refs;\n      if (!this.fromObject) {\n        refs = this.frags.map(findVmFromFrag);\n      } else {\n        refs = {};\n        this.frags.forEach(function (frag) {\n          refs[frag.scope.$key] = findVmFromFrag(frag);\n        });\n      }\n      hash[ref] = refs;\n    },\n\n    /**\n     * For option lists, update the containing v-model on\n     * parent <select>.\n     */\n\n    updateModel: function updateModel() {\n      if (this.isOption) {\n        var parent = this.start.parentNode;\n        var model = parent && parent.__v_model;\n        if (model) {\n          model.forceUpdate();\n        }\n      }\n    },\n\n    /**\n     * Insert a fragment. Handles staggering.\n     *\n     * @param {Fragment} frag\n     * @param {Number} index\n     * @param {Node} prevEl\n     * @param {Boolean} inDocument\n     */\n\n    insert: function insert(frag, index, prevEl, inDocument) {\n      if (frag.staggerCb) {\n        frag.staggerCb.cancel();\n        frag.staggerCb = null;\n      }\n      var staggerAmount = this.getStagger(frag, index, null, 'enter');\n      if (inDocument && staggerAmount) {\n        // create an anchor and insert it synchronously,\n        // so that we can resolve the correct order without\n        // worrying about some elements not inserted yet\n        var anchor = frag.staggerAnchor;\n        if (!anchor) {\n          anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\n          anchor.__vfrag__ = frag;\n        }\n        after(anchor, prevEl);\n        var op = frag.staggerCb = cancellable(function () {\n          frag.staggerCb = null;\n          frag.before(anchor);\n          remove(anchor);\n        });\n        setTimeout(op, staggerAmount);\n      } else {\n        frag.before(prevEl.nextSibling);\n      }\n    },\n\n    /**\n     * Remove a fragment. Handles staggering.\n     *\n     * @param {Fragment} frag\n     * @param {Number} index\n     * @param {Number} total\n     * @param {Boolean} inDocument\n     */\n\n    remove: function remove(frag, index, total, inDocument) {\n      if (frag.staggerCb) {\n        frag.staggerCb.cancel();\n        frag.staggerCb = null;\n        // it's not possible for the same frag to be removed\n        // twice, so if we have a pending stagger callback,\n        // it means this frag is queued for enter but removed\n        // before its transition started. Since it is already\n        // destroyed, we can just leave it in detached state.\n        return;\n      }\n      var staggerAmount = this.getStagger(frag, index, total, 'leave');\n      if (inDocument && staggerAmount) {\n        var op = frag.staggerCb = cancellable(function () {\n          frag.staggerCb = null;\n          frag.remove();\n        });\n        setTimeout(op, staggerAmount);\n      } else {\n        frag.remove();\n      }\n    },\n\n    /**\n     * Move a fragment to a new position.\n     * Force no transition.\n     *\n     * @param {Fragment} frag\n     * @param {Node} prevEl\n     */\n\n    move: function move(frag, prevEl) {\n      frag.before(prevEl.nextSibling, false);\n    },\n\n    /**\n     * Cache a fragment using track-by or the object key.\n     *\n     * @param {*} value\n     * @param {Fragment} frag\n     * @param {Number} index\n     * @param {String} [key]\n     */\n\n    cacheFrag: function cacheFrag(value, frag, index, key) {\n      var trackByKey = this.params.trackBy;\n      var cache = this.cache;\n      var primitive = !isObject(value);\n      var id;\n      if (key || trackByKey || primitive) {\n        id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;\n        if (!cache[id]) {\n          cache[id] = frag;\n        } else if (trackByKey !== '$index') {\n          'development' !== 'production' && this.warnDuplicate(value);\n        }\n      } else {\n        id = this.id;\n        if (hasOwn(value, id)) {\n          if (value[id] === null) {\n            value[id] = frag;\n          } else {\n            'development' !== 'production' && this.warnDuplicate(value);\n          }\n        } else {\n          def(value, id, frag);\n        }\n      }\n      frag.raw = value;\n    },\n\n    /**\n     * Get a cached fragment from the value/index/key\n     *\n     * @param {*} value\n     * @param {Number} index\n     * @param {String} key\n     * @return {Fragment}\n     */\n\n    getCachedFrag: function getCachedFrag(value, index, key) {\n      var trackByKey = this.params.trackBy;\n      var primitive = !isObject(value);\n      var frag;\n      if (key || trackByKey || primitive) {\n        var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;\n        frag = this.cache[id];\n      } else {\n        frag = value[this.id];\n      }\n      if (frag && (frag.reused || frag.fresh)) {\n        'development' !== 'production' && this.warnDuplicate(value);\n      }\n      return frag;\n    },\n\n    /**\n     * Delete a fragment from cache.\n     *\n     * @param {Fragment} frag\n     */\n\n    deleteCachedFrag: function deleteCachedFrag(frag) {\n      var value = frag.raw;\n      var trackByKey = this.params.trackBy;\n      var scope = frag.scope;\n      var index = scope.$index;\n      // fix #948: avoid accidentally fall through to\n      // a parent repeater which happens to have $key.\n      var key = hasOwn(scope, '$key') && scope.$key;\n      var primitive = !isObject(value);\n      if (trackByKey || key || primitive) {\n        var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;\n        this.cache[id] = null;\n      } else {\n        value[this.id] = null;\n        frag.raw = null;\n      }\n    },\n\n    /**\n     * Get the stagger amount for an insertion/removal.\n     *\n     * @param {Fragment} frag\n     * @param {Number} index\n     * @param {Number} total\n     * @param {String} type\n     */\n\n    getStagger: function getStagger(frag, index, total, type) {\n      type = type + 'Stagger';\n      var trans = frag.node.__v_trans;\n      var hooks = trans && trans.hooks;\n      var hook = hooks && (hooks[type] || hooks.stagger);\n      return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\n    },\n\n    /**\n     * Pre-process the value before piping it through the\n     * filters. This is passed to and called by the watcher.\n     */\n\n    _preProcess: function _preProcess(value) {\n      // regardless of type, store the un-filtered raw value.\n      this.rawValue = value;\n      return value;\n    },\n\n    /**\n     * Post-process the value after it has been piped through\n     * the filters. This is passed to and called by the watcher.\n     *\n     * It is necessary for this to be called during the\n     * wathcer's dependency collection phase because we want\n     * the v-for to update when the source Object is mutated.\n     */\n\n    _postProcess: function _postProcess(value) {\n      if (isArray(value)) {\n        return value;\n      } else if (isPlainObject(value)) {\n        // convert plain object to array.\n        var keys = Object.keys(value);\n        var i = keys.length;\n        var res = new Array(i);\n        var key;\n        while (i--) {\n          key = keys[i];\n          res[i] = {\n            $key: key,\n            $value: value[key]\n          };\n        }\n        return res;\n      } else {\n        if (typeof value === 'number') {\n          value = range(value);\n        }\n        return value || [];\n      }\n    },\n\n    unbind: function unbind() {\n      if (this.descriptor.ref) {\n        (this._scope || this.vm).$refs[this.descriptor.ref] = null;\n      }\n      if (this.frags) {\n        var i = this.frags.length;\n        var frag;\n        while (i--) {\n          frag = this.frags[i];\n          this.deleteCachedFrag(frag);\n          frag.destroy();\n        }\n      }\n    }\n  };\n\n  /**\n   * Helper to find the previous element that is a fragment\n   * anchor. This is necessary because a destroyed frag's\n   * element could still be lingering in the DOM before its\n   * leaving transition finishes, but its inserted flag\n   * should have been set to false so we can skip them.\n   *\n   * If this is a block repeat, we want to make sure we only\n   * return frag that is bound to this v-for. (see #929)\n   *\n   * @param {Fragment} frag\n   * @param {Comment|Text} anchor\n   * @param {String} id\n   * @return {Fragment}\n   */\n\n  function findPrevFrag(frag, anchor, id) {\n    var el = frag.node.previousSibling;\n    /* istanbul ignore if */\n    if (!el) return;\n    frag = el.__vfrag__;\n    while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\n      el = el.previousSibling;\n      /* istanbul ignore if */\n      if (!el) return;\n      frag = el.__vfrag__;\n    }\n    return frag;\n  }\n\n  /**\n   * Find a vm from a fragment.\n   *\n   * @param {Fragment} frag\n   * @return {Vue|undefined}\n   */\n\n  function findVmFromFrag(frag) {\n    var node = frag.node;\n    // handle multi-node frag\n    if (frag.end) {\n      while (!node.__vue__ && node !== frag.end && node.nextSibling) {\n        node = node.nextSibling;\n      }\n    }\n    return node.__vue__;\n  }\n\n  /**\n   * Create a range array from given number.\n   *\n   * @param {Number} n\n   * @return {Array}\n   */\n\n  function range(n) {\n    var i = -1;\n    var ret = new Array(n);\n    while (++i < n) {\n      ret[i] = i;\n    }\n    return ret;\n  }\n\n  if ('development' !== 'production') {\n    vFor.warnDuplicate = function (value) {\n      warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.');\n    };\n  }\n\n  var html = {\n\n    bind: function bind() {\n      // a comment node means this is a binding for\n      // {{{ inline unescaped html }}}\n      if (this.el.nodeType === 8) {\n        // hold nodes\n        this.nodes = [];\n        // replace the placeholder with proper anchor\n        this.anchor = createAnchor('v-html');\n        replace(this.el, this.anchor);\n      }\n    },\n\n    update: function update(value) {\n      value = _toString(value);\n      if (this.nodes) {\n        this.swap(value);\n      } else {\n        this.el.innerHTML = value;\n      }\n    },\n\n    swap: function swap(value) {\n      // remove old nodes\n      var i = this.nodes.length;\n      while (i--) {\n        remove(this.nodes[i]);\n      }\n      // convert new value to a fragment\n      // do not attempt to retrieve from id selector\n      var frag = parseTemplate(value, true, true);\n      // save a reference to these nodes so we can remove later\n      this.nodes = toArray(frag.childNodes);\n      before(frag, this.anchor);\n    }\n  };\n\n  var text = {\n\n    bind: function bind() {\n      this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n    },\n\n    update: function update(value) {\n      this.el[this.attr] = _toString(value);\n    }\n  };\n\n  // must export plain object\n  var publicDirectives = {\n    text: text,\n    html: html,\n    'for': vFor,\n    'if': vIf,\n    show: show,\n    model: model,\n    on: on,\n    bind: bind,\n    el: el,\n    ref: ref,\n    cloak: cloak\n  };\n\n  var queue$1 = [];\n  var queued = false;\n\n  /**\n   * Push a job into the queue.\n   *\n   * @param {Function} job\n   */\n\n  function pushJob(job) {\n    queue$1.push(job);\n    if (!queued) {\n      queued = true;\n      nextTick(flush);\n    }\n  }\n\n  /**\n   * Flush the queue, and do one forced reflow before\n   * triggering transitions.\n   */\n\n  function flush() {\n    // Force layout\n    var f = document.documentElement.offsetHeight;\n    for (var i = 0; i < queue$1.length; i++) {\n      queue$1[i]();\n    }\n    queue$1 = [];\n    queued = false;\n    // dummy return, so js linters don't complain about\n    // unused variable f\n    return f;\n  }\n\n  var TYPE_TRANSITION = 'transition';\n  var TYPE_ANIMATION = 'animation';\n  var transDurationProp = transitionProp + 'Duration';\n  var animDurationProp = animationProp + 'Duration';\n\n  /**\n   * A Transition object that encapsulates the state and logic\n   * of the transition.\n   *\n   * @param {Element} el\n   * @param {String} id\n   * @param {Object} hooks\n   * @param {Vue} vm\n   */\n  function Transition(el, id, hooks, vm) {\n    this.id = id;\n    this.el = el;\n    this.enterClass = hooks && hooks.enterClass || id + '-enter';\n    this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\n    this.hooks = hooks;\n    this.vm = vm;\n    // async state\n    this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\n    this.justEntered = false;\n    this.entered = this.left = false;\n    this.typeCache = {};\n    // check css transition type\n    this.type = hooks && hooks.type;\n    /* istanbul ignore if */\n    if ('development' !== 'production') {\n      if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\n        warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type);\n      }\n    }\n    // bind\n    var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\n      self[m] = bind$1(self[m], self);\n    });\n  }\n\n  var p$1 = Transition.prototype;\n\n  /**\n   * Start an entering transition.\n   *\n   * 1. enter transition triggered\n   * 2. call beforeEnter hook\n   * 3. add enter class\n   * 4. insert/show element\n   * 5. call enter hook (with possible explicit js callback)\n   * 6. reflow\n   * 7. based on transition type:\n   *    - transition:\n   *        remove class now, wait for transitionend,\n   *        then done if there's no explicit js callback.\n   *    - animation:\n   *        wait for animationend, remove class,\n   *        then done if there's no explicit js callback.\n   *    - no css transition:\n   *        done now if there's no explicit js callback.\n   * 8. wait for either done or js callback, then call\n   *    afterEnter hook.\n   *\n   * @param {Function} op - insert/show the element\n   * @param {Function} [cb]\n   */\n\n  p$1.enter = function (op, cb) {\n    this.cancelPending();\n    this.callHook('beforeEnter');\n    this.cb = cb;\n    addClass(this.el, this.enterClass);\n    op();\n    this.entered = false;\n    this.callHookWithCb('enter');\n    if (this.entered) {\n      return; // user called done synchronously.\n    }\n    this.cancel = this.hooks && this.hooks.enterCancelled;\n    pushJob(this.enterNextTick);\n  };\n\n  /**\n   * The \"nextTick\" phase of an entering transition, which is\n   * to be pushed into a queue and executed after a reflow so\n   * that removing the class can trigger a CSS transition.\n   */\n\n  p$1.enterNextTick = function () {\n\n    // Important hack:\n    // in Chrome, if a just-entered element is applied the\n    // leave class while its interpolated property still has\n    // a very small value (within one frame), Chrome will\n    // skip the leave transition entirely and not firing the\n    // transtionend event. Therefore we need to protected\n    // against such cases using a one-frame timeout.\n    this.justEntered = true;\n    var self = this;\n    setTimeout(function () {\n      self.justEntered = false;\n    }, 17);\n\n    var enterDone = this.enterDone;\n    var type = this.getCssTransitionType(this.enterClass);\n    if (!this.pendingJsCb) {\n      if (type === TYPE_TRANSITION) {\n        // trigger transition by removing enter class now\n        removeClass(this.el, this.enterClass);\n        this.setupCssCb(transitionEndEvent, enterDone);\n      } else if (type === TYPE_ANIMATION) {\n        this.setupCssCb(animationEndEvent, enterDone);\n      } else {\n        enterDone();\n      }\n    } else if (type === TYPE_TRANSITION) {\n      removeClass(this.el, this.enterClass);\n    }\n  };\n\n  /**\n   * The \"cleanup\" phase of an entering transition.\n   */\n\n  p$1.enterDone = function () {\n    this.entered = true;\n    this.cancel = this.pendingJsCb = null;\n    removeClass(this.el, this.enterClass);\n    this.callHook('afterEnter');\n    if (this.cb) this.cb();\n  };\n\n  /**\n   * Start a leaving transition.\n   *\n   * 1. leave transition triggered.\n   * 2. call beforeLeave hook\n   * 3. add leave class (trigger css transition)\n   * 4. call leave hook (with possible explicit js callback)\n   * 5. reflow if no explicit js callback is provided\n   * 6. based on transition type:\n   *    - transition or animation:\n   *        wait for end event, remove class, then done if\n   *        there's no explicit js callback.\n   *    - no css transition:\n   *        done if there's no explicit js callback.\n   * 7. wait for either done or js callback, then call\n   *    afterLeave hook.\n   *\n   * @param {Function} op - remove/hide the element\n   * @param {Function} [cb]\n   */\n\n  p$1.leave = function (op, cb) {\n    this.cancelPending();\n    this.callHook('beforeLeave');\n    this.op = op;\n    this.cb = cb;\n    addClass(this.el, this.leaveClass);\n    this.left = false;\n    this.callHookWithCb('leave');\n    if (this.left) {\n      return; // user called done synchronously.\n    }\n    this.cancel = this.hooks && this.hooks.leaveCancelled;\n    // only need to handle leaveDone if\n    // 1. the transition is already done (synchronously called\n    //    by the user, which causes this.op set to null)\n    // 2. there's no explicit js callback\n    if (this.op && !this.pendingJsCb) {\n      // if a CSS transition leaves immediately after enter,\n      // the transitionend event never fires. therefore we\n      // detect such cases and end the leave immediately.\n      if (this.justEntered) {\n        this.leaveDone();\n      } else {\n        pushJob(this.leaveNextTick);\n      }\n    }\n  };\n\n  /**\n   * The \"nextTick\" phase of a leaving transition.\n   */\n\n  p$1.leaveNextTick = function () {\n    var type = this.getCssTransitionType(this.leaveClass);\n    if (type) {\n      var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\n      this.setupCssCb(event, this.leaveDone);\n    } else {\n      this.leaveDone();\n    }\n  };\n\n  /**\n   * The \"cleanup\" phase of a leaving transition.\n   */\n\n  p$1.leaveDone = function () {\n    this.left = true;\n    this.cancel = this.pendingJsCb = null;\n    this.op();\n    removeClass(this.el, this.leaveClass);\n    this.callHook('afterLeave');\n    if (this.cb) this.cb();\n    this.op = null;\n  };\n\n  /**\n   * Cancel any pending callbacks from a previously running\n   * but not finished transition.\n   */\n\n  p$1.cancelPending = function () {\n    this.op = this.cb = null;\n    var hasPending = false;\n    if (this.pendingCssCb) {\n      hasPending = true;\n      off(this.el, this.pendingCssEvent, this.pendingCssCb);\n      this.pendingCssEvent = this.pendingCssCb = null;\n    }\n    if (this.pendingJsCb) {\n      hasPending = true;\n      this.pendingJsCb.cancel();\n      this.pendingJsCb = null;\n    }\n    if (hasPending) {\n      removeClass(this.el, this.enterClass);\n      removeClass(this.el, this.leaveClass);\n    }\n    if (this.cancel) {\n      this.cancel.call(this.vm, this.el);\n      this.cancel = null;\n    }\n  };\n\n  /**\n   * Call a user-provided synchronous hook function.\n   *\n   * @param {String} type\n   */\n\n  p$1.callHook = function (type) {\n    if (this.hooks && this.hooks[type]) {\n      this.hooks[type].call(this.vm, this.el);\n    }\n  };\n\n  /**\n   * Call a user-provided, potentially-async hook function.\n   * We check for the length of arguments to see if the hook\n   * expects a `done` callback. If true, the transition's end\n   * will be determined by when the user calls that callback;\n   * otherwise, the end is determined by the CSS transition or\n   * animation.\n   *\n   * @param {String} type\n   */\n\n  p$1.callHookWithCb = function (type) {\n    var hook = this.hooks && this.hooks[type];\n    if (hook) {\n      if (hook.length > 1) {\n        this.pendingJsCb = cancellable(this[type + 'Done']);\n      }\n      hook.call(this.vm, this.el, this.pendingJsCb);\n    }\n  };\n\n  /**\n   * Get an element's transition type based on the\n   * calculated styles.\n   *\n   * @param {String} className\n   * @return {Number}\n   */\n\n  p$1.getCssTransitionType = function (className) {\n    /* istanbul ignore if */\n    if (!transitionEndEvent ||\n    // skip CSS transitions if page is not visible -\n    // this solves the issue of transitionend events not\n    // firing until the page is visible again.\n    // pageVisibility API is supported in IE10+, same as\n    // CSS transitions.\n    document.hidden ||\n    // explicit js-only transition\n    this.hooks && this.hooks.css === false ||\n    // element is hidden\n    isHidden(this.el)) {\n      return;\n    }\n    var type = this.type || this.typeCache[className];\n    if (type) return type;\n    var inlineStyles = this.el.style;\n    var computedStyles = window.getComputedStyle(this.el);\n    var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\n    if (transDuration && transDuration !== '0s') {\n      type = TYPE_TRANSITION;\n    } else {\n      var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\n      if (animDuration && animDuration !== '0s') {\n        type = TYPE_ANIMATION;\n      }\n    }\n    if (type) {\n      this.typeCache[className] = type;\n    }\n    return type;\n  };\n\n  /**\n   * Setup a CSS transitionend/animationend callback.\n   *\n   * @param {String} event\n   * @param {Function} cb\n   */\n\n  p$1.setupCssCb = function (event, cb) {\n    this.pendingCssEvent = event;\n    var self = this;\n    var el = this.el;\n    var onEnd = this.pendingCssCb = function (e) {\n      if (e.target === el) {\n        off(el, event, onEnd);\n        self.pendingCssEvent = self.pendingCssCb = null;\n        if (!self.pendingJsCb && cb) {\n          cb();\n        }\n      }\n    };\n    on$1(el, event, onEnd);\n  };\n\n  /**\n   * Check if an element is hidden - in that case we can just\n   * skip the transition alltogether.\n   *\n   * @param {Element} el\n   * @return {Boolean}\n   */\n\n  function isHidden(el) {\n    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n  }\n\n  var transition = {\n\n    priority: TRANSITION,\n\n    update: function update(id, oldId) {\n      var el = this.el;\n      // resolve on owner vm\n      var hooks = resolveAsset(this.vm.$options, 'transitions', id);\n      id = id || 'v';\n      // apply on closest vm\n      el.__v_trans = new Transition(el, id, hooks, this.el.__vue__ || this.vm);\n      if (oldId) {\n        removeClass(el, oldId + '-transition');\n      }\n      addClass(el, id + '-transition');\n    }\n  };\n\n  var bindingModes = config._propBindingModes;\n\n  var propDef = {\n\n    bind: function bind() {\n\n      var child = this.vm;\n      var parent = child._context;\n      // passed in from compiler directly\n      var prop = this.descriptor.prop;\n      var childKey = prop.path;\n      var parentKey = prop.parentPath;\n      var twoWay = prop.mode === bindingModes.TWO_WAY;\n\n      var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\n        val = coerceProp(prop, val);\n        if (assertProp(prop, val)) {\n          child[childKey] = val;\n        }\n      }, {\n        twoWay: twoWay,\n        filters: prop.filters,\n        // important: props need to be observed on the\n        // v-for scope if present\n        scope: this._scope\n      });\n\n      // set the child initial value.\n      initProp(child, prop, parentWatcher.value);\n\n      // setup two-way binding\n      if (twoWay) {\n        // important: defer the child watcher creation until\n        // the created hook (after data observation)\n        var self = this;\n        child.$once('pre-hook:created', function () {\n          self.childWatcher = new Watcher(child, childKey, function (val) {\n            parentWatcher.set(val);\n          }, {\n            // ensure sync upward before parent sync down.\n            // this is necessary in cases e.g. the child\n            // mutates a prop array, then replaces it. (#1683)\n            sync: true\n          });\n        });\n      }\n    },\n\n    unbind: function unbind() {\n      this.parentWatcher.teardown();\n      if (this.childWatcher) {\n        this.childWatcher.teardown();\n      }\n    }\n  };\n\n  var component = {\n\n    priority: COMPONENT,\n\n    params: ['keep-alive', 'transition-mode', 'inline-template'],\n\n    /**\n     * Setup. Two possible usages:\n     *\n     * - static:\n     *   <comp> or <div v-component=\"comp\">\n     *\n     * - dynamic:\n     *   <component :is=\"view\">\n     */\n\n    bind: function bind() {\n      if (!this.el.__vue__) {\n        // keep-alive cache\n        this.keepAlive = this.params.keepAlive;\n        if (this.keepAlive) {\n          this.cache = {};\n        }\n        // check inline-template\n        if (this.params.inlineTemplate) {\n          // extract inline template as a DocumentFragment\n          this.inlineTemplate = extractContent(this.el, true);\n        }\n        // component resolution related state\n        this.pendingComponentCb = this.Component = null;\n        // transition related state\n        this.pendingRemovals = 0;\n        this.pendingRemovalCb = null;\n        // create a ref anchor\n        this.anchor = createAnchor('v-component');\n        replace(this.el, this.anchor);\n        // remove is attribute.\n        // this is removed during compilation, but because compilation is\n        // cached, when the component is used elsewhere this attribute\n        // will remain at link time.\n        this.el.removeAttribute('is');\n        // remove ref, same as above\n        if (this.descriptor.ref) {\n          this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\n        }\n        // if static, build right now.\n        if (this.literal) {\n          this.setComponent(this.expression);\n        }\n      } else {\n        'development' !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\n      }\n    },\n\n    /**\n     * Public update, called by the watcher in the dynamic\n     * literal scenario, e.g. <component :is=\"view\">\n     */\n\n    update: function update(value) {\n      if (!this.literal) {\n        this.setComponent(value);\n      }\n    },\n\n    /**\n     * Switch dynamic components. May resolve the component\n     * asynchronously, and perform transition based on\n     * specified transition mode. Accepts a few additional\n     * arguments specifically for vue-router.\n     *\n     * The callback is called when the full transition is\n     * finished.\n     *\n     * @param {String} value\n     * @param {Function} [cb]\n     */\n\n    setComponent: function setComponent(value, cb) {\n      this.invalidatePending();\n      if (!value) {\n        // just remove current\n        this.unbuild(true);\n        this.remove(this.childVM, cb);\n        this.childVM = null;\n      } else {\n        var self = this;\n        this.resolveComponent(value, function () {\n          self.mountComponent(cb);\n        });\n      }\n    },\n\n    /**\n     * Resolve the component constructor to use when creating\n     * the child vm.\n     */\n\n    resolveComponent: function resolveComponent(id, cb) {\n      var self = this;\n      this.pendingComponentCb = cancellable(function (Component) {\n        self.ComponentName = Component.options.name || id;\n        self.Component = Component;\n        cb();\n      });\n      this.vm._resolveComponent(id, this.pendingComponentCb);\n    },\n\n    /**\n     * Create a new instance using the current constructor and\n     * replace the existing instance. This method doesn't care\n     * whether the new component and the old one are actually\n     * the same.\n     *\n     * @param {Function} [cb]\n     */\n\n    mountComponent: function mountComponent(cb) {\n      // actual mount\n      this.unbuild(true);\n      var self = this;\n      var activateHook = this.Component.options.activate;\n      var cached = this.getCached();\n      var newComponent = this.build();\n      if (activateHook && !cached) {\n        this.waitingFor = newComponent;\n        activateHook.call(newComponent, function () {\n          if (self.waitingFor !== newComponent) {\n            return;\n          }\n          self.waitingFor = null;\n          self.transition(newComponent, cb);\n        });\n      } else {\n        // update ref for kept-alive component\n        if (cached) {\n          newComponent._updateRef();\n        }\n        this.transition(newComponent, cb);\n      }\n    },\n\n    /**\n     * When the component changes or unbinds before an async\n     * constructor is resolved, we need to invalidate its\n     * pending callback.\n     */\n\n    invalidatePending: function invalidatePending() {\n      if (this.pendingComponentCb) {\n        this.pendingComponentCb.cancel();\n        this.pendingComponentCb = null;\n      }\n    },\n\n    /**\n     * Instantiate/insert a new child vm.\n     * If keep alive and has cached instance, insert that\n     * instance; otherwise build a new one and cache it.\n     *\n     * @param {Object} [extraOptions]\n     * @return {Vue} - the created instance\n     */\n\n    build: function build(extraOptions) {\n      var cached = this.getCached();\n      if (cached) {\n        return cached;\n      }\n      if (this.Component) {\n        // default options\n        var options = {\n          name: this.ComponentName,\n          el: cloneNode(this.el),\n          template: this.inlineTemplate,\n          // make sure to add the child with correct parent\n          // if this is a transcluded component, its parent\n          // should be the transclusion host.\n          parent: this._host || this.vm,\n          // if no inline-template, then the compiled\n          // linker can be cached for better performance.\n          _linkerCachable: !this.inlineTemplate,\n          _ref: this.descriptor.ref,\n          _asComponent: true,\n          _isRouterView: this._isRouterView,\n          // if this is a transcluded component, context\n          // will be the common parent vm of this instance\n          // and its host.\n          _context: this.vm,\n          // if this is inside an inline v-for, the scope\n          // will be the intermediate scope created for this\n          // repeat fragment. this is used for linking props\n          // and container directives.\n          _scope: this._scope,\n          // pass in the owner fragment of this component.\n          // this is necessary so that the fragment can keep\n          // track of its contained components in order to\n          // call attach/detach hooks for them.\n          _frag: this._frag\n        };\n        // extra options\n        // in 1.0.0 this is used by vue-router only\n        /* istanbul ignore if */\n        if (extraOptions) {\n          extend(options, extraOptions);\n        }\n        var child = new this.Component(options);\n        if (this.keepAlive) {\n          this.cache[this.Component.cid] = child;\n        }\n        /* istanbul ignore if */\n        if ('development' !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {\n          warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template);\n        }\n        return child;\n      }\n    },\n\n    /**\n     * Try to get a cached instance of the current component.\n     *\n     * @return {Vue|undefined}\n     */\n\n    getCached: function getCached() {\n      return this.keepAlive && this.cache[this.Component.cid];\n    },\n\n    /**\n     * Teardown the current child, but defers cleanup so\n     * that we can separate the destroy and removal steps.\n     *\n     * @param {Boolean} defer\n     */\n\n    unbuild: function unbuild(defer) {\n      if (this.waitingFor) {\n        this.waitingFor.$destroy();\n        this.waitingFor = null;\n      }\n      var child = this.childVM;\n      if (!child || this.keepAlive) {\n        if (child) {\n          // remove ref\n          child._updateRef(true);\n        }\n        return;\n      }\n      // the sole purpose of `deferCleanup` is so that we can\n      // \"deactivate\" the vm right now and perform DOM removal\n      // later.\n      child.$destroy(false, defer);\n    },\n\n    /**\n     * Remove current destroyed child and manually do\n     * the cleanup after removal.\n     *\n     * @param {Function} cb\n     */\n\n    remove: function remove(child, cb) {\n      var keepAlive = this.keepAlive;\n      if (child) {\n        // we may have a component switch when a previous\n        // component is still being transitioned out.\n        // we want to trigger only one lastest insertion cb\n        // when the existing transition finishes. (#1119)\n        this.pendingRemovals++;\n        this.pendingRemovalCb = cb;\n        var self = this;\n        child.$remove(function () {\n          self.pendingRemovals--;\n          if (!keepAlive) child._cleanup();\n          if (!self.pendingRemovals && self.pendingRemovalCb) {\n            self.pendingRemovalCb();\n            self.pendingRemovalCb = null;\n          }\n        });\n      } else if (cb) {\n        cb();\n      }\n    },\n\n    /**\n     * Actually swap the components, depending on the\n     * transition mode. Defaults to simultaneous.\n     *\n     * @param {Vue} target\n     * @param {Function} [cb]\n     */\n\n    transition: function transition(target, cb) {\n      var self = this;\n      var current = this.childVM;\n      // for devtool inspection\n      if ('development' !== 'production') {\n        if (current) current._inactive = true;\n        target._inactive = false;\n      }\n      this.childVM = target;\n      switch (self.params.transitionMode) {\n        case 'in-out':\n          target.$before(self.anchor, function () {\n            self.remove(current, cb);\n          });\n          break;\n        case 'out-in':\n          self.remove(current, function () {\n            target.$before(self.anchor, cb);\n          });\n          break;\n        default:\n          self.remove(current);\n          target.$before(self.anchor, cb);\n      }\n    },\n\n    /**\n     * Unbind.\n     */\n\n    unbind: function unbind() {\n      this.invalidatePending();\n      // Do not defer cleanup when unbinding\n      this.unbuild();\n      // destroy all keep-alive cached instances\n      if (this.cache) {\n        for (var key in this.cache) {\n          this.cache[key].$destroy();\n        }\n        this.cache = null;\n      }\n    }\n  };\n\n  var vClass = {\n\n    deep: true,\n\n    update: function update(value) {\n      if (value && typeof value === 'string') {\n        this.handleObject(stringToObject(value));\n      } else if (isPlainObject(value)) {\n        this.handleObject(value);\n      } else if (isArray(value)) {\n        this.handleArray(value);\n      } else {\n        this.cleanup();\n      }\n    },\n\n    handleObject: function handleObject(value) {\n      this.cleanup(value);\n      var keys = this.prevKeys = Object.keys(value);\n      for (var i = 0, l = keys.length; i < l; i++) {\n        var key = keys[i];\n        if (value[key]) {\n          addClass(this.el, key);\n        } else {\n          removeClass(this.el, key);\n        }\n      }\n    },\n\n    handleArray: function handleArray(value) {\n      this.cleanup(value);\n      for (var i = 0, l = value.length; i < l; i++) {\n        if (value[i]) {\n          addClass(this.el, value[i]);\n        }\n      }\n      this.prevKeys = value.slice();\n    },\n\n    cleanup: function cleanup(value) {\n      if (this.prevKeys) {\n        var i = this.prevKeys.length;\n        while (i--) {\n          var key = this.prevKeys[i];\n          if (key && (!value || !contains$1(value, key))) {\n            removeClass(this.el, key);\n          }\n        }\n      }\n    }\n  };\n\n  function stringToObject(value) {\n    var res = {};\n    var keys = value.trim().split(/\\s+/);\n    var i = keys.length;\n    while (i--) {\n      res[keys[i]] = true;\n    }\n    return res;\n  }\n\n  function contains$1(value, key) {\n    return isArray(value) ? value.indexOf(key) > -1 : hasOwn(value, key);\n  }\n\n  var internalDirectives = {\n    style: style,\n    'class': vClass,\n    component: component,\n    prop: propDef,\n    transition: transition\n  };\n\n  var propBindingModes = config._propBindingModes;\n  var empty = {};\n\n  // regexes\n  var identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\n  var settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\n\n  /**\n   * Compile props on a root element and return\n   * a props link function.\n   *\n   * @param {Element|DocumentFragment} el\n   * @param {Array} propOptions\n   * @return {Function} propsLinkFn\n   */\n\n  function compileProps(el, propOptions) {\n    var props = [];\n    var names = Object.keys(propOptions);\n    var i = names.length;\n    var options, name, attr, value, path, parsed, prop;\n    while (i--) {\n      name = names[i];\n      options = propOptions[name] || empty;\n\n      if ('development' !== 'production' && name === '$data') {\n        warn('Do not use $data as prop.');\n        continue;\n      }\n\n      // props could contain dashes, which will be\n      // interpreted as minus calculations by the parser\n      // so we need to camelize the path here\n      path = camelize(name);\n      if (!identRE$1.test(path)) {\n        'development' !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.');\n        continue;\n      }\n\n      prop = {\n        name: name,\n        path: path,\n        options: options,\n        mode: propBindingModes.ONE_WAY,\n        raw: null\n      };\n\n      attr = hyphenate(name);\n      // first check dynamic version\n      if ((value = getBindAttr(el, attr)) === null) {\n        if ((value = getBindAttr(el, attr + '.sync')) !== null) {\n          prop.mode = propBindingModes.TWO_WAY;\n        } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\n          prop.mode = propBindingModes.ONE_TIME;\n        }\n      }\n      if (value !== null) {\n        // has dynamic binding!\n        prop.raw = value;\n        parsed = parseDirective(value);\n        value = parsed.expression;\n        prop.filters = parsed.filters;\n        // check binding type\n        if (isLiteral(value) && !parsed.filters) {\n          // for expressions containing literal numbers and\n          // booleans, there's no need to setup a prop binding,\n          // so we can optimize them as a one-time set.\n          prop.optimizedLiteral = true;\n        } else {\n          prop.dynamic = true;\n          // check non-settable path for two-way bindings\n          if ('development' !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {\n            prop.mode = propBindingModes.ONE_WAY;\n            warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value);\n          }\n        }\n        prop.parentPath = value;\n\n        // warn required two-way\n        if ('development' !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {\n          warn('Prop \"' + name + '\" expects a two-way binding type.');\n        }\n      } else if ((value = getAttr(el, attr)) !== null) {\n        // has literal binding!\n        prop.raw = value;\n      } else if (options.required) {\n        // warn missing required\n        'development' !== 'production' && warn('Missing required prop: ' + name);\n      }\n      // push prop\n      props.push(prop);\n    }\n    return makePropsLinkFn(props);\n  }\n\n  /**\n   * Build a function that applies props to a vm.\n   *\n   * @param {Array} props\n   * @return {Function} propsLinkFn\n   */\n\n  function makePropsLinkFn(props) {\n    return function propsLinkFn(vm, scope) {\n      // store resolved props info\n      vm._props = {};\n      var i = props.length;\n      var prop, path, options, value, raw;\n      while (i--) {\n        prop = props[i];\n        raw = prop.raw;\n        path = prop.path;\n        options = prop.options;\n        vm._props[path] = prop;\n        if (raw === null) {\n          // initialize absent prop\n          initProp(vm, prop, getDefault(vm, options));\n        } else if (prop.dynamic) {\n          // dynamic prop\n          if (vm._context) {\n            if (prop.mode === propBindingModes.ONE_TIME) {\n              // one time binding\n              value = (scope || vm._context).$get(prop.parentPath);\n              initProp(vm, prop, value);\n            } else {\n              // dynamic binding\n              vm._bindDir({\n                name: 'prop',\n                def: propDef,\n                prop: prop\n              }, null, null, scope); // el, host, scope\n            }\n          } else {\n              'development' !== 'production' && warn('Cannot bind dynamic prop on a root instance' + ' with no parent: ' + prop.name + '=\"' + raw + '\"');\n            }\n        } else if (prop.optimizedLiteral) {\n          // optimized literal, cast it and just set once\n          var stripped = stripQuotes(raw);\n          value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\n          initProp(vm, prop, value);\n        } else {\n          // string literal, but we need to cater for\n          // Boolean props with no value\n          value = options.type === Boolean && raw === '' ? true : raw;\n          initProp(vm, prop, value);\n        }\n      }\n    };\n  }\n\n  /**\n   * Get the default value of a prop.\n   *\n   * @param {Vue} vm\n   * @param {Object} options\n   * @return {*}\n   */\n\n  function getDefault(vm, options) {\n    // no default, return undefined\n    if (!hasOwn(options, 'default')) {\n      // absent boolean value defaults to false\n      return options.type === Boolean ? false : undefined;\n    }\n    var def = options['default'];\n    // warn against non-factory defaults for Object & Array\n    if (isObject(def)) {\n      'development' !== 'production' && warn('Object/Array as default prop values will be shared ' + 'across multiple instances. Use a factory function ' + 'to return the default value instead.');\n    }\n    // call factory function for non-Function types\n    return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\n  }\n\n  // special binding prefixes\n  var bindRE = /^v-bind:|^:/;\n  var onRE = /^v-on:|^@/;\n  var argRE = /:(.*)$/;\n  var modifierRE = /\\.[^\\.]+/g;\n  var transitionRE = /^(v-bind:|:)?transition$/;\n\n  // terminal directives\n  var terminalDirectives = ['for', 'if'];\n\n  // default directive priority\n  var DEFAULT_PRIORITY = 1000;\n\n  /**\n   * Compile a template and return a reusable composite link\n   * function, which recursively contains more link functions\n   * inside. This top level compile function would normally\n   * be called on instance root nodes, but can also be used\n   * for partial compilation if the partial argument is true.\n   *\n   * The returned composite link function, when called, will\n   * return an unlink function that tearsdown all directives\n   * created during the linking phase.\n   *\n   * @param {Element|DocumentFragment} el\n   * @param {Object} options\n   * @param {Boolean} partial\n   * @return {Function}\n   */\n\n  function compile(el, options, partial) {\n    // link function for the node itself.\n    var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\n    // link function for the childNodes\n    var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && el.tagName !== 'SCRIPT' && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\n\n    /**\n     * A composite linker function to be called on a already\n     * compiled piece of DOM, which instantiates all directive\n     * instances.\n     *\n     * @param {Vue} vm\n     * @param {Element|DocumentFragment} el\n     * @param {Vue} [host] - host vm of transcluded content\n     * @param {Object} [scope] - v-for scope\n     * @param {Fragment} [frag] - link context fragment\n     * @return {Function|undefined}\n     */\n\n    return function compositeLinkFn(vm, el, host, scope, frag) {\n      // cache childNodes before linking parent, fix #657\n      var childNodes = toArray(el.childNodes);\n      // link\n      var dirs = linkAndCapture(function compositeLinkCapturer() {\n        if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n        if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\n      }, vm);\n      return makeUnlinkFn(vm, dirs);\n    };\n  }\n\n  /**\n   * Apply a linker to a vm/element pair and capture the\n   * directives created during the process.\n   *\n   * @param {Function} linker\n   * @param {Vue} vm\n   */\n\n  function linkAndCapture(linker, vm) {\n    var originalDirCount = vm._directives.length;\n    linker();\n    var dirs = vm._directives.slice(originalDirCount);\n    dirs.sort(directiveComparator);\n    for (var i = 0, l = dirs.length; i < l; i++) {\n      dirs[i]._bind();\n    }\n    return dirs;\n  }\n\n  /**\n   * Directive priority sort comparator\n   *\n   * @param {Object} a\n   * @param {Object} b\n   */\n\n  function directiveComparator(a, b) {\n    a = a.descriptor.def.priority || DEFAULT_PRIORITY;\n    b = b.descriptor.def.priority || DEFAULT_PRIORITY;\n    return a > b ? -1 : a === b ? 0 : 1;\n  }\n\n  /**\n   * Linker functions return an unlink function that\n   * tearsdown all directives instances generated during\n   * the process.\n   *\n   * We create unlink functions with only the necessary\n   * information to avoid retaining additional closures.\n   *\n   * @param {Vue} vm\n   * @param {Array} dirs\n   * @param {Vue} [context]\n   * @param {Array} [contextDirs]\n   * @return {Function}\n   */\n\n  function makeUnlinkFn(vm, dirs, context, contextDirs) {\n    function unlink(destroying) {\n      teardownDirs(vm, dirs, destroying);\n      if (context && contextDirs) {\n        teardownDirs(context, contextDirs);\n      }\n    }\n    // expose linked directives\n    unlink.dirs = dirs;\n    return unlink;\n  }\n\n  /**\n   * Teardown partial linked directives.\n   *\n   * @param {Vue} vm\n   * @param {Array} dirs\n   * @param {Boolean} destroying\n   */\n\n  function teardownDirs(vm, dirs, destroying) {\n    var i = dirs.length;\n    while (i--) {\n      dirs[i]._teardown();\n      if (!destroying) {\n        vm._directives.$remove(dirs[i]);\n      }\n    }\n  }\n\n  /**\n   * Compile link props on an instance.\n   *\n   * @param {Vue} vm\n   * @param {Element} el\n   * @param {Object} props\n   * @param {Object} [scope]\n   * @return {Function}\n   */\n\n  function compileAndLinkProps(vm, el, props, scope) {\n    var propsLinkFn = compileProps(el, props);\n    var propDirs = linkAndCapture(function () {\n      propsLinkFn(vm, scope);\n    }, vm);\n    return makeUnlinkFn(vm, propDirs);\n  }\n\n  /**\n   * Compile the root element of an instance.\n   *\n   * 1. attrs on context container (context scope)\n   * 2. attrs on the component template root node, if\n   *    replace:true (child scope)\n   *\n   * If this is a fragment instance, we only need to compile 1.\n   *\n   * @param {Vue} vm\n   * @param {Element} el\n   * @param {Object} options\n   * @param {Object} contextOptions\n   * @return {Function}\n   */\n\n  function compileRoot(el, options, contextOptions) {\n    var containerAttrs = options._containerAttrs;\n    var replacerAttrs = options._replacerAttrs;\n    var contextLinkFn, replacerLinkFn;\n\n    // only need to compile other attributes for\n    // non-fragment instances\n    if (el.nodeType !== 11) {\n      // for components, container and replacer need to be\n      // compiled separately and linked in different scopes.\n      if (options._asComponent) {\n        // 2. container attributes\n        if (containerAttrs && contextOptions) {\n          contextLinkFn = compileDirectives(containerAttrs, contextOptions);\n        }\n        if (replacerAttrs) {\n          // 3. replacer attributes\n          replacerLinkFn = compileDirectives(replacerAttrs, options);\n        }\n      } else {\n        // non-component, just compile as a normal element.\n        replacerLinkFn = compileDirectives(el.attributes, options);\n      }\n    } else if ('development' !== 'production' && containerAttrs) {\n      // warn container directives for fragment instances\n      var names = containerAttrs.filter(function (attr) {\n        // allow vue-loader/vueify scoped css attributes\n        return attr.name.indexOf('_v-') < 0 &&\n        // allow event listeners\n        !onRE.test(attr.name) &&\n        // allow slots\n        attr.name !== 'slot';\n      }).map(function (attr) {\n        return '\"' + attr.name + '\"';\n      });\n      if (names.length) {\n        var plural = names.length > 1;\n        warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment_Instance');\n      }\n    }\n\n    options._containerAttrs = options._replacerAttrs = null;\n    return function rootLinkFn(vm, el, scope) {\n      // link context scope dirs\n      var context = vm._context;\n      var contextDirs;\n      if (context && contextLinkFn) {\n        contextDirs = linkAndCapture(function () {\n          contextLinkFn(context, el, null, scope);\n        }, context);\n      }\n\n      // link self\n      var selfDirs = linkAndCapture(function () {\n        if (replacerLinkFn) replacerLinkFn(vm, el);\n      }, vm);\n\n      // return the unlink function that tearsdown context\n      // container directives.\n      return makeUnlinkFn(vm, selfDirs, context, contextDirs);\n    };\n  }\n\n  /**\n   * Compile a node and return a nodeLinkFn based on the\n   * node type.\n   *\n   * @param {Node} node\n   * @param {Object} options\n   * @return {Function|null}\n   */\n\n  function compileNode(node, options) {\n    var type = node.nodeType;\n    if (type === 1 && node.tagName !== 'SCRIPT') {\n      return compileElement(node, options);\n    } else if (type === 3 && node.data.trim()) {\n      return compileTextNode(node, options);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Compile an element and return a nodeLinkFn.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Function|null}\n   */\n\n  function compileElement(el, options) {\n    // preprocess textareas.\n    // textarea treats its text content as the initial value.\n    // just bind it as an attr directive for value.\n    if (el.tagName === 'TEXTAREA') {\n      var tokens = parseText(el.value);\n      if (tokens) {\n        el.setAttribute(':value', tokensToExp(tokens));\n        el.value = '';\n      }\n    }\n    var linkFn;\n    var hasAttrs = el.hasAttributes();\n    // check terminal directives (for & if)\n    if (hasAttrs) {\n      linkFn = checkTerminalDirectives(el, options);\n    }\n    // check element directives\n    if (!linkFn) {\n      linkFn = checkElementDirectives(el, options);\n    }\n    // check component\n    if (!linkFn) {\n      linkFn = checkComponent(el, options);\n    }\n    // normal directives\n    if (!linkFn && hasAttrs) {\n      linkFn = compileDirectives(el.attributes, options);\n    }\n    return linkFn;\n  }\n\n  /**\n   * Compile a textNode and return a nodeLinkFn.\n   *\n   * @param {TextNode} node\n   * @param {Object} options\n   * @return {Function|null} textNodeLinkFn\n   */\n\n  function compileTextNode(node, options) {\n    // skip marked text nodes\n    if (node._skip) {\n      return removeText;\n    }\n\n    var tokens = parseText(node.wholeText);\n    if (!tokens) {\n      return null;\n    }\n\n    // mark adjacent text nodes as skipped,\n    // because we are using node.wholeText to compile\n    // all adjacent text nodes together. This fixes\n    // issues in IE where sometimes it splits up a single\n    // text node into multiple ones.\n    var next = node.nextSibling;\n    while (next && next.nodeType === 3) {\n      next._skip = true;\n      next = next.nextSibling;\n    }\n\n    var frag = document.createDocumentFragment();\n    var el, token;\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i];\n      el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\n      frag.appendChild(el);\n    }\n    return makeTextNodeLinkFn(tokens, frag, options);\n  }\n\n  /**\n   * Linker for an skipped text node.\n   *\n   * @param {Vue} vm\n   * @param {Text} node\n   */\n\n  function removeText(vm, node) {\n    remove(node);\n  }\n\n  /**\n   * Process a single text token.\n   *\n   * @param {Object} token\n   * @param {Object} options\n   * @return {Node}\n   */\n\n  function processTextToken(token, options) {\n    var el;\n    if (token.oneTime) {\n      el = document.createTextNode(token.value);\n    } else {\n      if (token.html) {\n        el = document.createComment('v-html');\n        setTokenType('html');\n      } else {\n        // IE will clean up empty textNodes during\n        // frag.cloneNode(true), so we have to give it\n        // something here...\n        el = document.createTextNode(' ');\n        setTokenType('text');\n      }\n    }\n    function setTokenType(type) {\n      if (token.descriptor) return;\n      var parsed = parseDirective(token.value);\n      token.descriptor = {\n        name: type,\n        def: publicDirectives[type],\n        expression: parsed.expression,\n        filters: parsed.filters\n      };\n    }\n    return el;\n  }\n\n  /**\n   * Build a function that processes a textNode.\n   *\n   * @param {Array<Object>} tokens\n   * @param {DocumentFragment} frag\n   */\n\n  function makeTextNodeLinkFn(tokens, frag) {\n    return function textNodeLinkFn(vm, el, host, scope) {\n      var fragClone = frag.cloneNode(true);\n      var childNodes = toArray(fragClone.childNodes);\n      var token, value, node;\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        token = tokens[i];\n        value = token.value;\n        if (token.tag) {\n          node = childNodes[i];\n          if (token.oneTime) {\n            value = (scope || vm).$eval(value);\n            if (token.html) {\n              replace(node, parseTemplate(value, true));\n            } else {\n              node.data = value;\n            }\n          } else {\n            vm._bindDir(token.descriptor, node, host, scope);\n          }\n        }\n      }\n      replace(el, fragClone);\n    };\n  }\n\n  /**\n   * Compile a node list and return a childLinkFn.\n   *\n   * @param {NodeList} nodeList\n   * @param {Object} options\n   * @return {Function|undefined}\n   */\n\n  function compileNodeList(nodeList, options) {\n    var linkFns = [];\n    var nodeLinkFn, childLinkFn, node;\n    for (var i = 0, l = nodeList.length; i < l; i++) {\n      node = nodeList[i];\n      nodeLinkFn = compileNode(node, options);\n      childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\n      linkFns.push(nodeLinkFn, childLinkFn);\n    }\n    return linkFns.length ? makeChildLinkFn(linkFns) : null;\n  }\n\n  /**\n   * Make a child link function for a node's childNodes.\n   *\n   * @param {Array<Function>} linkFns\n   * @return {Function} childLinkFn\n   */\n\n  function makeChildLinkFn(linkFns) {\n    return function childLinkFn(vm, nodes, host, scope, frag) {\n      var node, nodeLinkFn, childrenLinkFn;\n      for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n        node = nodes[n];\n        nodeLinkFn = linkFns[i++];\n        childrenLinkFn = linkFns[i++];\n        // cache childNodes before linking parent, fix #657\n        var childNodes = toArray(node.childNodes);\n        if (nodeLinkFn) {\n          nodeLinkFn(vm, node, host, scope, frag);\n        }\n        if (childrenLinkFn) {\n          childrenLinkFn(vm, childNodes, host, scope, frag);\n        }\n      }\n    };\n  }\n\n  /**\n   * Check for element directives (custom elements that should\n   * be resovled as terminal directives).\n   *\n   * @param {Element} el\n   * @param {Object} options\n   */\n\n  function checkElementDirectives(el, options) {\n    var tag = el.tagName.toLowerCase();\n    if (commonTagRE.test(tag)) return;\n    // special case: give named slot a higher priority\n    // than unnamed slots\n    if (tag === 'slot' && hasBindAttr(el, 'name')) {\n      tag = '_namedSlot';\n    }\n    var def = resolveAsset(options, 'elementDirectives', tag);\n    if (def) {\n      return makeTerminalNodeLinkFn(el, tag, '', options, def);\n    }\n  }\n\n  /**\n   * Check if an element is a component. If yes, return\n   * a component link function.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Function|undefined}\n   */\n\n  function checkComponent(el, options) {\n    var component = checkComponentAttr(el, options);\n    if (component) {\n      var ref = findRef(el);\n      var descriptor = {\n        name: 'component',\n        ref: ref,\n        expression: component.id,\n        def: internalDirectives.component,\n        modifiers: {\n          literal: !component.dynamic\n        }\n      };\n      var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\n        if (ref) {\n          defineReactive((scope || vm).$refs, ref, null);\n        }\n        vm._bindDir(descriptor, el, host, scope, frag);\n      };\n      componentLinkFn.terminal = true;\n      return componentLinkFn;\n    }\n  }\n\n  /**\n   * Check an element for terminal directives in fixed order.\n   * If it finds one, return a terminal link function.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Function} terminalLinkFn\n   */\n\n  function checkTerminalDirectives(el, options) {\n    // skip v-pre\n    if (getAttr(el, 'v-pre') !== null) {\n      return skip;\n    }\n    // skip v-else block, but only if following v-if\n    if (el.hasAttribute('v-else')) {\n      var prev = el.previousElementSibling;\n      if (prev && prev.hasAttribute('v-if')) {\n        return skip;\n      }\n    }\n    var value, dirName;\n    for (var i = 0, l = terminalDirectives.length; i < l; i++) {\n      dirName = terminalDirectives[i];\n      value = el.getAttribute('v-' + dirName);\n      if (value != null) {\n        return makeTerminalNodeLinkFn(el, dirName, value, options);\n      }\n    }\n  }\n\n  function skip() {}\n  skip.terminal = true;\n\n  /**\n   * Build a node link function for a terminal directive.\n   * A terminal link function terminates the current\n   * compilation recursion and handles compilation of the\n   * subtree in the directive.\n   *\n   * @param {Element} el\n   * @param {String} dirName\n   * @param {String} value\n   * @param {Object} options\n   * @param {Object} [def]\n   * @return {Function} terminalLinkFn\n   */\n\n  function makeTerminalNodeLinkFn(el, dirName, value, options, def) {\n    var parsed = parseDirective(value);\n    var descriptor = {\n      name: dirName,\n      expression: parsed.expression,\n      filters: parsed.filters,\n      raw: value,\n      // either an element directive, or if/for\n      def: def || publicDirectives[dirName]\n    };\n    // check ref for v-for and router-view\n    if (dirName === 'for' || dirName === 'router-view') {\n      descriptor.ref = findRef(el);\n    }\n    var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n      if (descriptor.ref) {\n        defineReactive((scope || vm).$refs, descriptor.ref, null);\n      }\n      vm._bindDir(descriptor, el, host, scope, frag);\n    };\n    fn.terminal = true;\n    return fn;\n  }\n\n  /**\n   * Compile the directives on an element and return a linker.\n   *\n   * @param {Array|NamedNodeMap} attrs\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function compileDirectives(attrs, options) {\n    var i = attrs.length;\n    var dirs = [];\n    var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens;\n    while (i--) {\n      attr = attrs[i];\n      name = rawName = attr.name;\n      value = rawValue = attr.value;\n      tokens = parseText(value);\n      // reset arg\n      arg = null;\n      // check modifiers\n      modifiers = parseModifiers(name);\n      name = name.replace(modifierRE, '');\n\n      // attribute interpolations\n      if (tokens) {\n        value = tokensToExp(tokens);\n        arg = name;\n        pushDir('bind', publicDirectives.bind, tokens);\n        // warn against mixing mustaches with v-bind\n        if ('development' !== 'production') {\n          if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\n            return attr.name === ':class' || attr.name === 'v-bind:class';\n          })) {\n            warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.');\n          }\n        }\n      } else\n\n        // special attribute: transition\n        if (transitionRE.test(name)) {\n          modifiers.literal = !bindRE.test(name);\n          pushDir('transition', internalDirectives.transition);\n        } else\n\n          // event handlers\n          if (onRE.test(name)) {\n            arg = name.replace(onRE, '');\n            pushDir('on', publicDirectives.on);\n          } else\n\n            // attribute bindings\n            if (bindRE.test(name)) {\n              dirName = name.replace(bindRE, '');\n              if (dirName === 'style' || dirName === 'class') {\n                pushDir(dirName, internalDirectives[dirName]);\n              } else {\n                arg = dirName;\n                pushDir('bind', publicDirectives.bind);\n              }\n            } else\n\n              // normal directives\n              if (name.indexOf('v-') === 0) {\n                // check arg\n                arg = (arg = name.match(argRE)) && arg[1];\n                if (arg) {\n                  name = name.replace(argRE, '');\n                }\n                // extract directive name\n                dirName = name.slice(2);\n\n                // skip v-else (when used with v-show)\n                if (dirName === 'else') {\n                  continue;\n                }\n\n                dirDef = resolveAsset(options, 'directives', dirName);\n\n                if ('development' !== 'production') {\n                  assertAsset(dirDef, 'directive', dirName);\n                }\n\n                if (dirDef) {\n                  pushDir(dirName, dirDef);\n                }\n              }\n    }\n\n    /**\n     * Push a directive.\n     *\n     * @param {String} dirName\n     * @param {Object|Function} def\n     * @param {Array} [interpTokens]\n     */\n\n    function pushDir(dirName, def, interpTokens) {\n      var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\n      var parsed = !hasOneTimeToken && parseDirective(value);\n      dirs.push({\n        name: dirName,\n        attr: rawName,\n        raw: rawValue,\n        def: def,\n        arg: arg,\n        modifiers: modifiers,\n        // conversion from interpolation strings with one-time token\n        // to expression is differed until directive bind time so that we\n        // have access to the actual vm context for one-time bindings.\n        expression: parsed && parsed.expression,\n        filters: parsed && parsed.filters,\n        interp: interpTokens,\n        hasOneTime: hasOneTimeToken\n      });\n    }\n\n    if (dirs.length) {\n      return makeNodeLinkFn(dirs);\n    }\n  }\n\n  /**\n   * Parse modifiers from directive attribute name.\n   *\n   * @param {String} name\n   * @return {Object}\n   */\n\n  function parseModifiers(name) {\n    var res = Object.create(null);\n    var match = name.match(modifierRE);\n    if (match) {\n      var i = match.length;\n      while (i--) {\n        res[match[i].slice(1)] = true;\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Build a link function for all directives on a single node.\n   *\n   * @param {Array} directives\n   * @return {Function} directivesLinkFn\n   */\n\n  function makeNodeLinkFn(directives) {\n    return function nodeLinkFn(vm, el, host, scope, frag) {\n      // reverse apply because it's sorted low to high\n      var i = directives.length;\n      while (i--) {\n        vm._bindDir(directives[i], el, host, scope, frag);\n      }\n    };\n  }\n\n  /**\n   * Check if an interpolation string contains one-time tokens.\n   *\n   * @param {Array} tokens\n   * @return {Boolean}\n   */\n\n  function hasOneTime(tokens) {\n    var i = tokens.length;\n    while (i--) {\n      if (tokens[i].oneTime) return true;\n    }\n  }\n\n  var specialCharRE = /[^\\w\\-:\\.]/;\n\n  /**\n   * Process an element or a DocumentFragment based on a\n   * instance option object. This allows us to transclude\n   * a template node/fragment before the instance is created,\n   * so the processed fragment can then be cloned and reused\n   * in v-for.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Element|DocumentFragment}\n   */\n\n  function transclude(el, options) {\n    // extract container attributes to pass them down\n    // to compiler, because they need to be compiled in\n    // parent scope. we are mutating the options object here\n    // assuming the same object will be used for compile\n    // right after this.\n    if (options) {\n      options._containerAttrs = extractAttrs(el);\n    }\n    // for template tags, what we want is its content as\n    // a documentFragment (for fragment instances)\n    if (isTemplate(el)) {\n      el = parseTemplate(el);\n    }\n    if (options) {\n      if (options._asComponent && !options.template) {\n        options.template = '<slot></slot>';\n      }\n      if (options.template) {\n        options._content = extractContent(el);\n        el = transcludeTemplate(el, options);\n      }\n    }\n    if (el instanceof DocumentFragment) {\n      // anchors for fragment instance\n      // passing in `persist: true` to avoid them being\n      // discarded by IE during template cloning\n      prepend(createAnchor('v-start', true), el);\n      el.appendChild(createAnchor('v-end', true));\n    }\n    return el;\n  }\n\n  /**\n   * Process the template option.\n   * If the replace option is true this will swap the $el.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Element|DocumentFragment}\n   */\n\n  function transcludeTemplate(el, options) {\n    var template = options.template;\n    var frag = parseTemplate(template, true);\n    if (frag) {\n      var replacer = frag.firstChild;\n      var tag = replacer.tagName && replacer.tagName.toLowerCase();\n      if (options.replace) {\n        /* istanbul ignore if */\n        if (el === document.body) {\n          'development' !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\n        }\n        // there are many cases where the instance must\n        // become a fragment instance: basically anything that\n        // can create more than 1 root nodes.\n        if (\n        // multi-children template\n        frag.childNodes.length > 1 ||\n        // non-element template\n        replacer.nodeType !== 1 ||\n        // single nested component\n        tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\n        // element directive\n        resolveAsset(options, 'elementDirectives', tag) ||\n        // for block\n        replacer.hasAttribute('v-for') ||\n        // if block\n        replacer.hasAttribute('v-if')) {\n          return frag;\n        } else {\n          options._replacerAttrs = extractAttrs(replacer);\n          mergeAttrs(el, replacer);\n          return replacer;\n        }\n      } else {\n        el.appendChild(frag);\n        return el;\n      }\n    } else {\n      'development' !== 'production' && warn('Invalid template option: ' + template);\n    }\n  }\n\n  /**\n   * Helper to extract a component container's attributes\n   * into a plain object array.\n   *\n   * @param {Element} el\n   * @return {Array}\n   */\n\n  function extractAttrs(el) {\n    if (el.nodeType === 1 && el.hasAttributes()) {\n      return toArray(el.attributes);\n    }\n  }\n\n  /**\n   * Merge the attributes of two elements, and make sure\n   * the class names are merged properly.\n   *\n   * @param {Element} from\n   * @param {Element} to\n   */\n\n  function mergeAttrs(from, to) {\n    var attrs = from.attributes;\n    var i = attrs.length;\n    var name, value;\n    while (i--) {\n      name = attrs[i].name;\n      value = attrs[i].value;\n      if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n        to.setAttribute(name, value);\n      } else if (name === 'class' && !parseText(value)) {\n        value.split(/\\s+/).forEach(function (cls) {\n          addClass(to, cls);\n        });\n      }\n    }\n  }\n\n  var compiler = Object.freeze({\n  \tcompile: compile,\n  \tcompileAndLinkProps: compileAndLinkProps,\n  \tcompileRoot: compileRoot,\n  \tterminalDirectives: terminalDirectives,\n  \ttransclude: transclude\n  });\n\n  function stateMixin (Vue) {\n\n    /**\n     * Accessor for `$data` property, since setting $data\n     * requires observing the new object and updating\n     * proxied properties.\n     */\n\n    Object.defineProperty(Vue.prototype, '$data', {\n      get: function get() {\n        return this._data;\n      },\n      set: function set(newData) {\n        if (newData !== this._data) {\n          this._setData(newData);\n        }\n      }\n    });\n\n    /**\n     * Setup the scope of an instance, which contains:\n     * - observed data\n     * - computed properties\n     * - user methods\n     * - meta properties\n     */\n\n    Vue.prototype._initState = function () {\n      this._initProps();\n      this._initMeta();\n      this._initMethods();\n      this._initData();\n      this._initComputed();\n    };\n\n    /**\n     * Initialize props.\n     */\n\n    Vue.prototype._initProps = function () {\n      var options = this.$options;\n      var el = options.el;\n      var props = options.props;\n      if (props && !el) {\n        'development' !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.');\n      }\n      // make sure to convert string selectors into element now\n      el = options.el = query(el);\n      this._propsUnlinkFn = el && el.nodeType === 1 && props\n      // props must be linked in proper scope if inside v-for\n      ? compileAndLinkProps(this, el, props, this._scope) : null;\n    };\n\n    /**\n     * Initialize the data.\n     */\n\n    Vue.prototype._initData = function () {\n      var propsData = this._data;\n      var optionsDataFn = this.$options.data;\n      var optionsData = optionsDataFn && optionsDataFn();\n      if (optionsData) {\n        this._data = optionsData;\n        for (var prop in propsData) {\n          if ('development' !== 'production' && hasOwn(optionsData, prop)) {\n            warn('Data field \"' + prop + '\" is already defined ' + 'as a prop. Use prop default value instead.');\n          }\n          if (this._props[prop].raw !== null || !hasOwn(optionsData, prop)) {\n            set(optionsData, prop, propsData[prop]);\n          }\n        }\n      }\n      var data = this._data;\n      // proxy data on instance\n      var keys = Object.keys(data);\n      var i, key;\n      i = keys.length;\n      while (i--) {\n        key = keys[i];\n        this._proxy(key);\n      }\n      // observe data\n      observe(data, this);\n    };\n\n    /**\n     * Swap the instance's $data. Called in $data's setter.\n     *\n     * @param {Object} newData\n     */\n\n    Vue.prototype._setData = function (newData) {\n      newData = newData || {};\n      var oldData = this._data;\n      this._data = newData;\n      var keys, key, i;\n      // unproxy keys not present in new data\n      keys = Object.keys(oldData);\n      i = keys.length;\n      while (i--) {\n        key = keys[i];\n        if (!(key in newData)) {\n          this._unproxy(key);\n        }\n      }\n      // proxy keys not already proxied,\n      // and trigger change for changed values\n      keys = Object.keys(newData);\n      i = keys.length;\n      while (i--) {\n        key = keys[i];\n        if (!hasOwn(this, key)) {\n          // new property\n          this._proxy(key);\n        }\n      }\n      oldData.__ob__.removeVm(this);\n      observe(newData, this);\n      this._digest();\n    };\n\n    /**\n     * Proxy a property, so that\n     * vm.prop === vm._data.prop\n     *\n     * @param {String} key\n     */\n\n    Vue.prototype._proxy = function (key) {\n      if (!isReserved(key)) {\n        // need to store ref to self here\n        // because these getter/setters might\n        // be called by child scopes via\n        // prototype inheritance.\n        var self = this;\n        Object.defineProperty(self, key, {\n          configurable: true,\n          enumerable: true,\n          get: function proxyGetter() {\n            return self._data[key];\n          },\n          set: function proxySetter(val) {\n            self._data[key] = val;\n          }\n        });\n      }\n    };\n\n    /**\n     * Unproxy a property.\n     *\n     * @param {String} key\n     */\n\n    Vue.prototype._unproxy = function (key) {\n      if (!isReserved(key)) {\n        delete this[key];\n      }\n    };\n\n    /**\n     * Force update on every watcher in scope.\n     */\n\n    Vue.prototype._digest = function () {\n      for (var i = 0, l = this._watchers.length; i < l; i++) {\n        this._watchers[i].update(true); // shallow updates\n      }\n    };\n\n    /**\n     * Setup computed properties. They are essentially\n     * special getter/setters\n     */\n\n    function noop() {}\n    Vue.prototype._initComputed = function () {\n      var computed = this.$options.computed;\n      if (computed) {\n        for (var key in computed) {\n          var userDef = computed[key];\n          var def = {\n            enumerable: true,\n            configurable: true\n          };\n          if (typeof userDef === 'function') {\n            def.get = makeComputedGetter(userDef, this);\n            def.set = noop;\n          } else {\n            def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind$1(userDef.get, this) : noop;\n            def.set = userDef.set ? bind$1(userDef.set, this) : noop;\n          }\n          Object.defineProperty(this, key, def);\n        }\n      }\n    };\n\n    function makeComputedGetter(getter, owner) {\n      var watcher = new Watcher(owner, getter, null, {\n        lazy: true\n      });\n      return function computedGetter() {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value;\n      };\n    }\n\n    /**\n     * Setup instance methods. Methods must be bound to the\n     * instance since they might be passed down as a prop to\n     * child components.\n     */\n\n    Vue.prototype._initMethods = function () {\n      var methods = this.$options.methods;\n      if (methods) {\n        for (var key in methods) {\n          this[key] = bind$1(methods[key], this);\n        }\n      }\n    };\n\n    /**\n     * Initialize meta information like $index, $key & $value.\n     */\n\n    Vue.prototype._initMeta = function () {\n      var metas = this.$options._meta;\n      if (metas) {\n        for (var key in metas) {\n          defineReactive(this, key, metas[key]);\n        }\n      }\n    };\n  }\n\n  var eventRE = /^v-on:|^@/;\n\n  function eventsMixin (Vue) {\n\n    /**\n     * Setup the instance's option events & watchers.\n     * If the value is a string, we pull it from the\n     * instance's methods by name.\n     */\n\n    Vue.prototype._initEvents = function () {\n      var options = this.$options;\n      if (options._asComponent) {\n        registerComponentEvents(this, options.el);\n      }\n      registerCallbacks(this, '$on', options.events);\n      registerCallbacks(this, '$watch', options.watch);\n    };\n\n    /**\n     * Register v-on events on a child component\n     *\n     * @param {Vue} vm\n     * @param {Element} el\n     */\n\n    function registerComponentEvents(vm, el) {\n      var attrs = el.attributes;\n      var name, handler;\n      for (var i = 0, l = attrs.length; i < l; i++) {\n        name = attrs[i].name;\n        if (eventRE.test(name)) {\n          name = name.replace(eventRE, '');\n          handler = (vm._scope || vm._context).$eval(attrs[i].value, true);\n          handler._fromParent = true;\n          vm.$on(name.replace(eventRE), handler);\n        }\n      }\n    }\n\n    /**\n     * Register callbacks for option events and watchers.\n     *\n     * @param {Vue} vm\n     * @param {String} action\n     * @param {Object} hash\n     */\n\n    function registerCallbacks(vm, action, hash) {\n      if (!hash) return;\n      var handlers, key, i, j;\n      for (key in hash) {\n        handlers = hash[key];\n        if (isArray(handlers)) {\n          for (i = 0, j = handlers.length; i < j; i++) {\n            register(vm, action, key, handlers[i]);\n          }\n        } else {\n          register(vm, action, key, handlers);\n        }\n      }\n    }\n\n    /**\n     * Helper to register an event/watch callback.\n     *\n     * @param {Vue} vm\n     * @param {String} action\n     * @param {String} key\n     * @param {Function|String|Object} handler\n     * @param {Object} [options]\n     */\n\n    function register(vm, action, key, handler, options) {\n      var type = typeof handler;\n      if (type === 'function') {\n        vm[action](key, handler, options);\n      } else if (type === 'string') {\n        var methods = vm.$options.methods;\n        var method = methods && methods[handler];\n        if (method) {\n          vm[action](key, method, options);\n        } else {\n          'development' !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".');\n        }\n      } else if (handler && type === 'object') {\n        register(vm, action, key, handler.handler, handler);\n      }\n    }\n\n    /**\n     * Setup recursive attached/detached calls\n     */\n\n    Vue.prototype._initDOMHooks = function () {\n      this.$on('hook:attached', onAttached);\n      this.$on('hook:detached', onDetached);\n    };\n\n    /**\n     * Callback to recursively call attached hook on children\n     */\n\n    function onAttached() {\n      if (!this._isAttached) {\n        this._isAttached = true;\n        this.$children.forEach(callAttach);\n      }\n    }\n\n    /**\n     * Iterator to call attached hook\n     *\n     * @param {Vue} child\n     */\n\n    function callAttach(child) {\n      if (!child._isAttached && inDoc(child.$el)) {\n        child._callHook('attached');\n      }\n    }\n\n    /**\n     * Callback to recursively call detached hook on children\n     */\n\n    function onDetached() {\n      if (this._isAttached) {\n        this._isAttached = false;\n        this.$children.forEach(callDetach);\n      }\n    }\n\n    /**\n     * Iterator to call detached hook\n     *\n     * @param {Vue} child\n     */\n\n    function callDetach(child) {\n      if (child._isAttached && !inDoc(child.$el)) {\n        child._callHook('detached');\n      }\n    }\n\n    /**\n     * Trigger all handlers for a hook\n     *\n     * @param {String} hook\n     */\n\n    Vue.prototype._callHook = function (hook) {\n      this.$emit('pre-hook:' + hook);\n      var handlers = this.$options[hook];\n      if (handlers) {\n        for (var i = 0, j = handlers.length; i < j; i++) {\n          handlers[i].call(this);\n        }\n      }\n      this.$emit('hook:' + hook);\n    };\n  }\n\n  function noop() {}\n\n  /**\n   * A directive links a DOM element with a piece of data,\n   * which is the result of evaluating an expression.\n   * It registers a watcher with the expression and calls\n   * the DOM update function when a change is triggered.\n   *\n   * @param {String} name\n   * @param {Node} el\n   * @param {Vue} vm\n   * @param {Object} descriptor\n   *                 - {String} name\n   *                 - {Object} def\n   *                 - {String} expression\n   *                 - {Array<Object>} [filters]\n   *                 - {Boolean} literal\n   *                 - {String} attr\n   *                 - {String} raw\n   * @param {Object} def - directive definition object\n   * @param {Vue} [host] - transclusion host component\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - owner fragment\n   * @constructor\n   */\n  function Directive(descriptor, vm, el, host, scope, frag) {\n    this.vm = vm;\n    this.el = el;\n    // copy descriptor properties\n    this.descriptor = descriptor;\n    this.name = descriptor.name;\n    this.expression = descriptor.expression;\n    this.arg = descriptor.arg;\n    this.modifiers = descriptor.modifiers;\n    this.filters = descriptor.filters;\n    this.literal = this.modifiers && this.modifiers.literal;\n    // private\n    this._locked = false;\n    this._bound = false;\n    this._listeners = null;\n    // link context\n    this._host = host;\n    this._scope = scope;\n    this._frag = frag;\n    // store directives on node in dev mode\n    if ('development' !== 'production' && this.el) {\n      this.el._vue_directives = this.el._vue_directives || [];\n      this.el._vue_directives.push(this);\n    }\n  }\n\n  /**\n   * Initialize the directive, mixin definition properties,\n   * setup the watcher, call definition bind() and update()\n   * if present.\n   *\n   * @param {Object} def\n   */\n\n  Directive.prototype._bind = function () {\n    var name = this.name;\n    var descriptor = this.descriptor;\n\n    // remove attribute\n    if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\n      var attr = descriptor.attr || 'v-' + name;\n      this.el.removeAttribute(attr);\n    }\n\n    // copy def properties\n    var def = descriptor.def;\n    if (typeof def === 'function') {\n      this.update = def;\n    } else {\n      extend(this, def);\n    }\n\n    // setup directive params\n    this._setupParams();\n\n    // initial bind\n    if (this.bind) {\n      this.bind();\n    }\n    this._bound = true;\n\n    if (this.literal) {\n      this.update && this.update(descriptor.raw);\n    } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\n      // wrapped updater for context\n      var dir = this;\n      if (this.update) {\n        this._update = function (val, oldVal) {\n          if (!dir._locked) {\n            dir.update(val, oldVal);\n          }\n        };\n      } else {\n        this._update = noop;\n      }\n      var preProcess = this._preProcess ? bind$1(this._preProcess, this) : null;\n      var postProcess = this._postProcess ? bind$1(this._postProcess, this) : null;\n      var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n      {\n        filters: this.filters,\n        twoWay: this.twoWay,\n        deep: this.deep,\n        preProcess: preProcess,\n        postProcess: postProcess,\n        scope: this._scope\n      });\n      // v-model with inital inline value need to sync back to\n      // model instead of update to DOM on init. They would\n      // set the afterBind hook to indicate that.\n      if (this.afterBind) {\n        this.afterBind();\n      } else if (this.update) {\n        this.update(watcher.value);\n      }\n    }\n  };\n\n  /**\n   * Setup all param attributes, e.g. track-by,\n   * transition-mode, etc...\n   */\n\n  Directive.prototype._setupParams = function () {\n    if (!this.params) {\n      return;\n    }\n    var params = this.params;\n    // swap the params array with a fresh object.\n    this.params = Object.create(null);\n    var i = params.length;\n    var key, val, mappedKey;\n    while (i--) {\n      key = params[i];\n      mappedKey = camelize(key);\n      val = getBindAttr(this.el, key);\n      if (val != null) {\n        // dynamic\n        this._setupParamWatcher(mappedKey, val);\n      } else {\n        // static\n        val = getAttr(this.el, key);\n        if (val != null) {\n          this.params[mappedKey] = val === '' ? true : val;\n        }\n      }\n    }\n  };\n\n  /**\n   * Setup a watcher for a dynamic param.\n   *\n   * @param {String} key\n   * @param {String} expression\n   */\n\n  Directive.prototype._setupParamWatcher = function (key, expression) {\n    var self = this;\n    var called = false;\n    var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n      self.params[key] = val;\n      // since we are in immediate mode,\n      // only call the param change callbacks if this is not the first update.\n      if (called) {\n        var cb = self.paramWatchers && self.paramWatchers[key];\n        if (cb) {\n          cb.call(self, val, oldVal);\n        }\n      } else {\n        called = true;\n      }\n    }, {\n      immediate: true,\n      user: false\n    });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\n  };\n\n  /**\n   * Check if the directive is a function caller\n   * and if the expression is a callable one. If both true,\n   * we wrap up the expression and use it as the event\n   * handler.\n   *\n   * e.g. on-click=\"a++\"\n   *\n   * @return {Boolean}\n   */\n\n  Directive.prototype._checkStatement = function () {\n    var expression = this.expression;\n    if (expression && this.acceptStatement && !isSimplePath(expression)) {\n      var fn = parseExpression(expression).get;\n      var scope = this._scope || this.vm;\n      var handler = function handler(e) {\n        scope.$event = e;\n        fn.call(scope, scope);\n        scope.$event = null;\n      };\n      if (this.filters) {\n        handler = scope._applyFilters(handler, null, this.filters);\n      }\n      this.update(handler);\n      return true;\n    }\n  };\n\n  /**\n   * Set the corresponding value with the setter.\n   * This should only be used in two-way directives\n   * e.g. v-model.\n   *\n   * @param {*} value\n   * @public\n   */\n\n  Directive.prototype.set = function (value) {\n    /* istanbul ignore else */\n    if (this.twoWay) {\n      this._withLock(function () {\n        this._watcher.set(value);\n      });\n    } else if ('development' !== 'production') {\n      warn('Directive.set() can only be used inside twoWay' + 'directives.');\n    }\n  };\n\n  /**\n   * Execute a function while preventing that function from\n   * triggering updates on this directive instance.\n   *\n   * @param {Function} fn\n   */\n\n  Directive.prototype._withLock = function (fn) {\n    var self = this;\n    self._locked = true;\n    fn.call(self);\n    nextTick(function () {\n      self._locked = false;\n    });\n  };\n\n  /**\n   * Convenience method that attaches a DOM event listener\n   * to the directive element and autometically tears it down\n   * during unbind.\n   *\n   * @param {String} event\n   * @param {Function} handler\n   */\n\n  Directive.prototype.on = function (event, handler) {\n    on$1(this.el, event, handler);(this._listeners || (this._listeners = [])).push([event, handler]);\n  };\n\n  /**\n   * Teardown the watcher and call unbind.\n   */\n\n  Directive.prototype._teardown = function () {\n    if (this._bound) {\n      this._bound = false;\n      if (this.unbind) {\n        this.unbind();\n      }\n      if (this._watcher) {\n        this._watcher.teardown();\n      }\n      var listeners = this._listeners;\n      var i;\n      if (listeners) {\n        i = listeners.length;\n        while (i--) {\n          off(this.el, listeners[i][0], listeners[i][1]);\n        }\n      }\n      var unwatchFns = this._paramUnwatchFns;\n      if (unwatchFns) {\n        i = unwatchFns.length;\n        while (i--) {\n          unwatchFns[i]();\n        }\n      }\n      if ('development' !== 'production' && this.el) {\n        this.el._vue_directives.$remove(this);\n      }\n      this.vm = this.el = this._watcher = this._listeners = null;\n    }\n  };\n\n  function lifecycleMixin (Vue) {\n\n    /**\n     * Update v-ref for component.\n     *\n     * @param {Boolean} remove\n     */\n\n    Vue.prototype._updateRef = function (remove) {\n      var ref = this.$options._ref;\n      if (ref) {\n        var refs = (this._scope || this._context).$refs;\n        if (remove) {\n          if (refs[ref] === this) {\n            refs[ref] = null;\n          }\n        } else {\n          refs[ref] = this;\n        }\n      }\n    };\n\n    /**\n     * Transclude, compile and link element.\n     *\n     * If a pre-compiled linker is available, that means the\n     * passed in element will be pre-transcluded and compiled\n     * as well - all we need to do is to call the linker.\n     *\n     * Otherwise we need to call transclude/compile/link here.\n     *\n     * @param {Element} el\n     * @return {Element}\n     */\n\n    Vue.prototype._compile = function (el) {\n      var options = this.$options;\n\n      // transclude and init element\n      // transclude can potentially replace original\n      // so we need to keep reference; this step also injects\n      // the template and caches the original attributes\n      // on the container node and replacer node.\n      var original = el;\n      el = transclude(el, options);\n      this._initElement(el);\n\n      // handle v-pre on root node (#2026)\n      if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\n        return;\n      }\n\n      // root is always compiled per-instance, because\n      // container attrs and props can be different every time.\n      var contextOptions = this._context && this._context.$options;\n      var rootLinker = compileRoot(el, options, contextOptions);\n\n      // compile and link the rest\n      var contentLinkFn;\n      var ctor = this.constructor;\n      // component compilation can be cached\n      // as long as it's not using inline-template\n      if (options._linkerCachable) {\n        contentLinkFn = ctor.linker;\n        if (!contentLinkFn) {\n          contentLinkFn = ctor.linker = compile(el, options);\n        }\n      }\n\n      // link phase\n      // make sure to link root with prop scope!\n      var rootUnlinkFn = rootLinker(this, el, this._scope);\n      var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\n\n      // register composite unlink function\n      // to be called during instance destruction\n      this._unlinkFn = function () {\n        rootUnlinkFn();\n        // passing destroying: true to avoid searching and\n        // splicing the directives\n        contentUnlinkFn(true);\n      };\n\n      // finally replace original\n      if (options.replace) {\n        replace(original, el);\n      }\n\n      this._isCompiled = true;\n      this._callHook('compiled');\n      return el;\n    };\n\n    /**\n     * Initialize instance element. Called in the public\n     * $mount() method.\n     *\n     * @param {Element} el\n     */\n\n    Vue.prototype._initElement = function (el) {\n      if (el instanceof DocumentFragment) {\n        this._isFragment = true;\n        this.$el = this._fragmentStart = el.firstChild;\n        this._fragmentEnd = el.lastChild;\n        // set persisted text anchors to empty\n        if (this._fragmentStart.nodeType === 3) {\n          this._fragmentStart.data = this._fragmentEnd.data = '';\n        }\n        this._fragment = el;\n      } else {\n        this.$el = el;\n      }\n      this.$el.__vue__ = this;\n      this._callHook('beforeCompile');\n    };\n\n    /**\n     * Create and bind a directive to an element.\n     *\n     * @param {String} name - directive name\n     * @param {Node} node   - target node\n     * @param {Object} desc - parsed directive descriptor\n     * @param {Object} def  - directive definition object\n     * @param {Vue} [host] - transclusion host component\n     * @param {Object} [scope] - v-for scope\n     * @param {Fragment} [frag] - owner fragment\n     */\n\n    Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\n      this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\n    };\n\n    /**\n     * Teardown an instance, unobserves the data, unbind all the\n     * directives, turn off all the event listeners, etc.\n     *\n     * @param {Boolean} remove - whether to remove the DOM node.\n     * @param {Boolean} deferCleanup - if true, defer cleanup to\n     *                                 be called later\n     */\n\n    Vue.prototype._destroy = function (remove, deferCleanup) {\n      if (this._isBeingDestroyed) {\n        if (!deferCleanup) {\n          this._cleanup();\n        }\n        return;\n      }\n\n      var destroyReady;\n      var pendingRemoval;\n\n      var self = this;\n      // Cleanup should be called either synchronously or asynchronoysly as\n      // callback of this.$remove(), or if remove and deferCleanup are false.\n      // In any case it should be called after all other removing, unbinding and\n      // turning of is done\n      var cleanupIfPossible = function cleanupIfPossible() {\n        if (destroyReady && !pendingRemoval && !deferCleanup) {\n          self._cleanup();\n        }\n      };\n\n      // remove DOM element\n      if (remove && this.$el) {\n        pendingRemoval = true;\n        this.$remove(function () {\n          pendingRemoval = false;\n          cleanupIfPossible();\n        });\n      }\n\n      this._callHook('beforeDestroy');\n      this._isBeingDestroyed = true;\n      var i;\n      // remove self from parent. only necessary\n      // if parent is not being destroyed as well.\n      var parent = this.$parent;\n      if (parent && !parent._isBeingDestroyed) {\n        parent.$children.$remove(this);\n        // unregister ref (remove: true)\n        this._updateRef(true);\n      }\n      // destroy all children.\n      i = this.$children.length;\n      while (i--) {\n        this.$children[i].$destroy();\n      }\n      // teardown props\n      if (this._propsUnlinkFn) {\n        this._propsUnlinkFn();\n      }\n      // teardown all directives. this also tearsdown all\n      // directive-owned watchers.\n      if (this._unlinkFn) {\n        this._unlinkFn();\n      }\n      i = this._watchers.length;\n      while (i--) {\n        this._watchers[i].teardown();\n      }\n      // remove reference to self on $el\n      if (this.$el) {\n        this.$el.__vue__ = null;\n      }\n\n      destroyReady = true;\n      cleanupIfPossible();\n    };\n\n    /**\n     * Clean up to ensure garbage collection.\n     * This is called after the leave transition if there\n     * is any.\n     */\n\n    Vue.prototype._cleanup = function () {\n      if (this._isDestroyed) {\n        return;\n      }\n      // remove self from owner fragment\n      // do it in cleanup so that we can call $destroy with\n      // defer right when a fragment is about to be removed.\n      if (this._frag) {\n        this._frag.children.$remove(this);\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (this._data.__ob__) {\n        this._data.__ob__.removeVm(this);\n      }\n      // Clean up references to private properties and other\n      // instances. preserve reference to _data so that proxy\n      // accessors still work. The only potential side effect\n      // here is that mutating the instance after it's destroyed\n      // may affect the state of other components that are still\n      // observing the same object, but that seems to be a\n      // reasonable responsibility for the user rather than\n      // always throwing an error on them.\n      this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\n      // call the last hook...\n      this._isDestroyed = true;\n      this._callHook('destroyed');\n      // turn off all instance listeners.\n      this.$off();\n    };\n  }\n\n  function miscMixin (Vue) {\n\n    /**\n     * Apply a list of filter (descriptors) to a value.\n     * Using plain for loops here because this will be called in\n     * the getter of any watcher with filters so it is very\n     * performance sensitive.\n     *\n     * @param {*} value\n     * @param {*} [oldValue]\n     * @param {Array} filters\n     * @param {Boolean} write\n     * @return {*}\n     */\n\n    Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\n      var filter, fn, args, arg, offset, i, l, j, k;\n      for (i = 0, l = filters.length; i < l; i++) {\n        filter = filters[i];\n        fn = resolveAsset(this.$options, 'filters', filter.name);\n        if ('development' !== 'production') {\n          assertAsset(fn, 'filter', filter.name);\n        }\n        if (!fn) continue;\n        fn = write ? fn.write : fn.read || fn;\n        if (typeof fn !== 'function') continue;\n        args = write ? [value, oldValue] : [value];\n        offset = write ? 2 : 1;\n        if (filter.args) {\n          for (j = 0, k = filter.args.length; j < k; j++) {\n            arg = filter.args[j];\n            args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\n          }\n        }\n        value = fn.apply(this, args);\n      }\n      return value;\n    };\n\n    /**\n     * Resolve a component, depending on whether the component\n     * is defined normally or using an async factory function.\n     * Resolves synchronously if already resolved, otherwise\n     * resolves asynchronously and caches the resolved\n     * constructor on the factory.\n     *\n     * @param {String} id\n     * @param {Function} cb\n     */\n\n    Vue.prototype._resolveComponent = function (id, cb) {\n      var factory = resolveAsset(this.$options, 'components', id);\n      if ('development' !== 'production') {\n        assertAsset(factory, 'component', id);\n      }\n      if (!factory) {\n        return;\n      }\n      // async component factory\n      if (!factory.options) {\n        if (factory.resolved) {\n          // cached\n          cb(factory.resolved);\n        } else if (factory.requested) {\n          // pool callbacks\n          factory.pendingCallbacks.push(cb);\n        } else {\n          factory.requested = true;\n          var cbs = factory.pendingCallbacks = [cb];\n          factory(function resolve(res) {\n            if (isPlainObject(res)) {\n              res = Vue.extend(res);\n            }\n            // cache resolved\n            factory.resolved = res;\n            // invoke callbacks\n            for (var i = 0, l = cbs.length; i < l; i++) {\n              cbs[i](res);\n            }\n          }, function reject(reason) {\n            'development' !== 'production' && warn('Failed to resolve async component: ' + id + '. ' + (reason ? '\\nReason: ' + reason : ''));\n          });\n        }\n      } else {\n        // normal component\n        cb(factory);\n      }\n    };\n  }\n\n  function globalAPI (Vue) {\n\n    /**\n     * Expose useful internals\n     */\n\n    Vue.util = util;\n    Vue.config = config;\n    Vue.set = set;\n    Vue['delete'] = del;\n    Vue.nextTick = nextTick;\n\n    /**\n     * The following are exposed for advanced usage / plugins\n     */\n\n    Vue.compiler = compiler;\n    Vue.FragmentFactory = FragmentFactory;\n    Vue.internalDirectives = internalDirectives;\n    Vue.parsers = {\n      path: path,\n      text: text$1,\n      template: template,\n      directive: directive,\n      expression: expression\n    };\n\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     *\n     * @param {Object} extendOptions\n     */\n\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var isFirstExtend = Super.cid === 0;\n      if (isFirstExtend && extendOptions._Ctor) {\n        return extendOptions._Ctor;\n      }\n      var name = extendOptions.name || Super.options.name;\n      if ('development' !== 'production') {\n        if (!/^[a-zA-Z][\\w-]+$/.test(name)) {\n          warn('Invalid component name: ' + name);\n          name = null;\n        }\n      }\n      var Sub = createClass(name || 'VueComponent');\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super;\n      // allow further extension\n      Sub.extend = Super.extend;\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      config._assetTypes.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n      // cache constructor\n      if (isFirstExtend) {\n        extendOptions._Ctor = Sub;\n      }\n      return Sub;\n    };\n\n    /**\n     * A function that returns a sub-class constructor with the\n     * given name. This gives us much nicer output when\n     * logging instances in the console.\n     *\n     * @param {String} name\n     * @return {Function}\n     */\n\n    function createClass(name) {\n      return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\n    }\n\n    /**\n     * Plugin system\n     *\n     * @param {Object} plugin\n     */\n\n    Vue.use = function (plugin) {\n      /* istanbul ignore if */\n      if (plugin.installed) {\n        return;\n      }\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else {\n        plugin.apply(null, args);\n      }\n      plugin.installed = true;\n      return this;\n    };\n\n    /**\n     * Apply a global mixin by merging it into the default\n     * options.\n     */\n\n    Vue.mixin = function (mixin) {\n      Vue.options = mergeOptions(Vue.options, mixin);\n    };\n\n    /**\n     * Create asset registration methods with the following\n     * signature:\n     *\n     * @param {String} id\n     * @param {*} definition\n     */\n\n    config._assetTypes.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if ('development' !== 'production') {\n            if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\n              warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n            }\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = id;\n            definition = Vue.extend(definition);\n          }\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n\n  var filterRE = /[^|]\\|[^|]/;\n\n  function dataAPI (Vue) {\n\n    /**\n     * Get the value from an expression on this vm.\n     *\n     * @param {String} exp\n     * @param {Boolean} [asStatement]\n     * @return {*}\n     */\n\n    Vue.prototype.$get = function (exp, asStatement) {\n      var res = parseExpression(exp);\n      if (res) {\n        if (asStatement && !isSimplePath(exp)) {\n          var self = this;\n          return function statementHandler() {\n            self.$arguments = toArray(arguments);\n            var result = res.get.call(self, self);\n            self.$arguments = null;\n            return result;\n          };\n        } else {\n          try {\n            return res.get.call(this, this);\n          } catch (e) {}\n        }\n      }\n    };\n\n    /**\n     * Set the value from an expression on this vm.\n     * The expression must be a valid left-hand\n     * expression in an assignment.\n     *\n     * @param {String} exp\n     * @param {*} val\n     */\n\n    Vue.prototype.$set = function (exp, val) {\n      var res = parseExpression(exp, true);\n      if (res && res.set) {\n        res.set.call(this, this, val);\n      }\n    };\n\n    /**\n     * Delete a property on the VM\n     *\n     * @param {String} key\n     */\n\n    Vue.prototype.$delete = function (key) {\n      del(this._data, key);\n    };\n\n    /**\n     * Watch an expression, trigger callback when its\n     * value changes.\n     *\n     * @param {String|Function} expOrFn\n     * @param {Function} cb\n     * @param {Object} [options]\n     *                 - {Boolean} deep\n     *                 - {Boolean} immediate\n     * @return {Function} - unwatchFn\n     */\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n      var parsed;\n      if (typeof expOrFn === 'string') {\n        parsed = parseDirective(expOrFn);\n        expOrFn = parsed.expression;\n      }\n      var watcher = new Watcher(vm, expOrFn, cb, {\n        deep: options && options.deep,\n        sync: options && options.sync,\n        filters: parsed && parsed.filters,\n        user: !options || options.user !== false\n      });\n      if (options && options.immediate) {\n        cb.call(vm, watcher.value);\n      }\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n\n    /**\n     * Evaluate a text directive, including filters.\n     *\n     * @param {String} text\n     * @param {Boolean} [asStatement]\n     * @return {String}\n     */\n\n    Vue.prototype.$eval = function (text, asStatement) {\n      // check for filters.\n      if (filterRE.test(text)) {\n        var dir = parseDirective(text);\n        // the filter regex check might give false positive\n        // for pipes inside strings, so it's possible that\n        // we don't get any filters here\n        var val = this.$get(dir.expression, asStatement);\n        return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\n      } else {\n        // no filter\n        return this.$get(text, asStatement);\n      }\n    };\n\n    /**\n     * Interpolate a piece of template text.\n     *\n     * @param {String} text\n     * @return {String}\n     */\n\n    Vue.prototype.$interpolate = function (text) {\n      var tokens = parseText(text);\n      var vm = this;\n      if (tokens) {\n        if (tokens.length === 1) {\n          return vm.$eval(tokens[0].value) + '';\n        } else {\n          return tokens.map(function (token) {\n            return token.tag ? vm.$eval(token.value) : token.value;\n          }).join('');\n        }\n      } else {\n        return text;\n      }\n    };\n\n    /**\n     * Log instance data as a plain JS object\n     * so that it is easier to inspect in console.\n     * This method assumes console is available.\n     *\n     * @param {String} [path]\n     */\n\n    Vue.prototype.$log = function (path) {\n      var data = path ? getPath(this._data, path) : this._data;\n      if (data) {\n        data = clean(data);\n      }\n      // include computed fields\n      if (!path) {\n        for (var key in this.$options.computed) {\n          data[key] = clean(this[key]);\n        }\n      }\n      console.log(data);\n    };\n\n    /**\n     * \"clean\" a getter/setter converted object into a plain\n     * object copy.\n     *\n     * @param {Object} - obj\n     * @return {Object}\n     */\n\n    function clean(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n  }\n\n  function domAPI (Vue) {\n\n    /**\n     * Convenience on-instance nextTick. The callback is\n     * auto-bound to the instance, and this avoids component\n     * modules having to rely on the global Vue.\n     *\n     * @param {Function} fn\n     */\n\n    Vue.prototype.$nextTick = function (fn) {\n      nextTick(fn, this);\n    };\n\n    /**\n     * Append instance to target\n     *\n     * @param {Node} target\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition] - defaults to true\n     */\n\n    Vue.prototype.$appendTo = function (target, cb, withTransition) {\n      return insert(this, target, cb, withTransition, append, appendWithTransition);\n    };\n\n    /**\n     * Prepend instance to target\n     *\n     * @param {Node} target\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition] - defaults to true\n     */\n\n    Vue.prototype.$prependTo = function (target, cb, withTransition) {\n      target = query(target);\n      if (target.hasChildNodes()) {\n        this.$before(target.firstChild, cb, withTransition);\n      } else {\n        this.$appendTo(target, cb, withTransition);\n      }\n      return this;\n    };\n\n    /**\n     * Insert instance before target\n     *\n     * @param {Node} target\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition] - defaults to true\n     */\n\n    Vue.prototype.$before = function (target, cb, withTransition) {\n      return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\n    };\n\n    /**\n     * Insert instance after target\n     *\n     * @param {Node} target\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition] - defaults to true\n     */\n\n    Vue.prototype.$after = function (target, cb, withTransition) {\n      target = query(target);\n      if (target.nextSibling) {\n        this.$before(target.nextSibling, cb, withTransition);\n      } else {\n        this.$appendTo(target.parentNode, cb, withTransition);\n      }\n      return this;\n    };\n\n    /**\n     * Remove instance from DOM\n     *\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition] - defaults to true\n     */\n\n    Vue.prototype.$remove = function (cb, withTransition) {\n      if (!this.$el.parentNode) {\n        return cb && cb();\n      }\n      var inDocument = this._isAttached && inDoc(this.$el);\n      // if we are not in document, no need to check\n      // for transitions\n      if (!inDocument) withTransition = false;\n      var self = this;\n      var realCb = function realCb() {\n        if (inDocument) self._callHook('detached');\n        if (cb) cb();\n      };\n      if (this._isFragment) {\n        removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\n      } else {\n        var op = withTransition === false ? removeWithCb : removeWithTransition;\n        op(this.$el, this, realCb);\n      }\n      return this;\n    };\n\n    /**\n     * Shared DOM insertion function.\n     *\n     * @param {Vue} vm\n     * @param {Element} target\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition]\n     * @param {Function} op1 - op for non-transition insert\n     * @param {Function} op2 - op for transition insert\n     * @return vm\n     */\n\n    function insert(vm, target, cb, withTransition, op1, op2) {\n      target = query(target);\n      var targetIsDetached = !inDoc(target);\n      var op = withTransition === false || targetIsDetached ? op1 : op2;\n      var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\n      if (vm._isFragment) {\n        mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n          op(node, target, vm);\n        });\n        cb && cb();\n      } else {\n        op(vm.$el, target, vm, cb);\n      }\n      if (shouldCallHook) {\n        vm._callHook('attached');\n      }\n      return vm;\n    }\n\n    /**\n     * Check for selectors\n     *\n     * @param {String|Element} el\n     */\n\n    function query(el) {\n      return typeof el === 'string' ? document.querySelector(el) : el;\n    }\n\n    /**\n     * Append operation that takes a callback.\n     *\n     * @param {Node} el\n     * @param {Node} target\n     * @param {Vue} vm - unused\n     * @param {Function} [cb]\n     */\n\n    function append(el, target, vm, cb) {\n      target.appendChild(el);\n      if (cb) cb();\n    }\n\n    /**\n     * InsertBefore operation that takes a callback.\n     *\n     * @param {Node} el\n     * @param {Node} target\n     * @param {Vue} vm - unused\n     * @param {Function} [cb]\n     */\n\n    function beforeWithCb(el, target, vm, cb) {\n      before(el, target);\n      if (cb) cb();\n    }\n\n    /**\n     * Remove operation that takes a callback.\n     *\n     * @param {Node} el\n     * @param {Vue} vm - unused\n     * @param {Function} [cb]\n     */\n\n    function removeWithCb(el, vm, cb) {\n      remove(el);\n      if (cb) cb();\n    }\n  }\n\n  function eventsAPI (Vue) {\n\n    /**\n     * Listen on the given `event` with `fn`.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     */\n\n    Vue.prototype.$on = function (event, fn) {\n      (this._events[event] || (this._events[event] = [])).push(fn);\n      modifyListenerCount(this, event, 1);\n      return this;\n    };\n\n    /**\n     * Adds an `event` listener that will be invoked a single\n     * time then automatically removed.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     */\n\n    Vue.prototype.$once = function (event, fn) {\n      var self = this;\n      function on() {\n        self.$off(event, on);\n        fn.apply(this, arguments);\n      }\n      on.fn = fn;\n      this.$on(event, on);\n      return this;\n    };\n\n    /**\n     * Remove the given callback for `event` or all\n     * registered callbacks.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     */\n\n    Vue.prototype.$off = function (event, fn) {\n      var cbs;\n      // all\n      if (!arguments.length) {\n        if (this.$parent) {\n          for (event in this._events) {\n            cbs = this._events[event];\n            if (cbs) {\n              modifyListenerCount(this, event, -cbs.length);\n            }\n          }\n        }\n        this._events = {};\n        return this;\n      }\n      // specific event\n      cbs = this._events[event];\n      if (!cbs) {\n        return this;\n      }\n      if (arguments.length === 1) {\n        modifyListenerCount(this, event, -cbs.length);\n        this._events[event] = null;\n        return this;\n      }\n      // specific handler\n      var cb;\n      var i = cbs.length;\n      while (i--) {\n        cb = cbs[i];\n        if (cb === fn || cb.fn === fn) {\n          modifyListenerCount(this, event, -1);\n          cbs.splice(i, 1);\n          break;\n        }\n      }\n      return this;\n    };\n\n    /**\n     * Trigger an event on self.\n     *\n     * @param {String|Object} event\n     * @return {Boolean} shouldPropagate\n     */\n\n    Vue.prototype.$emit = function (event) {\n      var isSource = typeof event === 'string';\n      event = isSource ? event : event.name;\n      var cbs = this._events[event];\n      var shouldPropagate = isSource || !cbs;\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        // this is a somewhat hacky solution to the question raised\n        // in #2102: for an inline component listener like <comp @test=\"doThis\">,\n        // the propagation handling is somewhat broken. Therefore we\n        // need to treat these inline callbacks differently.\n        var hasParentCbs = isSource && cbs.some(function (cb) {\n          return cb._fromParent;\n        });\n        if (hasParentCbs) {\n          shouldPropagate = false;\n        }\n        var args = toArray(arguments, 1);\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          var cb = cbs[i];\n          var res = cb.apply(this, args);\n          if (res === true && (!hasParentCbs || cb._fromParent)) {\n            shouldPropagate = true;\n          }\n        }\n      }\n      return shouldPropagate;\n    };\n\n    /**\n     * Recursively broadcast an event to all children instances.\n     *\n     * @param {String|Object} event\n     * @param {...*} additional arguments\n     */\n\n    Vue.prototype.$broadcast = function (event) {\n      var isSource = typeof event === 'string';\n      event = isSource ? event : event.name;\n      // if no child has registered for this event,\n      // then there's no need to broadcast.\n      if (!this._eventsCount[event]) return;\n      var children = this.$children;\n      var args = toArray(arguments);\n      if (isSource) {\n        // use object event to indicate non-source emit\n        // on children\n        args[0] = { name: event, source: this };\n      }\n      for (var i = 0, l = children.length; i < l; i++) {\n        var child = children[i];\n        var shouldPropagate = child.$emit.apply(child, args);\n        if (shouldPropagate) {\n          child.$broadcast.apply(child, args);\n        }\n      }\n      return this;\n    };\n\n    /**\n     * Recursively propagate an event up the parent chain.\n     *\n     * @param {String} event\n     * @param {...*} additional arguments\n     */\n\n    Vue.prototype.$dispatch = function (event) {\n      var shouldPropagate = this.$emit.apply(this, arguments);\n      if (!shouldPropagate) return;\n      var parent = this.$parent;\n      var args = toArray(arguments);\n      // use object event to indicate non-source emit\n      // on parents\n      args[0] = { name: event, source: this };\n      while (parent) {\n        shouldPropagate = parent.$emit.apply(parent, args);\n        parent = shouldPropagate ? parent.$parent : null;\n      }\n      return this;\n    };\n\n    /**\n     * Modify the listener counts on all parents.\n     * This bookkeeping allows $broadcast to return early when\n     * no child has listened to a certain event.\n     *\n     * @param {Vue} vm\n     * @param {String} event\n     * @param {Number} count\n     */\n\n    var hookRE = /^hook:/;\n    function modifyListenerCount(vm, event, count) {\n      var parent = vm.$parent;\n      // hooks do not get broadcasted so no need\n      // to do bookkeeping for them\n      if (!parent || !count || hookRE.test(event)) return;\n      while (parent) {\n        parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\n        parent = parent.$parent;\n      }\n    }\n  }\n\n  function lifecycleAPI (Vue) {\n\n    /**\n     * Set instance target element and kick off the compilation\n     * process. The passed in `el` can be a selector string, an\n     * existing Element, or a DocumentFragment (for block\n     * instances).\n     *\n     * @param {Element|DocumentFragment|string} el\n     * @public\n     */\n\n    Vue.prototype.$mount = function (el) {\n      if (this._isCompiled) {\n        'development' !== 'production' && warn('$mount() should be called only once.');\n        return;\n      }\n      el = query(el);\n      if (!el) {\n        el = document.createElement('div');\n      }\n      this._compile(el);\n      this._initDOMHooks();\n      if (inDoc(this.$el)) {\n        this._callHook('attached');\n        ready.call(this);\n      } else {\n        this.$once('hook:attached', ready);\n      }\n      return this;\n    };\n\n    /**\n     * Mark an instance as ready.\n     */\n\n    function ready() {\n      this._isAttached = true;\n      this._isReady = true;\n      this._callHook('ready');\n    }\n\n    /**\n     * Teardown the instance, simply delegate to the internal\n     * _destroy.\n     */\n\n    Vue.prototype.$destroy = function (remove, deferCleanup) {\n      this._destroy(remove, deferCleanup);\n    };\n\n    /**\n     * Partially compile a piece of DOM and return a\n     * decompile function.\n     *\n     * @param {Element|DocumentFragment} el\n     * @param {Vue} [host]\n     * @return {Function}\n     */\n\n    Vue.prototype.$compile = function (el, host, scope, frag) {\n      return compile(el, this.$options, true)(this, el, host, scope, frag);\n    };\n  }\n\n  /**\n   * The exposed Vue constructor.\n   *\n   * API conventions:\n   * - public API methods/properties are prefixed with `$`\n   * - internal methods/properties are prefixed with `_`\n   * - non-prefixed properties are assumed to be proxied user\n   *   data.\n   *\n   * @constructor\n   * @param {Object} [options]\n   * @public\n   */\n\n  function Vue(options) {\n    this._init(options);\n  }\n\n  // install internals\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  miscMixin(Vue);\n\n  // install APIs\n  globalAPI(Vue);\n  dataAPI(Vue);\n  domAPI(Vue);\n  eventsAPI(Vue);\n  lifecycleAPI(Vue);\n\n  var convertArray = vFor._postProcess;\n\n  /**\n   * Limit filter for arrays\n   *\n   * @param {Number} n\n   * @param {Number} offset (Decimal expected)\n   */\n\n  function limitBy(arr, n, offset) {\n    offset = offset ? parseInt(offset, 10) : 0;\n    n = toNumber(n);\n    return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\n  }\n\n  /**\n   * Filter filter for arrays\n   *\n   * @param {String} search\n   * @param {String} [delimiter]\n   * @param {String} ...dataKeys\n   */\n\n  function filterBy(arr, search, delimiter) {\n    arr = convertArray(arr);\n    if (search == null) {\n      return arr;\n    }\n    if (typeof search === 'function') {\n      return arr.filter(search);\n    }\n    // cast to lowercase string\n    search = ('' + search).toLowerCase();\n    // allow optional `in` delimiter\n    // because why not\n    var n = delimiter === 'in' ? 3 : 2;\n    // extract and flatten keys\n    var keys = toArray(arguments, n).reduce(function (prev, cur) {\n      return prev.concat(cur);\n    }, []);\n    var res = [];\n    var item, key, val, j;\n    for (var i = 0, l = arr.length; i < l; i++) {\n      item = arr[i];\n      val = item && item.$value || item;\n      j = keys.length;\n      if (j) {\n        while (j--) {\n          key = keys[j];\n          if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\n            res.push(item);\n            break;\n          }\n        }\n      } else if (contains(item, search)) {\n        res.push(item);\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Filter filter for arrays\n   *\n   * @param {String} sortKey\n   * @param {String} reverse\n   */\n\n  function orderBy(arr, sortKey, reverse) {\n    arr = convertArray(arr);\n    if (!sortKey) {\n      return arr;\n    }\n    var order = reverse && reverse < 0 ? -1 : 1;\n    // sort on a copy to avoid mutating original array\n    return arr.slice().sort(function (a, b) {\n      if (sortKey !== '$key') {\n        if (isObject(a) && '$value' in a) a = a.$value;\n        if (isObject(b) && '$value' in b) b = b.$value;\n      }\n      a = isObject(a) ? getPath(a, sortKey) : a;\n      b = isObject(b) ? getPath(b, sortKey) : b;\n      return a === b ? 0 : a > b ? order : -order;\n    });\n  }\n\n  /**\n   * String contain helper\n   *\n   * @param {*} val\n   * @param {String} search\n   */\n\n  function contains(val, search) {\n    var i;\n    if (isPlainObject(val)) {\n      var keys = Object.keys(val);\n      i = keys.length;\n      while (i--) {\n        if (contains(val[keys[i]], search)) {\n          return true;\n        }\n      }\n    } else if (isArray(val)) {\n      i = val.length;\n      while (i--) {\n        if (contains(val[i], search)) {\n          return true;\n        }\n      }\n    } else if (val != null) {\n      return val.toString().toLowerCase().indexOf(search) > -1;\n    }\n  }\n\n  var digitsRE = /(\\d{3})(?=\\d)/g;\n\n  // asset collections must be a plain object.\n  var filters = {\n\n    orderBy: orderBy,\n    filterBy: filterBy,\n    limitBy: limitBy,\n\n    /**\n     * Stringify value.\n     *\n     * @param {Number} indent\n     */\n\n    json: {\n      read: function read(value, indent) {\n        return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);\n      },\n      write: function write(value) {\n        try {\n          return JSON.parse(value);\n        } catch (e) {\n          return value;\n        }\n      }\n    },\n\n    /**\n     * 'abc' => 'Abc'\n     */\n\n    capitalize: function capitalize(value) {\n      if (!value && value !== 0) return '';\n      value = value.toString();\n      return value.charAt(0).toUpperCase() + value.slice(1);\n    },\n\n    /**\n     * 'abc' => 'ABC'\n     */\n\n    uppercase: function uppercase(value) {\n      return value || value === 0 ? value.toString().toUpperCase() : '';\n    },\n\n    /**\n     * 'AbC' => 'abc'\n     */\n\n    lowercase: function lowercase(value) {\n      return value || value === 0 ? value.toString().toLowerCase() : '';\n    },\n\n    /**\n     * 12345 => $12,345.00\n     *\n     * @param {String} sign\n     */\n\n    currency: function currency(value, _currency) {\n      value = parseFloat(value);\n      if (!isFinite(value) || !value && value !== 0) return '';\n      _currency = _currency != null ? _currency : '$';\n      var stringified = Math.abs(value).toFixed(2);\n      var _int = stringified.slice(0, -3);\n      var i = _int.length % 3;\n      var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\n      var _float = stringified.slice(-3);\n      var sign = value < 0 ? '-' : '';\n      return _currency + sign + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\n    },\n\n    /**\n     * 'item' => 'items'\n     *\n     * @params\n     *  an array of strings corresponding to\n     *  the single, double, triple ... forms of the word to\n     *  be pluralized. When the number to be pluralized\n     *  exceeds the length of the args, it will use the last\n     *  entry in the array.\n     *\n     *  e.g. ['single', 'double', 'triple', 'multiple']\n     */\n\n    pluralize: function pluralize(value) {\n      var args = toArray(arguments, 1);\n      return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');\n    },\n\n    /**\n     * Debounce a handler function.\n     *\n     * @param {Function} handler\n     * @param {Number} delay = 300\n     * @return {Function}\n     */\n\n    debounce: function debounce(handler, delay) {\n      if (!handler) return;\n      if (!delay) {\n        delay = 300;\n      }\n      return _debounce(handler, delay);\n    }\n  };\n\n  var partial = {\n\n    priority: PARTIAL,\n\n    params: ['name'],\n\n    // watch changes to name for dynamic partials\n    paramWatchers: {\n      name: function name(value) {\n        vIf.remove.call(this);\n        if (value) {\n          this.insert(value);\n        }\n      }\n    },\n\n    bind: function bind() {\n      this.anchor = createAnchor('v-partial');\n      replace(this.el, this.anchor);\n      this.insert(this.params.name);\n    },\n\n    insert: function insert(id) {\n      var partial = resolveAsset(this.vm.$options, 'partials', id);\n      if ('development' !== 'production') {\n        assertAsset(partial, 'partial', id);\n      }\n      if (partial) {\n        this.factory = new FragmentFactory(this.vm, partial);\n        vIf.insert.call(this);\n      }\n    },\n\n    unbind: function unbind() {\n      if (this.frag) {\n        this.frag.destroy();\n      }\n    }\n  };\n\n  // This is the elementDirective that handles <content>\n  // transclusions. It relies on the raw content of an\n  // instance being stored as `$options._content` during\n  // the transclude phase.\n\n  // We are exporting two versions, one for named and one\n  // for unnamed, because the unnamed slots must be compiled\n  // AFTER all named slots have selected their content. So\n  // we need to give them different priorities in the compilation\n  // process. (See #1965)\n\n  var slot = {\n\n    priority: SLOT,\n\n    bind: function bind() {\n      var host = this.vm;\n      var raw = host.$options._content;\n      if (!raw) {\n        this.fallback();\n        return;\n      }\n      var context = host._context;\n      var slotName = this.params && this.params.name;\n      if (!slotName) {\n        // Default slot\n        this.tryCompile(extractFragment(raw.childNodes, raw, true), context, host);\n      } else {\n        // Named slot\n        var selector = '[slot=\"' + slotName + '\"]';\n        var nodes = raw.querySelectorAll(selector);\n        if (nodes.length) {\n          this.tryCompile(extractFragment(nodes, raw), context, host);\n        } else {\n          this.fallback();\n        }\n      }\n    },\n\n    tryCompile: function tryCompile(content, context, host) {\n      if (content.hasChildNodes()) {\n        this.compile(content, context, host);\n      } else {\n        this.fallback();\n      }\n    },\n\n    compile: function compile(content, context, host) {\n      if (content && context) {\n        var scope = host ? host._scope : this._scope;\n        this.unlink = context.$compile(content, host, scope, this._frag);\n      }\n      if (content) {\n        replace(this.el, content);\n      } else {\n        remove(this.el);\n      }\n    },\n\n    fallback: function fallback() {\n      this.compile(extractContent(this.el, true), this.vm);\n    },\n\n    unbind: function unbind() {\n      if (this.unlink) {\n        this.unlink();\n      }\n    }\n  };\n\n  var namedSlot = extend(extend({}, slot), {\n    priority: slot.priority + 1,\n    params: ['name']\n  });\n\n  /**\n   * Extract qualified content nodes from a node list.\n   *\n   * @param {NodeList} nodes\n   * @param {Element} parent\n   * @param {Boolean} main\n   * @return {DocumentFragment}\n   */\n\n  function extractFragment(nodes, parent, main) {\n    var frag = document.createDocumentFragment();\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      var node = nodes[i];\n      // if this is the main outlet, we want to skip all\n      // previously selected nodes;\n      // otherwise, we want to mark the node as selected.\n      // clone the node so the original raw content remains\n      // intact. this ensures proper re-compilation in cases\n      // where the outlet is inside a conditional block\n      if (main && !node.__v_selected) {\n        append(node);\n      } else if (!main && node.parentNode === parent) {\n        node.__v_selected = true;\n        append(node);\n      }\n    }\n    return frag;\n\n    function append(node) {\n      if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\n        node = parseTemplate(node);\n      }\n      node = cloneNode(node);\n      frag.appendChild(node);\n    }\n  }\n\n  var elementDirectives = {\n    slot: slot,\n    _namedSlot: namedSlot, // same as slot but with higher priority\n    partial: partial\n  };\n\n  Vue.version = '1.0.14';\n\n  /**\n   * Vue and every constructor that extends Vue has an\n   * associated options object, which can be accessed during\n   * compilation steps as `this.constructor.options`.\n   *\n   * These can be seen as the default options of every\n   * Vue instance.\n   */\n\n  Vue.options = {\n    directives: publicDirectives,\n    elementDirectives: elementDirectives,\n    filters: filters,\n    transitions: {},\n    components: {},\n    partials: {},\n    replace: true\n  };\n\n  // devtools global hook\n  /* istanbul ignore if */\n  if ('development' !== 'production' && inBrowser) {\n    if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {\n      window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('init', Vue);\n    } else if (/Chrome\\/\\d+/.test(navigator.userAgent)) {\n      console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n    }\n  }\n\n  return Vue;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue/dist/vue.js\n ** module id = 13\n ** module chunks = 0\n **/","/**\r\n * marked - a markdown parser\r\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\r\n * https://github.com/chjj/marked\r\n */\r\n\r\n;(function() {\r\n\r\n/**\r\n * Block-Level Grammar\r\n */\r\n\r\nvar block = {\r\n  newline: /^\\n+/,\r\n  code: /^( {4}[^\\n]+\\n*)+/,\r\n  fences: noop,\r\n  hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\r\n  heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\r\n  nptable: noop,\r\n  lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\r\n  blockquote: /^( *>[^\\n]+(\\n(?!def)[^\\n]+)*\\n*)+/,\r\n  list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\r\n  html: /^ *(?:comment *(?:\\n|\\s*$)|closed *(?:\\n{2,}|\\s*$)|closing *(?:\\n{2,}|\\s*$))/,\r\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\r\n  table: noop,\r\n  paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\r\n  text: /^[^\\n]+/\r\n};\r\n\r\nblock.bullet = /(?:[*+-]|\\d+\\.)/;\r\nblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\r\nblock.item = replace(block.item, 'gm')\r\n  (/bull/g, block.bullet)\r\n  ();\r\n\r\nblock.list = replace(block.list)\r\n  (/bull/g, block.bullet)\r\n  ('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\r\n  ('def', '\\\\n+(?=' + block.def.source + ')')\r\n  ();\r\n\r\nblock.blockquote = replace(block.blockquote)\r\n  ('def', block.def)\r\n  ();\r\n\r\nblock._tag = '(?!(?:'\r\n  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\r\n  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\r\n  + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\r\n\r\nblock.html = replace(block.html)\r\n  ('comment', /<!--[\\s\\S]*?-->/)\r\n  ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\r\n  ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\r\n  (/tag/g, block._tag)\r\n  ();\r\n\r\nblock.paragraph = replace(block.paragraph)\r\n  ('hr', block.hr)\r\n  ('heading', block.heading)\r\n  ('lheading', block.lheading)\r\n  ('blockquote', block.blockquote)\r\n  ('tag', '<' + block._tag)\r\n  ('def', block.def)\r\n  ();\r\n\r\n/**\r\n * Normal Block Grammar\r\n */\r\n\r\nblock.normal = merge({}, block);\r\n\r\n/**\r\n * GFM Block Grammar\r\n */\r\n\r\nblock.gfm = merge({}, block.normal, {\r\n  fences: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/,\r\n  paragraph: /^/,\r\n  heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/\r\n});\r\n\r\nblock.gfm.paragraph = replace(block.paragraph)\r\n  ('(?!', '(?!'\r\n    + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\r\n    + block.list.source.replace('\\\\1', '\\\\3') + '|')\r\n  ();\r\n\r\n/**\r\n * GFM + Tables Block Grammar\r\n */\r\n\r\nblock.tables = merge({}, block.gfm, {\r\n  nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\r\n  table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\r\n});\r\n\r\n/**\r\n * Block Lexer\r\n */\r\n\r\nfunction Lexer(options) {\r\n  this.tokens = [];\r\n  this.tokens.links = {};\r\n  this.options = options || marked.defaults;\r\n  this.rules = block.normal;\r\n\r\n  if (this.options.gfm) {\r\n    if (this.options.tables) {\r\n      this.rules = block.tables;\r\n    } else {\r\n      this.rules = block.gfm;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Expose Block Rules\r\n */\r\n\r\nLexer.rules = block;\r\n\r\n/**\r\n * Static Lex Method\r\n */\r\n\r\nLexer.lex = function(src, options) {\r\n  var lexer = new Lexer(options);\r\n  return lexer.lex(src);\r\n};\r\n\r\n/**\r\n * Preprocessing\r\n */\r\n\r\nLexer.prototype.lex = function(src) {\r\n  src = src\r\n    .replace(/\\r\\n|\\r/g, '\\n')\r\n    .replace(/\\t/g, '    ')\r\n    .replace(/\\u00a0/g, ' ')\r\n    .replace(/\\u2424/g, '\\n');\r\n\r\n  return this.token(src, true);\r\n};\r\n\r\n/**\r\n * Lexing\r\n */\r\n\r\nLexer.prototype.token = function(src, top, bq) {\r\n  var src = src.replace(/^ +$/gm, '')\r\n    , next\r\n    , loose\r\n    , cap\r\n    , bull\r\n    , b\r\n    , item\r\n    , space\r\n    , i\r\n    , l;\r\n\r\n  while (src) {\r\n    // newline\r\n    if (cap = this.rules.newline.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      if (cap[0].length > 1) {\r\n        this.tokens.push({\r\n          type: 'space'\r\n        });\r\n      }\r\n    }\r\n\r\n    // code\r\n    if (cap = this.rules.code.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      cap = cap[0].replace(/^ {4}/gm, '');\r\n      this.tokens.push({\r\n        type: 'code',\r\n        text: !this.options.pedantic\r\n          ? cap.replace(/\\n+$/, '')\r\n          : cap\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // fences (gfm)\r\n    if (cap = this.rules.fences.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'code',\r\n        lang: cap[2],\r\n        text: cap[3] || ''\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // heading\r\n    if (cap = this.rules.heading.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'heading',\r\n        depth: cap[1].length,\r\n        text: cap[2]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // table no leading pipe (gfm)\r\n    if (top && (cap = this.rules.nptable.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n\r\n      item = {\r\n        type: 'table',\r\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\r\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\r\n        cells: cap[3].replace(/\\n$/, '').split('\\n')\r\n      };\r\n\r\n      for (i = 0; i < item.align.length; i++) {\r\n        if (/^ *-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'right';\r\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'center';\r\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\r\n          item.align[i] = 'left';\r\n        } else {\r\n          item.align[i] = null;\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < item.cells.length; i++) {\r\n        item.cells[i] = item.cells[i].split(/ *\\| */);\r\n      }\r\n\r\n      this.tokens.push(item);\r\n\r\n      continue;\r\n    }\r\n\r\n    // lheading\r\n    if (cap = this.rules.lheading.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'heading',\r\n        depth: cap[2] === '=' ? 1 : 2,\r\n        text: cap[1]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // hr\r\n    if (cap = this.rules.hr.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'hr'\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // blockquote\r\n    if (cap = this.rules.blockquote.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n\r\n      this.tokens.push({\r\n        type: 'blockquote_start'\r\n      });\r\n\r\n      cap = cap[0].replace(/^ *> ?/gm, '');\r\n\r\n      // Pass `top` to keep the current\r\n      // \"toplevel\" state. This is exactly\r\n      // how markdown.pl works.\r\n      this.token(cap, top, true);\r\n\r\n      this.tokens.push({\r\n        type: 'blockquote_end'\r\n      });\r\n\r\n      continue;\r\n    }\r\n\r\n    // list\r\n    if (cap = this.rules.list.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      bull = cap[2];\r\n\r\n      this.tokens.push({\r\n        type: 'list_start',\r\n        ordered: bull.length > 1\r\n      });\r\n\r\n      // Get each top-level item.\r\n      cap = cap[0].match(this.rules.item);\r\n\r\n      next = false;\r\n      l = cap.length;\r\n      i = 0;\r\n\r\n      for (; i < l; i++) {\r\n        item = cap[i];\r\n\r\n        // Remove the list item's bullet\r\n        // so it is seen as the next token.\r\n        space = item.length;\r\n        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\r\n\r\n        // Outdent whatever the\r\n        // list item contains. Hacky.\r\n        if (~item.indexOf('\\n ')) {\r\n          space -= item.length;\r\n          item = !this.options.pedantic\r\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\r\n            : item.replace(/^ {1,4}/gm, '');\r\n        }\r\n\r\n        // Determine whether the next list item belongs here.\r\n        // Backpedal if it does not belong in this list.\r\n        if (this.options.smartLists && i !== l - 1) {\r\n          b = block.bullet.exec(cap[i + 1])[0];\r\n          if (bull !== b && !(bull.length > 1 && b.length > 1)) {\r\n            src = cap.slice(i + 1).join('\\n') + src;\r\n            i = l - 1;\r\n          }\r\n        }\r\n\r\n        // Determine whether item is loose or not.\r\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\r\n        // for discount behavior.\r\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\r\n        if (i !== l - 1) {\r\n          next = item.charAt(item.length - 1) === '\\n';\r\n          if (!loose) loose = next;\r\n        }\r\n\r\n        this.tokens.push({\r\n          type: loose\r\n            ? 'loose_item_start'\r\n            : 'list_item_start'\r\n        });\r\n\r\n        // Recurse.\r\n        this.token(item, false, bq);\r\n\r\n        this.tokens.push({\r\n          type: 'list_item_end'\r\n        });\r\n      }\r\n\r\n      this.tokens.push({\r\n        type: 'list_end'\r\n      });\r\n\r\n      continue;\r\n    }\r\n\r\n    // html\r\n    if (cap = this.rules.html.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: this.options.sanitize\r\n          ? 'paragraph'\r\n          : 'html',\r\n        pre: !this.options.sanitizer\r\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\r\n        text: cap[0]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // def\r\n    if ((!bq && top) && (cap = this.rules.def.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.links[cap[1].toLowerCase()] = {\r\n        href: cap[2],\r\n        title: cap[3]\r\n      };\r\n      continue;\r\n    }\r\n\r\n    // table (gfm)\r\n    if (top && (cap = this.rules.table.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n\r\n      item = {\r\n        type: 'table',\r\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\r\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\r\n        cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\r\n      };\r\n\r\n      for (i = 0; i < item.align.length; i++) {\r\n        if (/^ *-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'right';\r\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\r\n          item.align[i] = 'center';\r\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\r\n          item.align[i] = 'left';\r\n        } else {\r\n          item.align[i] = null;\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < item.cells.length; i++) {\r\n        item.cells[i] = item.cells[i]\r\n          .replace(/^ *\\| *| *\\| *$/g, '')\r\n          .split(/ *\\| */);\r\n      }\r\n\r\n      this.tokens.push(item);\r\n\r\n      continue;\r\n    }\r\n\r\n    // top-level paragraph\r\n    if (top && (cap = this.rules.paragraph.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'paragraph',\r\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\r\n          ? cap[1].slice(0, -1)\r\n          : cap[1]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // text\r\n    if (cap = this.rules.text.exec(src)) {\r\n      // Top-level should never reach here.\r\n      src = src.substring(cap[0].length);\r\n      this.tokens.push({\r\n        type: 'text',\r\n        text: cap[0]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    if (src) {\r\n      throw new\r\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\r\n    }\r\n  }\r\n\r\n  return this.tokens;\r\n};\r\n\r\n/**\r\n * Inline-Level Grammar\r\n */\r\n\r\nvar inline = {\r\n  escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\r\n  autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\r\n  url: noop,\r\n  tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\r\n  link: /^!?\\[(inside)\\]\\(href\\)/,\r\n  reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\r\n  nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\r\n  strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\r\n  em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\r\n  code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\r\n  br: /^ {2,}\\n(?!\\s*$)/,\r\n  del: noop,\r\n  text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\r\n};\r\n\r\ninline._inside = /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/;\r\ninline._href = /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\r\n\r\ninline.link = replace(inline.link)\r\n  ('inside', inline._inside)\r\n  ('href', inline._href)\r\n  ();\r\n\r\ninline.reflink = replace(inline.reflink)\r\n  ('inside', inline._inside)\r\n  ();\r\n\r\n/**\r\n * Normal Inline Grammar\r\n */\r\n\r\ninline.normal = merge({}, inline);\r\n\r\n/**\r\n * Pedantic Inline Grammar\r\n */\r\n\r\ninline.pedantic = merge({}, inline.normal, {\r\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\r\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\r\n});\r\n\r\n/**\r\n * GFM Inline Grammar\r\n */\r\n\r\ninline.gfm = merge({}, inline.normal, {\r\n  escape: replace(inline.escape)('])', '~|])')(),\r\n  url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\r\n  del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\r\n  text: replace(inline.text)\r\n    (']|', '~]|')\r\n    ('|', '|https?://|')\r\n    ()\r\n});\r\n\r\n/**\r\n * GFM + Line Breaks Inline Grammar\r\n */\r\n\r\ninline.breaks = merge({}, inline.gfm, {\r\n  br: replace(inline.br)('{2,}', '*')(),\r\n  text: replace(inline.gfm.text)('{2,}', '*')()\r\n});\r\n\r\n/**\r\n * Inline Lexer & Compiler\r\n */\r\n\r\nfunction InlineLexer(links, options) {\r\n  this.options = options || marked.defaults;\r\n  this.links = links;\r\n  this.rules = inline.normal;\r\n  this.renderer = this.options.renderer || new Renderer;\r\n  this.renderer.options = this.options;\r\n\r\n  if (!this.links) {\r\n    throw new\r\n      Error('Tokens array requires a `links` property.');\r\n  }\r\n\r\n  if (this.options.gfm) {\r\n    if (this.options.breaks) {\r\n      this.rules = inline.breaks;\r\n    } else {\r\n      this.rules = inline.gfm;\r\n    }\r\n  } else if (this.options.pedantic) {\r\n    this.rules = inline.pedantic;\r\n  }\r\n}\r\n\r\n/**\r\n * Expose Inline Rules\r\n */\r\n\r\nInlineLexer.rules = inline;\r\n\r\n/**\r\n * Static Lexing/Compiling Method\r\n */\r\n\r\nInlineLexer.output = function(src, links, options) {\r\n  var inline = new InlineLexer(links, options);\r\n  return inline.output(src);\r\n};\r\n\r\n/**\r\n * Lexing/Compiling\r\n */\r\n\r\nInlineLexer.prototype.output = function(src) {\r\n  var out = ''\r\n    , link\r\n    , text\r\n    , href\r\n    , cap;\r\n\r\n  while (src) {\r\n    // escape\r\n    if (cap = this.rules.escape.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += cap[1];\r\n      continue;\r\n    }\r\n\r\n    // autolink\r\n    if (cap = this.rules.autolink.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      if (cap[2] === '@') {\r\n        text = cap[1].charAt(6) === ':'\r\n          ? this.mangle(cap[1].substring(7))\r\n          : this.mangle(cap[1]);\r\n        href = this.mangle('mailto:') + text;\r\n      } else {\r\n        text = escape(cap[1]);\r\n        href = text;\r\n      }\r\n      out += this.renderer.link(href, null, text);\r\n      continue;\r\n    }\r\n\r\n    // url (gfm)\r\n    if (!this.inLink && (cap = this.rules.url.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      text = escape(cap[1]);\r\n      href = text;\r\n      out += this.renderer.link(href, null, text);\r\n      continue;\r\n    }\r\n\r\n    // tag\r\n    if (cap = this.rules.tag.exec(src)) {\r\n      if (!this.inLink && /^<a /i.test(cap[0])) {\r\n        this.inLink = true;\r\n      } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\r\n        this.inLink = false;\r\n      }\r\n      src = src.substring(cap[0].length);\r\n      out += this.options.sanitize\r\n        ? this.options.sanitizer\r\n          ? this.options.sanitizer(cap[0])\r\n          : escape(cap[0])\r\n        : cap[0]\r\n      continue;\r\n    }\r\n\r\n    // link\r\n    if (cap = this.rules.link.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      this.inLink = true;\r\n      out += this.outputLink(cap, {\r\n        href: cap[2],\r\n        title: cap[3]\r\n      });\r\n      this.inLink = false;\r\n      continue;\r\n    }\r\n\r\n    // reflink, nolink\r\n    if ((cap = this.rules.reflink.exec(src))\r\n        || (cap = this.rules.nolink.exec(src))) {\r\n      src = src.substring(cap[0].length);\r\n      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\r\n      link = this.links[link.toLowerCase()];\r\n      if (!link || !link.href) {\r\n        out += cap[0].charAt(0);\r\n        src = cap[0].substring(1) + src;\r\n        continue;\r\n      }\r\n      this.inLink = true;\r\n      out += this.outputLink(cap, link);\r\n      this.inLink = false;\r\n      continue;\r\n    }\r\n\r\n    // strong\r\n    if (cap = this.rules.strong.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.strong(this.output(cap[2] || cap[1]));\r\n      continue;\r\n    }\r\n\r\n    // em\r\n    if (cap = this.rules.em.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.em(this.output(cap[2] || cap[1]));\r\n      continue;\r\n    }\r\n\r\n    // code\r\n    if (cap = this.rules.code.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.codespan(escape(cap[2], true));\r\n      continue;\r\n    }\r\n\r\n    // br\r\n    if (cap = this.rules.br.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.br();\r\n      continue;\r\n    }\r\n\r\n    // del (gfm)\r\n    if (cap = this.rules.del.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.del(this.output(cap[1]));\r\n      continue;\r\n    }\r\n\r\n    // text\r\n    if (cap = this.rules.text.exec(src)) {\r\n      src = src.substring(cap[0].length);\r\n      out += this.renderer.text(escape(this.smartypants(cap[0])));\r\n      continue;\r\n    }\r\n\r\n    if (src) {\r\n      throw new\r\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\r\n    }\r\n  }\r\n\r\n  return out;\r\n};\r\n\r\n/**\r\n * Compile Link\r\n */\r\n\r\nInlineLexer.prototype.outputLink = function(cap, link) {\r\n  var href = escape(link.href)\r\n    , title = link.title ? escape(link.title) : null;\r\n\r\n  return cap[0].charAt(0) !== '!'\r\n    ? this.renderer.link(href, title, this.output(cap[1]))\r\n    : this.renderer.image(href, title, escape(cap[1]));\r\n};\r\n\r\n/**\r\n * Smartypants Transformations\r\n */\r\n\r\nInlineLexer.prototype.smartypants = function(text) {\r\n  if (!this.options.smartypants) return text;\r\n  return text\r\n    // em-dashes\r\n    .replace(/---/g, '\\u2014')\r\n    // en-dashes\r\n    .replace(/--/g, '\\u2013')\r\n    // opening singles\r\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\r\n    // closing singles & apostrophes\r\n    .replace(/'/g, '\\u2019')\r\n    // opening doubles\r\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\r\n    // closing doubles\r\n    .replace(/\"/g, '\\u201d')\r\n    // ellipses\r\n    .replace(/\\.{3}/g, '\\u2026');\r\n};\r\n\r\n/**\r\n * Mangle Links\r\n */\r\n\r\nInlineLexer.prototype.mangle = function(text) {\r\n  if (!this.options.mangle) return text;\r\n  var out = ''\r\n    , l = text.length\r\n    , i = 0\r\n    , ch;\r\n\r\n  for (; i < l; i++) {\r\n    ch = text.charCodeAt(i);\r\n    if (Math.random() > 0.5) {\r\n      ch = 'x' + ch.toString(16);\r\n    }\r\n    out += '&#' + ch + ';';\r\n  }\r\n\r\n  return out;\r\n};\r\n\r\n/**\r\n * Renderer\r\n */\r\n\r\nfunction Renderer(options) {\r\n  this.options = options || {};\r\n}\r\n\r\nRenderer.prototype.code = function(code, lang, escaped) {\r\n  if (this.options.highlight) {\r\n    var out = this.options.highlight(code, lang);\r\n    if (out != null && out !== code) {\r\n      escaped = true;\r\n      code = out;\r\n    }\r\n  }\r\n\r\n  if (!lang) {\r\n    return '<pre><code>'\r\n      + (escaped ? code : escape(code, true))\r\n      + '\\n</code></pre>';\r\n  }\r\n\r\n  return '<pre><code class=\"'\r\n    + this.options.langPrefix\r\n    + escape(lang, true)\r\n    + '\">'\r\n    + (escaped ? code : escape(code, true))\r\n    + '\\n</code></pre>\\n';\r\n};\r\n\r\nRenderer.prototype.blockquote = function(quote) {\r\n  return '<blockquote>\\n' + quote + '</blockquote>\\n';\r\n};\r\n\r\nRenderer.prototype.html = function(html) {\r\n  return html;\r\n};\r\n\r\nRenderer.prototype.heading = function(text, level, raw) {\r\n  return '<h'\r\n    + level\r\n    + ' id=\"'\r\n    + this.options.headerPrefix\r\n    + raw.toLowerCase().replace(/[^\\w]+/g, '-')\r\n    + '\">'\r\n    + text\r\n    + '</h'\r\n    + level\r\n    + '>\\n';\r\n};\r\n\r\nRenderer.prototype.hr = function() {\r\n  return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\r\n};\r\n\r\nRenderer.prototype.list = function(body, ordered) {\r\n  var type = ordered ? 'ol' : 'ul';\r\n  return '<' + type + '>\\n' + body + '</' + type + '>\\n';\r\n};\r\n\r\nRenderer.prototype.listitem = function(text) {\r\n  return '<li>' + text + '</li>\\n';\r\n};\r\n\r\nRenderer.prototype.paragraph = function(text) {\r\n  return '<p>' + text + '</p>\\n';\r\n};\r\n\r\nRenderer.prototype.table = function(header, body) {\r\n  return '<table>\\n'\r\n    + '<thead>\\n'\r\n    + header\r\n    + '</thead>\\n'\r\n    + '<tbody>\\n'\r\n    + body\r\n    + '</tbody>\\n'\r\n    + '</table>\\n';\r\n};\r\n\r\nRenderer.prototype.tablerow = function(content) {\r\n  return '<tr>\\n' + content + '</tr>\\n';\r\n};\r\n\r\nRenderer.prototype.tablecell = function(content, flags) {\r\n  var type = flags.header ? 'th' : 'td';\r\n  var tag = flags.align\r\n    ? '<' + type + ' style=\"text-align:' + flags.align + '\">'\r\n    : '<' + type + '>';\r\n  return tag + content + '</' + type + '>\\n';\r\n};\r\n\r\n// span level renderer\r\nRenderer.prototype.strong = function(text) {\r\n  return '<strong>' + text + '</strong>';\r\n};\r\n\r\nRenderer.prototype.em = function(text) {\r\n  return '<em>' + text + '</em>';\r\n};\r\n\r\nRenderer.prototype.codespan = function(text) {\r\n  return '<code>' + text + '</code>';\r\n};\r\n\r\nRenderer.prototype.br = function() {\r\n  return this.options.xhtml ? '<br/>' : '<br>';\r\n};\r\n\r\nRenderer.prototype.del = function(text) {\r\n  return '<del>' + text + '</del>';\r\n};\r\n\r\nRenderer.prototype.link = function(href, title, text) {\r\n  if (this.options.sanitize) {\r\n    try {\r\n      var prot = decodeURIComponent(unescape(href))\r\n        .replace(/[^\\w:]/g, '')\r\n        .toLowerCase();\r\n    } catch (e) {\r\n      return '';\r\n    }\r\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {\r\n      return '';\r\n    }\r\n  }\r\n  var out = '<a href=\"' + href + '\"';\r\n  if (title) {\r\n    out += ' title=\"' + title + '\"';\r\n  }\r\n  out += '>' + text + '</a>';\r\n  return out;\r\n};\r\n\r\nRenderer.prototype.image = function(href, title, text) {\r\n  var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\r\n  if (title) {\r\n    out += ' title=\"' + title + '\"';\r\n  }\r\n  out += this.options.xhtml ? '/>' : '>';\r\n  return out;\r\n};\r\n\r\nRenderer.prototype.text = function(text) {\r\n  return text;\r\n};\r\n\r\n/**\r\n * Parsing & Compiling\r\n */\r\n\r\nfunction Parser(options) {\r\n  this.tokens = [];\r\n  this.token = null;\r\n  this.options = options || marked.defaults;\r\n  this.options.renderer = this.options.renderer || new Renderer;\r\n  this.renderer = this.options.renderer;\r\n  this.renderer.options = this.options;\r\n}\r\n\r\n/**\r\n * Static Parse Method\r\n */\r\n\r\nParser.parse = function(src, options, renderer) {\r\n  var parser = new Parser(options, renderer);\r\n  return parser.parse(src);\r\n};\r\n\r\n/**\r\n * Parse Loop\r\n */\r\n\r\nParser.prototype.parse = function(src) {\r\n  this.inline = new InlineLexer(src.links, this.options, this.renderer);\r\n  this.tokens = src.reverse();\r\n\r\n  var out = '';\r\n  while (this.next()) {\r\n    out += this.tok();\r\n  }\r\n\r\n  return out;\r\n};\r\n\r\n/**\r\n * Next Token\r\n */\r\n\r\nParser.prototype.next = function() {\r\n  return this.token = this.tokens.pop();\r\n};\r\n\r\n/**\r\n * Preview Next Token\r\n */\r\n\r\nParser.prototype.peek = function() {\r\n  return this.tokens[this.tokens.length - 1] || 0;\r\n};\r\n\r\n/**\r\n * Parse Text Tokens\r\n */\r\n\r\nParser.prototype.parseText = function() {\r\n  var body = this.token.text;\r\n\r\n  while (this.peek().type === 'text') {\r\n    body += '\\n' + this.next().text;\r\n  }\r\n\r\n  return this.inline.output(body);\r\n};\r\n\r\n/**\r\n * Parse Current Token\r\n */\r\n\r\nParser.prototype.tok = function() {\r\n  switch (this.token.type) {\r\n    case 'space': {\r\n      return '';\r\n    }\r\n    case 'hr': {\r\n      return this.renderer.hr();\r\n    }\r\n    case 'heading': {\r\n      return this.renderer.heading(\r\n        this.inline.output(this.token.text),\r\n        this.token.depth,\r\n        this.token.text);\r\n    }\r\n    case 'code': {\r\n      return this.renderer.code(this.token.text,\r\n        this.token.lang,\r\n        this.token.escaped);\r\n    }\r\n    case 'table': {\r\n      var header = ''\r\n        , body = ''\r\n        , i\r\n        , row\r\n        , cell\r\n        , flags\r\n        , j;\r\n\r\n      // header\r\n      cell = '';\r\n      for (i = 0; i < this.token.header.length; i++) {\r\n        flags = { header: true, align: this.token.align[i] };\r\n        cell += this.renderer.tablecell(\r\n          this.inline.output(this.token.header[i]),\r\n          { header: true, align: this.token.align[i] }\r\n        );\r\n      }\r\n      header += this.renderer.tablerow(cell);\r\n\r\n      for (i = 0; i < this.token.cells.length; i++) {\r\n        row = this.token.cells[i];\r\n\r\n        cell = '';\r\n        for (j = 0; j < row.length; j++) {\r\n          cell += this.renderer.tablecell(\r\n            this.inline.output(row[j]),\r\n            { header: false, align: this.token.align[j] }\r\n          );\r\n        }\r\n\r\n        body += this.renderer.tablerow(cell);\r\n      }\r\n      return this.renderer.table(header, body);\r\n    }\r\n    case 'blockquote_start': {\r\n      var body = '';\r\n\r\n      while (this.next().type !== 'blockquote_end') {\r\n        body += this.tok();\r\n      }\r\n\r\n      return this.renderer.blockquote(body);\r\n    }\r\n    case 'list_start': {\r\n      var body = ''\r\n        , ordered = this.token.ordered;\r\n\r\n      while (this.next().type !== 'list_end') {\r\n        body += this.tok();\r\n      }\r\n\r\n      return this.renderer.list(body, ordered);\r\n    }\r\n    case 'list_item_start': {\r\n      var body = '';\r\n\r\n      while (this.next().type !== 'list_item_end') {\r\n        body += this.token.type === 'text'\r\n          ? this.parseText()\r\n          : this.tok();\r\n      }\r\n\r\n      return this.renderer.listitem(body);\r\n    }\r\n    case 'loose_item_start': {\r\n      var body = '';\r\n\r\n      while (this.next().type !== 'list_item_end') {\r\n        body += this.tok();\r\n      }\r\n\r\n      return this.renderer.listitem(body);\r\n    }\r\n    case 'html': {\r\n      var html = !this.token.pre && !this.options.pedantic\r\n        ? this.inline.output(this.token.text)\r\n        : this.token.text;\r\n      return this.renderer.html(html);\r\n    }\r\n    case 'paragraph': {\r\n      return this.renderer.paragraph(this.inline.output(this.token.text));\r\n    }\r\n    case 'text': {\r\n      return this.renderer.paragraph(this.parseText());\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Helpers\r\n */\r\n\r\nfunction escape(html, encode) {\r\n  return html\r\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/'/g, '&#39;');\r\n}\r\n\r\nfunction unescape(html) {\r\n  return html.replace(/&([#\\w]+);/g, function(_, n) {\r\n    n = n.toLowerCase();\r\n    if (n === 'colon') return ':';\r\n    if (n.charAt(0) === '#') {\r\n      return n.charAt(1) === 'x'\r\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\r\n        : String.fromCharCode(+n.substring(1));\r\n    }\r\n    return '';\r\n  });\r\n}\r\n\r\nfunction replace(regex, opt) {\r\n  regex = regex.source;\r\n  opt = opt || '';\r\n  return function self(name, val) {\r\n    if (!name) return new RegExp(regex, opt);\r\n    val = val.source || val;\r\n    val = val.replace(/(^|[^\\[])\\^/g, '$1');\r\n    regex = regex.replace(name, val);\r\n    return self;\r\n  };\r\n}\r\n\r\nfunction noop() {}\r\nnoop.exec = noop;\r\n\r\nfunction merge(obj) {\r\n  var i = 1\r\n    , target\r\n    , key;\r\n\r\n  for (; i < arguments.length; i++) {\r\n    target = arguments[i];\r\n    for (key in target) {\r\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\r\n        obj[key] = target[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\n\r\n/**\r\n * Marked\r\n */\r\n\r\nfunction marked(src, opt, callback) {\r\n  if (callback || typeof opt === 'function') {\r\n    if (!callback) {\r\n      callback = opt;\r\n      opt = null;\r\n    }\r\n\r\n    opt = merge({}, marked.defaults, opt || {});\r\n\r\n    var highlight = opt.highlight\r\n      , tokens\r\n      , pending\r\n      , i = 0;\r\n\r\n    try {\r\n      tokens = Lexer.lex(src, opt)\r\n    } catch (e) {\r\n      return callback(e);\r\n    }\r\n\r\n    pending = tokens.length;\r\n\r\n    var done = function(err) {\r\n      if (err) {\r\n        opt.highlight = highlight;\r\n        return callback(err);\r\n      }\r\n\r\n      var out;\r\n\r\n      try {\r\n        out = Parser.parse(tokens, opt);\r\n      } catch (e) {\r\n        err = e;\r\n      }\r\n\r\n      opt.highlight = highlight;\r\n\r\n      return err\r\n        ? callback(err)\r\n        : callback(null, out);\r\n    };\r\n\r\n    if (!highlight || highlight.length < 3) {\r\n      return done();\r\n    }\r\n\r\n    delete opt.highlight;\r\n\r\n    if (!pending) return done();\r\n\r\n    for (; i < tokens.length; i++) {\r\n      (function(token) {\r\n        if (token.type !== 'code') {\r\n          return --pending || done();\r\n        }\r\n        return highlight(token.text, token.lang, function(err, code) {\r\n          if (err) return done(err);\r\n          if (code == null || code === token.text) {\r\n            return --pending || done();\r\n          }\r\n          token.text = code;\r\n          token.escaped = true;\r\n          --pending || done();\r\n        });\r\n      })(tokens[i]);\r\n    }\r\n\r\n    return;\r\n  }\r\n  try {\r\n    if (opt) opt = merge({}, marked.defaults, opt);\r\n    return Parser.parse(Lexer.lex(src, opt), opt);\r\n  } catch (e) {\r\n    e.message += '\\nPlease report this to https://github.com/chjj/marked.';\r\n    if ((opt || marked.defaults).silent) {\r\n      return '<p>An error occured:</p><pre>'\r\n        + escape(e.message + '', true)\r\n        + '</pre>';\r\n    }\r\n    throw e;\r\n  }\r\n}\r\n\r\n/**\r\n * Options\r\n */\r\n\r\nmarked.options =\r\nmarked.setOptions = function(opt) {\r\n  merge(marked.defaults, opt);\r\n  return marked;\r\n};\r\n\r\nmarked.defaults = {\r\n  gfm: true,\r\n  tables: true,\r\n  breaks: false,\r\n  pedantic: false,\r\n  sanitize: false,\r\n  sanitizer: null,\r\n  mangle: true,\r\n  smartLists: false,\r\n  silent: false,\r\n  highlight: null,\r\n  langPrefix: 'lang-',\r\n  smartypants: false,\r\n  headerPrefix: '',\r\n  renderer: new Renderer,\r\n  xhtml: false\r\n};\r\n\r\n/**\r\n * Expose\r\n */\r\n\r\nmarked.Parser = Parser;\r\nmarked.parser = Parser.parse;\r\n\r\nmarked.Renderer = Renderer;\r\n\r\nmarked.Lexer = Lexer;\r\nmarked.lexer = Lexer.lex;\r\n\r\nmarked.InlineLexer = InlineLexer;\r\nmarked.inlineLexer = InlineLexer.output;\r\n\r\nmarked.parse = marked;\r\n\r\nif (typeof module !== 'undefined' && typeof exports === 'object') {\r\n  module.exports = marked;\r\n} else if (typeof define === 'function' && define.amd) {\r\n  define(function() { return marked; });\r\n} else {\r\n  this.marked = marked;\r\n}\r\n\r\n}).call(function() {\r\n  return this || (typeof window !== 'undefined' ? window : global);\r\n}());\r\n\n\n\n/** WEBPACK FOOTER **\n ** ../Vue-projects/lib/marked.js\n **/","<template>\n  <div id=\"app\">\n    <div class=\"container-fluid\">\n      <div class=\"row\">\n        <div class=\"col-xs-12\">\n          <toolbox></toolbox>\n          <div class=\"pull-right\">\n            <button class=\"btn btn-sm btn-success btn-raised\" @click='save'>本地缓存</button>\n            <button class=\"btn btn-sm btn-info btn-raised\" @click='read'>加载上次</button>\n            <a :href='mdDataUrl' download=\"index.md\" class=\"btn btn-sm btn-info btn-raised\" @mouseenter='createUrl(0)'>保存为.md格式</a>\n            <a :href='htmlDataUrl' download=\"index.html\" class=\"btn btn-sm btn-info btn-raised\" @mouseenter='createUrl(1)'>保存为.html格式</a>\n          </div>\n        </div>\n      </div>\n      <div class=\"work-space row\">\n        <div class=\"col-xs-6\">\n          <div class=\"well\">\n            <hr>\n            <textarea autofocus id=\"inputter\" v-model=\"article\"></textarea>\n          </div>\n        </div>\n        <div class=\"col-xs-6\">\n          <div class=\"well\">\n            <hr>\n            <output id=\"outputter\" v-html=\"article | markify\"></output>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport Vue from 'vue'\nimport marked from '../lib/marked'\nimport toolbox from './components/toolbox'\n\nVue.filter('markify', function (val) {\n  return marked(val)\n})\n\nexport default {\n  data: function () {\n    return {\n      article: '',\n      htmlDataUrl: '',\n      mdDataUrl: ''\n    }\n  },\n  ready: function () {\n    var self = this;\n    (function () {\n      var dropbox;\n      dropbox = document.getElementById(\"inputter\");\n      dropbox.addEventListener(\"dragenter\", dragenter, false);\n      dropbox.addEventListener(\"dragover\", dragover, false);\n      dropbox.addEventListener(\"drop\", drop, false);\n      function dragenter(e) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n\n      function dragover(e) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n\n      function drop(e) {\n        e.stopPropagation();\n        e.preventDefault();\n\n        var dt = e.dataTransfer;\n        var files = dt.files;\n\n        var fileReader = new FileReader();\n        fileReader.readAsText(files[0], 'UTF-8');\n        fileReader.onloadend = function (e) {\n          self.article = e.target.result\n        }\n      }\n    })()\n  },\n  computed: {\n    outputHtml: function () {\n      return marked(this.article)\n    }\n  },\n  components: {\n    toolbox\n  },\n  methods: {\n    save: function () {\n      localStorage.article = this.article\n      swal('本地缓存成功', '请勿清空浏览器信息', 'success')\n    },\n    read: function () {\n      this.article = localStorage.article\n    },\n    createUrl: function (mode) {\n      var self = this\n      var val = ''\n      if (mode == 0) {\n        val = self.article\n        var blobObj = new Blob([val])\n        var objectURL = URL.createObjectURL(blobObj)\n        self.mdDataUrl = objectURL\n      } else {\n        val = self.outputHtml\n        var blobObj = new Blob([val])\n        var objectURL = URL.createObjectURL(blobObj)\n        self.htmlDataUrl = objectURL\n      }\n    }\n  }\n}\n</script>\n\n<style lang=less>\nbody {\n  font-family: microsoft yahei, Helvetica, sans-serif;\n  background: #fff;\n}\nhtml,\nbody,\nbody > #app,\nbody > #app > .container-fluid {\n  height: 100%;\n  overflow: hidden;\n}\n#app > .container-fluid {\n  position: relative;\n  height: 100%;\n  .work-space {\n    height: 90%;\n    .col-xs-6 {\n      height: 100%;\n      .well {\n        height: 100%;\n        #inputter,\n        #outputter {\n          width: 100%;\n          height: 90%;\n          border: none;\n          resize: none;\n          overflow-y: auto;\n          overflow-x: hidden;\n          &::-webkit-scrollbar {\n            background-color: #eee;\n            width: 5px;\n            border-radius: 10px;\n          }\n          &::-webkit-scrollbar-thumb {\n            background-color: rgba(0, 0, 0, 0.2);\n            border-radius: 10px;\n          }\n        }\n      }\n    }\n  }\n}\n\n</style>\n\n\n\n/** WEBPACK FOOTER **\n ** App.vue?2a692092\n **/","<template>\r\n\t<div class=\"btn-group btn-group-xs\" role=\"group\" aria-label=\"...\">\r\n\t    <button type=\"button\" class=\"btn btn-default btn-raised\" @click='insert(\"#\")'>标题</button>\r\n\t    <button type=\"button\" class=\"btn btn-default btn-raised\" @click='insert(\">\")'>引用</button>\r\n\t    <button type=\"button\" class=\"btn btn-default btn-raised\" @click='insert(\"\\n- \")'>列表</button>\r\n\t    <button type=\"button\" class=\"btn btn-default btn-raised\" @click='insert(\"\\n    \")'>代码快</button>\r\n\t    <button type=\"button\" class=\"btn btn-default btn-raised\" @click='insert(\"\\n***\\n\")'>分割线</button>\r\n\t    <button type=\"button\" class=\"btn btn-default btn-raised\" @click='insert(\"[描述](http://example.com/)\")'>链接</button>\r\n\t    <button type=\"button\" class=\"btn btn-default btn-raised\" @click='insert(\"*content*\")'>斜体</button>\r\n\t    <button type=\"button\" class=\"btn btn-default btn-raised\" @click='insert(\"**content**\")'>强调</button>\r\n\t    <button type=\"button\" class=\"btn btn-default btn-raised\" @click='insert(\"`code`\")'>代码</button>\r\n\t    <button type=\"button\" class=\"btn btn-default btn-raised\" @click='insert(\"![替代文字](example.img)\")'>图片</button>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n\texport default {\r\n\t\tmethods: {\r\n\t    insert: function (myValue) {\r\n\t      //IE support \r\n\t      var myField = document.getElementById('inputter')\r\n\t      if (document.selection) { \r\n\t        myField.focus() \r\n\t        sel = document.selection.createRange() \r\n\t        sel.text = myValue \r\n\t        sel.select() \r\n\t      } \r\n\t      //MOZILLA/NETSCAPE support \r\n\t      else if (myField.selectionStart || myField.selectionStart == '0') { \r\n\t        var startPos = myField.selectionStart \r\n\t        var endPos = myField.selectionEnd \r\n\t        // save scrollTop before insert \r\n\t        var restoreTop = myField.scrollTop \r\n\t        myField.value = myField.value.substring(0, startPos) + myValue + myField.value.substring(endPos,myField.value.length) \r\n\t        if (restoreTop > 0) { \r\n\t          // restore previous scrollTop \r\n\t          myField.scrollTop = restoreTop \r\n\t        } \r\n\t          myField.focus() \r\n\t          myField.selectionStart = startPos + myValue.length \r\n\t          myField.selectionEnd = startPos + myValue.length \r\n\t      } else { \r\n\t          myField.value += myValue \r\n\t          myField.focus() \r\n\t        } \r\n\t    }\r\n\t  }\r\n\t}\r\n</script>\n\n\n/** WEBPACK FOOTER **\n ** toolbox.vue?623dace8\n **/","module.exports = { \"default\": require(\"core-js/library/fn/symbol\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/symbol.js\n ** module id = 17\n ** module chunks = 0\n **/","\"use strict\";\n\nvar _Symbol = require(\"babel-runtime/core-js/symbol\")[\"default\"];\n\nexports[\"default\"] = function (obj) {\n  return obj && obj.constructor === _Symbol ? \"symbol\" : typeof obj;\n};\n\nexports.__esModule = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/typeof.js\n ** module id = 18\n ** module chunks = 0\n **/","require('../../modules/es6.symbol');\nrequire('../../modules/es6.object.to-string');\nmodule.exports = require('../../modules/$.core').Symbol;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/fn/symbol/index.js\n ** module id = 19\n ** module chunks = 0\n **/","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.a-function.js\n ** module id = 20\n ** module chunks = 0\n **/","var isObject = require('./$.is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.an-object.js\n ** module id = 21\n ** module chunks = 0\n **/","// optional / simple context binding\nvar aFunction = require('./$.a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.ctx.js\n ** module id = 22\n ** module chunks = 0\n **/","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.defined.js\n ** module id = 23\n ** module chunks = 0\n **/","// all enumerable object keys, includes symbols\nvar $ = require('./$');\nmodule.exports = function(it){\n  var keys       = $.getKeys(it)\n    , getSymbols = $.getSymbols;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = $.isEnum\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);\n  }\n  return keys;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.enum-keys.js\n ** module id = 24\n ** module chunks = 0\n **/","var global    = require('./$.global')\n  , core      = require('./$.core')\n  , ctx       = require('./$.ctx')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && key in target;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(param){\n        return this instanceof C ? new C(param) : C(param);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n  }\n};\n// type bitmap\n$export.F = 1;  // forced\n$export.G = 2;  // global\n$export.S = 4;  // static\n$export.P = 8;  // proto\n$export.B = 16; // bind\n$export.W = 32; // wrap\nmodule.exports = $export;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.export.js\n ** module id = 25\n ** module chunks = 0\n **/","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./$.to-iobject')\n  , getNames  = require('./$').getNames\n  , toString  = {}.toString;\n\nvar windowNames = typeof window == 'object' && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return getNames(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.get = function getOwnPropertyNames(it){\n  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);\n  return getNames(toIObject(it));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.get-names.js\n ** module id = 26\n ** module chunks = 0\n **/","var $          = require('./$')\n  , createDesc = require('./$.property-desc');\nmodule.exports = require('./$.descriptors') ? function(object, key, value){\n  return $.setDesc(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.hide.js\n ** module id = 27\n ** module chunks = 0\n **/","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./$.cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iobject.js\n ** module id = 28\n ** module chunks = 0\n **/","// 7.2.2 IsArray(argument)\nvar cof = require('./$.cof');\nmodule.exports = Array.isArray || function(arg){\n  return cof(arg) == 'Array';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.is-array.js\n ** module id = 29\n ** module chunks = 0\n **/","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.is-object.js\n ** module id = 30\n ** module chunks = 0\n **/","var $         = require('./$')\n  , toIObject = require('./$.to-iobject');\nmodule.exports = function(object, el){\n  var O      = toIObject(object)\n    , keys   = $.getKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.keyof.js\n ** module id = 31\n ** module chunks = 0\n **/","module.exports = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.library.js\n ** module id = 32\n ** module chunks = 0\n **/","module.exports = require('./$.hide');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.redefine.js\n ** module id = 33\n ** module chunks = 0\n **/","var def = require('./$').setDesc\n  , has = require('./$.has')\n  , TAG = require('./$.wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.set-to-string-tag.js\n ** module id = 34\n ** module chunks = 0\n **/","'use strict';\n// ECMAScript 6 symbols shim\nvar $              = require('./$')\n  , global         = require('./$.global')\n  , has            = require('./$.has')\n  , DESCRIPTORS    = require('./$.descriptors')\n  , $export        = require('./$.export')\n  , redefine       = require('./$.redefine')\n  , $fails         = require('./$.fails')\n  , shared         = require('./$.shared')\n  , setToStringTag = require('./$.set-to-string-tag')\n  , uid            = require('./$.uid')\n  , wks            = require('./$.wks')\n  , keyOf          = require('./$.keyof')\n  , $names         = require('./$.get-names')\n  , enumKeys       = require('./$.enum-keys')\n  , isArray        = require('./$.is-array')\n  , anObject       = require('./$.an-object')\n  , toIObject      = require('./$.to-iobject')\n  , createDesc     = require('./$.property-desc')\n  , getDesc        = $.getDesc\n  , setDesc        = $.setDesc\n  , _create        = $.create\n  , getNames       = $names.get\n  , $Symbol        = global.Symbol\n  , $JSON          = global.JSON\n  , _stringify     = $JSON && $JSON.stringify\n  , setter         = false\n  , HIDDEN         = wks('_hidden')\n  , isEnum         = $.isEnum\n  , SymbolRegistry = shared('symbol-registry')\n  , AllSymbols     = shared('symbols')\n  , useNative      = typeof $Symbol == 'function'\n  , ObjectProto    = Object.prototype;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n  return _create(setDesc({}, 'a', {\n    get: function(){ return setDesc(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = getDesc(ObjectProto, key);\n  if(protoDesc)delete ObjectProto[key];\n  setDesc(it, key, D);\n  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);\n} : setDesc;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _create($Symbol.prototype);\n  sym._k = tag;\n  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {\n    configurable: true,\n    set: function(value){\n      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    }\n  });\n  return sym;\n};\n\nvar isSymbol = function(it){\n  return typeof it == 'symbol';\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(D && has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _create(D, {enumerable: createDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return setDesc(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key);\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]\n    ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  var D = getDesc(it = toIObject(it), key);\n  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = getNames(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);\n  return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var names  = getNames(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);\n  return result;\n};\nvar $stringify = function stringify(it){\n  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n  var args = [it]\n    , i    = 1\n    , $$   = arguments\n    , replacer, $replacer;\n  while($$.length > i)args.push($$[i++]);\n  replacer = args[1];\n  if(typeof replacer == 'function')$replacer = replacer;\n  if($replacer || !isArray(replacer))replacer = function(key, value){\n    if($replacer)value = $replacer.call(this, key, value);\n    if(!isSymbol(value))return value;\n  };\n  args[1] = replacer;\n  return _stringify.apply($JSON, args);\n};\nvar buggyJSON = $fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n});\n\n// 19.4.1.1 Symbol([description])\nif(!useNative){\n  $Symbol = function Symbol(){\n    if(isSymbol(this))throw TypeError('Symbol is not a constructor');\n    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));\n  };\n  redefine($Symbol.prototype, 'toString', function toString(){\n    return this._k;\n  });\n\n  isSymbol = function(it){\n    return it instanceof $Symbol;\n  };\n\n  $.create     = $create;\n  $.isEnum     = $propertyIsEnumerable;\n  $.getDesc    = $getOwnPropertyDescriptor;\n  $.setDesc    = $defineProperty;\n  $.setDescs   = $defineProperties;\n  $.getNames   = $names.get = $getOwnPropertyNames;\n  $.getSymbols = $getOwnPropertySymbols;\n\n  if(DESCRIPTORS && !require('./$.library')){\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n}\n\nvar symbolStatics = {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    return keyOf(SymbolRegistry, key);\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n};\n// 19.4.2.2 Symbol.hasInstance\n// 19.4.2.3 Symbol.isConcatSpreadable\n// 19.4.2.4 Symbol.iterator\n// 19.4.2.6 Symbol.match\n// 19.4.2.8 Symbol.replace\n// 19.4.2.9 Symbol.search\n// 19.4.2.10 Symbol.species\n// 19.4.2.11 Symbol.split\n// 19.4.2.12 Symbol.toPrimitive\n// 19.4.2.13 Symbol.toStringTag\n// 19.4.2.14 Symbol.unscopables\n$.each.call((\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +\n  'species,split,toPrimitive,toStringTag,unscopables'\n).split(','), function(it){\n  var sym = wks(it);\n  symbolStatics[it] = useNative ? sym : wrap(sym);\n});\n\nsetter = true;\n\n$export($export.G + $export.W, {Symbol: $Symbol});\n\n$export($export.S, 'Symbol', symbolStatics);\n\n$export($export.S + $export.F * !useNative, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});\n\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/es6.symbol.js\n ** module id = 36\n ** module chunks = 0\n **/","module.exports = \"<div id=app><div class=container-fluid><div class=row><div class=col-xs-12><toolbox></toolbox><div class=pull-right><button class=\\\"btn btn-sm btn-success btn-raised\\\" @click=save>本地缓存</button> <button class=\\\"btn btn-sm btn-info btn-raised\\\" @click=read>加载上次</button> <a :href=mdDataUrl download=index.md class=\\\"btn btn-sm btn-info btn-raised\\\" @mouseenter=createUrl(0)>保存为.md格式</a> <a :href=htmlDataUrl download=index.html class=\\\"btn btn-sm btn-info btn-raised\\\" @mouseenter=createUrl(1)>保存为.html格式</a></div></div></div><div class=\\\"work-space row\\\"><div class=col-xs-6><div class=well><hr><textarea autofocus id=inputter v-model=article></textarea></div></div><div class=col-xs-6><div class=well><hr><output id=outputter v-html=\\\"article | markify\\\"></output></div></div></div></div></div>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-html-loader!./~/vue-loader/lib/selector.js?type=template&index=0!./src/App.vue\n ** module id = 38\n ** module chunks = 0\n **/","module.exports = \"<div class=\\\"btn-group btn-group-xs\\\" role=group aria-label=...><button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;#&quot;)>标题</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=\\\"insert(&quot;>&quot;)\\\">引用</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=\\\"insert(&quot;\\\\n- &quot;)\\\">列表</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=\\\"insert(&quot;\\\\n    &quot;)\\\">代码快</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;\\\\n***\\\\n&quot;)>分割线</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;[描述](http://example.com/)&quot;)>链接</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;*content*&quot;)>斜体</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;**content**&quot;)>强调</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=\\\"insert(&quot;`code`&quot;)\\\">代码</button> <button type=button class=\\\"btn btn-default btn-raised\\\" @click=insert(&quot;![替代文字](example.img)&quot;)>图片</button></div>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-html-loader!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/toolbox.vue\n ** module id = 39\n ** module chunks = 0\n **/","var __vue_script__, __vue_template__\nrequire(\"-!./../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader?sourceMap!./../node_modules/vue-loader/lib/style-rewriter.js?id=_v-6746a777&file=App.vue!less-loader?sourceMap!./../node_modules/vue-loader/lib/selector.js?type=style&index=0!./App.vue\")\n__vue_script__ = require(\"-!babel!eslint!./../node_modules/vue-loader/lib/selector.js?type=script&index=0!./App.vue\")\n__vue_template__ = require(\"-!vue-html-loader!./../node_modules/vue-loader/lib/selector.js?type=template&index=0!./App.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) { (typeof module.exports === \"function\" ? module.exports.options : module.exports).template = __vue_template__ }\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"E:\\\\Vue-projects\\\\src\\\\App.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/App.vue\n ** module id = 40\n ** module chunks = 0\n **/","var __vue_script__, __vue_template__\n__vue_script__ = require(\"-!babel!eslint!./../../node_modules/vue-loader/lib/selector.js?type=script&index=0!./toolbox.vue\")\n__vue_template__ = require(\"-!vue-html-loader!./../../node_modules/vue-loader/lib/selector.js?type=template&index=0!./toolbox.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) { (typeof module.exports === \"function\" ? module.exports.options : module.exports).template = __vue_template__ }\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), true)\n  if (!hotAPI.compatible) return\n  var id = \"E:\\\\Vue-projects\\\\src\\\\components\\\\toolbox.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/components/toolbox.vue\n ** module id = 41\n ** module chunks = 0\n **/"],"sourceRoot":""}